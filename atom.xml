<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>赵KK的个人博客</title>
  
  <subtitle>纠结体本体,同步记录日常笔记，Write the code, Change the world！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://kkget.github.io/"/>
  <updated>2021-04-14T06:54:27.951Z</updated>
  <id>http://kkget.github.io/</id>
  
  <author>
    <name>赵KK</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>分布式服务100问</title>
    <link href="http://kkget.github.io/2021/04/14/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1100%E9%97%AE/"/>
    <id>http://kkget.github.io/2021/04/14/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1100%E9%97%AE/</id>
    <published>2021-04-14T06:52:58.000Z</published>
    <updated>2021-04-14T06:54:27.951Z</updated>
    
    <content type="html"><![CDATA[<p>1.简述CAP理论<br>一致性 C<br>可用性 A<br>分区容错性P  网络分区必定存在节点丢包问题<br>2.简述BASE理论<br>BASE模型<br>BA：基本可用<br>S：软状态，状态可以在一段时间内不同步<br>E：最终一致<br>BASE思想可以解决案例一一致性问题<br>3.数据一致性模型<br>强一致性<br>弱一致性<br>最终一致性<br>因果一致性:因果关系顺序得到保证<br>会话一致性：分布式session一致性问题<br>4.Quorum，WARO机制(选举算法，主从架构)<br>Write all read one(WARO):只要有一个节点存活仍能提供读服务<br> Quorum  对WARO条件进行松弛，对读写服务可用性做折中，保证读取到最新的 ，配合版本号     10-N+1个节点保证读取最新的<br>kafka  ack.all<br>5.paxos算法 一致性算法  算法模型  raft  zab<br>一种思想<br>6.负载均衡策略有哪些<br>.随机<br>.轮询<br>.一致性哈希<br>.加权<br>.最小连接数<br>.源地址哈希<br>7.集群  分布式    SOA,微服务</p><p>8.分布式事务的解决方案？涉及到两个数据源，不同机器的DB访问<br>XA协议:<br>事务补偿：TCC<br>事务消息MQ<br>两阶段提交，三阶段提交，TCC、<br>两阶段提交协议：准备阶段，提交阶段<br>三阶段提交协议：询问阶段，准备阶段，提交阶段<br>TCC协议：Try，Confirm，Cancel，先执行try，没问题执行confirm，如果出现问题执行Cancel<br>9.如何理解RPC   远程协议调用</p><p>10.ZK得选举和崩溃选举过程  改投时需要更新信息，并广播<br>—集群初始化选举<br>1.2.3.4.5<br>依次比较.半数同意3为主节点其他为follower</p><p>—崩溃选举  Leader E</p><p>follower进入looking状态<br>半数转为leader  节点内为二进制数组，存储节点数据<br>11简述zk的数据模型<br>持久节点：有子节点<br>临时：没有子节点信息<br>有序<br>12zk数据同步原理</p><p>一共四类<br>13 zk的watch机制实现原理</p><p>1.new Zookeeper<br>2.动态添加  getData exists getChildren<br>14zk的分布式锁原理</p><p>创建一个临时节点，如果自己不是第一个节点  就对上一个节点加监听器watch<br>上一个节点释放锁就排到前面去，解决惊群效应，临时节点会自动释锁，来避免死锁<br>惊群效应:如果多个服务其中一个服务挂掉，那么锁释放的时候不会唤醒所有线程<br><a href="https://blog.csdn.net/second60/article/details/81252106" target="_blank" rel="noopener">https://blog.csdn.net/second60/article/details/81252106</a></p><p>最后等待锁的线程太长，容易线程饿死<br>15：简述zk的应用场景<br>数据节点丰富，watch机制<br>znode只能放1M数据，用来存储配置信息<br>能做的很多，但是否最合适要另论</p><p>16zk中一个客户端修改了某个节点的数据，其他客户端能够马上获取到这个最新数据吗<br>ZAB协议  数据同步<br>能读到  但是需要加sync参数，不加读到的是老版本的数据<br>17请谈谈ZK对事务性的支持<br>依赖于函数操作<br>zoo_create_op_init<br>zoo_muti提交事务返回值是第一个失败状态操作的状态信号<br>18简述zk中的观察者机制<br>动态扩展zookeeper集群又不会降低性能，添加的是observer类型<br>负责同步leader同步过来的数据</p><p>19zk的会话管理机制</p><p>20Dubbo是什么？能做什么？<br>1.远程通讯<br>2.集群容错<br>3.自动发现<br>21能说下Dubbo的工作流程吗</p><p>22简述dubbo的SPI机制</p><p>23为什么 Dubbo 不用 JDK 的 SPI，而是要自己实现?</p><p>24简述dubbo服务暴露过程</p><p>25简述dubbo服务引入过程</p><p>26简述dubbo服务调用过程</p><p>27dubbo中Zk集群挂掉，发布者和订阅者还能通信么</p><p>28   zk实际如何存储dubbo生产者和消费者信息</p><p>29存储拆分后如何解决唯一主键<br>雪花算法<br>强依赖于时钟<br>30分布式session</p><p>IP绑定存在ip动态，服务宕机<br>redis的话可以跨平台，跨语言</p><p>31如何实现分库分表</p><p>32定时任务实现原理<br>Timer 优先级队列  BlockingQueue<br>小顶堆  数据结构  子节点大于父节点</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.简述CAP理论&lt;br&gt;一致性 C&lt;br&gt;可用性 A&lt;br&gt;分区容错性P  网络分区必定存在节点丢包问题&lt;br&gt;2.简述BASE理论&lt;br&gt;BASE模型&lt;br&gt;BA：基本可用&lt;br&gt;S：软状态，状态可以在一段时间内不同步&lt;br&gt;E：最终一致&lt;br&gt;BASE思想可以解决案例
      
    
    </summary>
    
    
    
      <category term="面经" scheme="http://kkget.github.io/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>拼多多面试题整理</title>
    <link href="http://kkget.github.io/2021/03/11/%E6%8B%BC%E5%A4%9A%E5%A4%9A%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/"/>
    <id>http://kkget.github.io/2021/03/11/%E6%8B%BC%E5%A4%9A%E5%A4%9A%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/</id>
    <published>2021-03-11T08:35:50.000Z</published>
    <updated>2021-03-22T00:22:00.572Z</updated>
    
    <content type="html"><![CDATA[<h2 id="讲一讲观察者模式"><a href="#讲一讲观察者模式" class="headerlink" title="讲一讲观察者模式"></a>讲一讲观察者模式</h2><p>简单来讲观察者模式，就是当⼀个⾏为发⽣时传递信息给另外⼀个⽤户接收做出相应的处理，<br>两者之间没有直接的耦合关联。MQ服务，虽然MQ服务是有⼀个通知中⼼并不是每⼀个类服务进⾏通知，但整体上也可以算作是观察者<br>模式的思路设计</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/pdd1.png" alt="观察者模式" title>                </div>                <div class="image-caption">观察者模式</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/pdd2.png" alt="观察者模式" title>                </div>                <div class="image-caption">观察者模式</div>            </figure><h2 id="topK问题"><a href="#topK问题" class="headerlink" title="topK问题"></a>topK问题</h2><p>不太清楚问的是linux的topk问题还是算法问题</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/topk.jpg" alt="观察者模式" title>                </div>                <div class="image-caption">观察者模式</div>            </figure><p>设想<br>kk.get():<br>有没有一种结构  把数据自动排序<br>kk.get():<br>像二叉树那样  但是数据是按着最大的在根节点的<br>kk.get():<br>最小的在最左最末尾节点的<br>topk问题能不能放在文件中用linux命令筛选<br>1.冒泡<br>2.快排<br>3.局部排序</p><h2 id="redis，十几万条已排好的数据在redis里，这时新来了一条数据，怎么快速更新排行榜"><a href="#redis，十几万条已排好的数据在redis里，这时新来了一条数据，怎么快速更新排行榜" class="headerlink" title="redis，十几万条已排好的数据在redis里，这时新来了一条数据，怎么快速更新排行榜?"></a>redis，十几万条已排好的数据在redis里，这时新来了一条数据，怎么快速更新排行榜?</h2><p>redis自身不是能够更新排序的，一条命令不就排完了么？</p><h2 id="synchronized可以修饰类吗？"><a href="#synchronized可以修饰类吗？" class="headerlink" title="synchronized可以修饰类吗？"></a>synchronized可以修饰类吗？</h2><p>可以<br>A. 无论synchronized关键字加在方法上还是对象上，如果它作用的对象是非静态的，则它取得的锁是对象；如果synchronized作用的对象是一个静态方法或一个类，则它取得的锁是对类，该类所有的对象同一把锁。<br>B. 每个对象只有一个锁（lock）与之相关联，谁拿到这个锁谁就可以运行它所控制的那段代码。<br>C. 实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制</p><h2 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h2><p>1.自我介绍<br>2.在项目中都做了什么？（详细）<br>3.学过哪些课？编译原理课的内容<br>4.笔试题第一题思路<br>5.笔试题第二题思路<br>6.网络7层模型<br>7.Tcp和udp位于哪一层<br>8.Ip寻址流程<br>9.Tcp和udp的区别<br>10.进程和线程的区别<br>11.Java调度进程和线程<br>12.Hashmap的结构<br>13.String和Stringbuffer的区别<br>14.你用过哪些设计模式<br>15.静态实现<br>16.动态实现<br>17.观察者模式<br>18.观察者模式的使用场景<br>19.e-r图<br>20.Jvm内存区域划分<br>21.一个对象从进入堆区到死亡的全流程<br>22.数据库索引的实现<br>23.介绍B 树<br>24.数据库两种存储引擎的区别<br>25.为什么myisam不支持行锁<br>26.写代码：</p><p>记录：id, status<br>存储：256库*256表<br>场景：需要扫描所有数据，找出所有status=2的id列表<br>要求：同一份代码，部署20台服务器，速度快，且每一张表不会被扫描2次</p><p>二面</p><p>1.自我介绍<br>2.项目都做了什么？（详细）<br>3.具体用到的技术？<br>4.深度学习模块怎么实现？<br>5.问了问nlp流程<br>6.nlp模型各部分的作用<br>7.神经网络训练的原理<br>8.训练集和测试集的比例<br>9.用了哪些设计模式<br>10.Spring aop怎么实现？<br>11.Mysql索引的实现<br>12.使用b 树的理由<br>13.B 树做索引比红黑树好在哪里？<br>14.项目里Redis怎么用<br>15.分布式缓存可能出现的问题<br>16.分布式锁<br>17.Setnx加锁的原理<br>18.怎么解除分布式锁？<br>19.Jvm内存区域划分<br>20.程序计数器的作用<br>21.本地方法栈和虚拟机栈的区别<br>22.Gc全流程<br>23.Gc算法<br>24.连接过程中什么时候会出现time_wait状态<br>25.为什么要有time_wait状态<br>26.一致性hash了解吗？<br>27.一致性hash的优点？<br>28.<strong>设计题：</strong>有一个服务器专门接收大量请求，怎么设计？<br>29.同步和异步的区别<br>30.非阻塞io和阻塞式io的区别<br>31.http如何保持连接<br>32.如果不用http，如何保持连接<br>33.Volatile 关键字的作用<br>34.Volatile 关键字的实现<br>35.用户态和内核态的区别<br>36.lru了解吗？<br>37.怎么实现lru？<br>38.布隆过滤器了解吗？<br>39.<strong>算法题：</strong>二叉树前序遍历非递归</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;讲一讲观察者模式&quot;&gt;&lt;a href=&quot;#讲一讲观察者模式&quot; class=&quot;headerlink&quot; title=&quot;讲一讲观察者模式&quot;&gt;&lt;/a&gt;讲一讲观察者模式&lt;/h2&gt;&lt;p&gt;简单来讲观察者模式，就是当⼀个⾏为发⽣时传递信息给另外⼀个⽤户接收做出相应的处理，&lt;br&gt;两
      
    
    </summary>
    
    
    
      <category term="面经" scheme="http://kkget.github.io/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>Redis面试专题</title>
    <link href="http://kkget.github.io/2021/02/24/Redis%E9%9D%A2%E8%AF%95/"/>
    <id>http://kkget.github.io/2021/02/24/Redis%E9%9D%A2%E8%AF%95/</id>
    <published>2021-02-24T03:09:15.000Z</published>
    <updated>2021-03-01T01:36:34.070Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis如何做持久化的？"><a href="#Redis如何做持久化的？" class="headerlink" title="Redis如何做持久化的？"></a>Redis如何做持久化的？</h1><p>bgsave做全量持久化到RDB二进制文件中，aof做增量持久化，存储的是文本协议数据。  </p><h1 id="它们的优缺点呢？"><a href="#它们的优缺点呢？" class="headerlink" title="它们的优缺点呢？"></a>它们的优缺点呢？</h1><p>rdb二进制文件启动加载速度可以更快，aof要重放命令，所以速度比较慢<br>rdb,aof<br>RDB  快<br>浪费空间  消费性能  会丢失数据<br>AOF  备份稳健   默认取AOF得<br>占用空间   存在bug<br>RDB:Redis默认的持久化机制,将内存数据库快照保存在名字为 dump.rdb 的二进制文件中.RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘,实际操作过程是fork一个子进程,先将数据集写入临时文件,写入成功后,再替换之前的文件,用二进制压缩存储.[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传</p><p>​            优点:(1)整个持久化文件只有一个,方便备份.(2)性能最大化,持久化采用fork子进程,避免了主进程的IO操作.(3).相比于AOF,持久化的数据加载快,启动效率高.</p><p>​            缺点:(1)在定时持久化之前出现宕机现象,此前没有来得及写入磁盘的数据都将丢失.(2)由于RDB是通过fork子进程来协助完成数据持久化工作的,因此,如果当数据集较大时,可能会导致整个服务器停止服务几百毫秒,甚至是1秒钟</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/rdb.jpg" alt="jvm分区" title>                </div>                <div class="image-caption">jvm分区</div>            </figure><p>​        AOF:AOF持久化以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录。</p><p>​        优点:(1) 该机制可以带来更高的数据安全性,即数据持久性。(2). 由于该机制对日志文件的写入操作采用的是append模式,因此在写入过程中即使出现宕机现象,也不会破坏日志文件中已经存在的内容.(3).AOF包含一个格式清晰,易于理解的日志文件用于记录所有的修改操作.</p><p>​        缺点:(1).AOF文件记录的所有操作过程,比rdb文件大,启动恢复速度比rdb慢.(2).根据同步策略的不同,AOF在运行效率上往往会慢于RDB.总之,每秒同步策略的效率是比较高的,同步禁用策略的效率和RDB一样高效.</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/aof.jpg" alt="jvm分区" title>                </div>                <div class="image-caption">jvm分区</div>            </figure><h1 id="Redis持久化期间，主进程还能对外提供服务吗？"><a href="#Redis持久化期间，主进程还能对外提供服务吗？" class="headerlink" title="Redis持久化期间，主进程还能对外提供服务吗？"></a>Redis持久化期间，主进程还能对外提供服务吗？</h1><p> 能</p><h1 id="那Redis如何处理新写入的数据呢，这个数据也会直接进行持久化吗？"><a href="#那Redis如何处理新写入的数据呢，这个数据也会直接进行持久化吗？" class="headerlink" title="那Redis如何处理新写入的数据呢，这个数据也会直接进行持久化吗？"></a>那Redis如何处理新写入的数据呢，这个数据也会直接进行持久化吗？</h1><p>。。。这个可能吧!     </p><h1 id="Reids可以设置最大内存大小，如果数据达到了内存最大限制，Redis如何处理呢？"><a href="#Reids可以设置最大内存大小，如果数据达到了内存最大限制，Redis如何处理呢？" class="headerlink" title="Reids可以设置最大内存大小，如果数据达到了内存最大限制，Redis如何处理呢？"></a>Reids可以设置最大内存大小，如果数据达到了内存最大限制，Redis如何处理呢？</h1><p>可以配置淘汰策略 LRU 或者 LFU 淘汰策略。</p><h1 id="Redis-的LRU算法实现原理，可以讲讲吗？"><a href="#Redis-的LRU算法实现原理，可以讲讲吗？" class="headerlink" title="Redis 的LRU算法实现原理，可以讲讲吗？"></a>Redis 的LRU算法实现原理，可以讲讲吗？</h1><p>这个不太清楚。</p><p>图片</p><h1 id="Redis-核心数据类型有哪些？"><a href="#Redis-核心数据类型有哪些？" class="headerlink" title="Redis 核心数据类型有哪些？"></a>Redis 核心数据类型有哪些？</h1><p> string, hash, list, set, zset.</p><h1 id="存储数据用-string-类型-和-hash-类型，你是如何选择的呢？"><a href="#存储数据用-string-类型-和-hash-类型，你是如何选择的呢？" class="headerlink" title="存储数据用 string 类型 和 hash 类型，你是如何选择的呢？"></a>存储数据用 string 类型 和 hash 类型，你是如何选择的呢？</h1><p>string 对大量字段的对象中的某个数据进行获取，需要进行整体的数据获取，在客户端完成反序列化，而hash可以获取指定字段获取数据。所以根据访问需求来选择。</p><h1 id="还有其他的考虑吗？"><a href="#还有其他的考虑吗？" class="headerlink" title="还有其他的考虑吗？"></a>还有其他的考虑吗？</h1><p>没有</p><h1 id="zset-底层的实现原理有了解过吗？"><a href="#zset-底层的实现原理有了解过吗？" class="headerlink" title="zset 底层的实现原理有了解过吗？"></a>zset 底层的实现原理有了解过吗？</h1><p> 1.有序集合对象的编码可以是ziplist或者skiplist。同时满足以下条件时使用ziplist编码：</p><p>元素数量小于128个<br>所有member的长度都小于64字节<br>其他：<br>不能满足上面两个条件的使用 skiplist 编码。以上两个条件也可以通过Redis配置文件zset-max-ziplist-entries 选项和 zset-max-ziplist-value 进行修改<br>对于一个 REDIS_ENCODING_ZIPLIST 编码的 Zset， 只要满足以上任一条件， 则会被转换为 REDIS_ENCODING_SKIPLIST 编码<br>skiplist 编码的 Zset 底层为一个被称为 zset 的结构体，这个结构体中包含一个字典和一个跳跃表。跳跃表按 score 从小到大保存所有集合元素，查找时间复杂度为平均 </p><p>O(logN)，最坏 O(N<br> 。字典则保存着从 member 到 score 的映射，这样就可以用 O(1) 的复杂度来查找 member 对应的 score 值。虽然同时使用两种结构，但它们会通过指针来共享相同元素的 member 和 score，因此不会浪费额外的内存。</p><h1 id="你能讲讲它的实现原理以及时间复杂度分析吗？"><a href="#你能讲讲它的实现原理以及时间复杂度分析吗？" class="headerlink" title="你能讲讲它的实现原理以及时间复杂度分析吗？"></a>你能讲讲它的实现原理以及时间复杂度分析吗？</h1><p>这个不太清楚。 </p><p>图片</p><h1 id="你能说说缓存穿透是怎么回事吗？"><a href="#你能说说缓存穿透是怎么回事吗？" class="headerlink" title="你能说说缓存穿透是怎么回事吗？"></a>你能说说缓存穿透是怎么回事吗？</h1><p>缓存穿透，即黑客故意去请求缓存中不存在的数据，导致所有的请求都怼到数据库上，从而数据库连接异常。</p><p>解决方案:<br>(一)利用互斥锁，缓存失效的时候，先去获得锁，得到锁了，再去请求数据库。没得到锁，则休眠一段时间重试<br>(二)采用异步更新策略，无论key是否取到值，都直接返回。value值中维护一个缓存失效时间，缓存如果过期，异步起一个线程去读数据库，更新缓存。需要做缓存预热(项目启动前，先加载缓存)操作。<br>(三)提供一个能迅速判断请求是否有效的拦截机制，比如，利用布隆过滤器，内部维护一系列合法有效的key。迅速判断出，请求所携带的Key是否合法有效。如果不合法，则直接返回。</p><p>可以用布隆过滤器来阻挡。</p><h1 id="布隆过滤器的实现原理是什么？能讲讲么？"><a href="#布隆过滤器的实现原理是什么？能讲讲么？" class="headerlink" title="布隆过滤器的实现原理是什么？能讲讲么？"></a>布隆过滤器的实现原理是什么？能讲讲么？</h1><p>AtomicInteger+CAS</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//https://blog.csdn.net/u014653197/article/details/76397037</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BloomFilter</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[] seeds;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BitSet notebook;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MisjudgmentRate rate;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger useCount = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Double autoClearRate;</span><br><span class="line"></span><br><span class="line"><span class="comment">//dataCount逾预期处理的数据规模</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BloomFilter</span><span class="params">(<span class="keyword">int</span> dataCount)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>(MisjudgmentRate.MIDDLE, dataCount, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自动清空过滤器内部信息的使用比率，传null则表示不会自动清理;</span></span><br><span class="line"><span class="comment">//当过滤器使用率达到100%时，则无论传入什么数据，都会认为在数据已经存在了;</span></span><br><span class="line"><span class="comment">//当希望过滤器使用率达到80%时自动清空重新使用，则传入0.8</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BloomFilter</span><span class="params">(MisjudgmentRate rate, <span class="keyword">int</span> dataCount, Double autoClearRate)</span></span>&#123;</span><br><span class="line"><span class="comment">//每个字符串需要的bit位数*总数据量</span></span><br><span class="line"><span class="keyword">long</span> bitSize = rate.seeds.length * dataCount;</span><br><span class="line"><span class="keyword">if</span>(bitSize&lt;<span class="number">0</span> || bitSize&gt;Integer.MAX_VALUE)&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"位数太大溢出了，请降低误判率或者降低数据大小"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.rate = rate;</span><br><span class="line">seeds = rate.seeds;</span><br><span class="line">size = (<span class="keyword">int</span>)bitSize;</span><br><span class="line"><span class="comment">//创建一个BitSet位集合</span></span><br><span class="line">notebook = <span class="keyword">new</span> BitSet(size);</span><br><span class="line"><span class="keyword">this</span>.autoClearRate = autoClearRate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果存在返回true,不存在返回false</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addIfNotExist</span><span class="params">(String data)</span></span>&#123;</span><br><span class="line"><span class="comment">//是否需要清理</span></span><br><span class="line">checkNeedClear();</span><br><span class="line"><span class="comment">//seeds.length决定每一个string对应多少个bit位，每一位都有一个索引值</span></span><br><span class="line"><span class="comment">//给定data，求出data字符串的第一个索引值index，如果第一个index值对应的bit=false说明，该data值不存在，则直接将所有对应bit位置为true即可;</span></span><br><span class="line"><span class="comment">//如果第一个index值对应bit=true，则将index值保存，但此时并不能说明data已经存在，</span></span><br><span class="line"><span class="comment">//则继续求解第二个index值，若所有index值都不存在则说明该data值不存在，将之前保存的index数组对应的bit位置为true</span></span><br><span class="line"><span class="keyword">int</span>[] indexs = <span class="keyword">new</span> <span class="keyword">int</span>[seeds.length];</span><br><span class="line"><span class="comment">//假定data已经存在</span></span><br><span class="line"><span class="keyword">boolean</span> exist = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">int</span> index;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;seeds.length; i++)&#123;</span><br><span class="line"><span class="comment">//计算位hash值</span></span><br><span class="line">indexs[i] = index = hash(data, seeds[i]);</span><br><span class="line"><span class="keyword">if</span>(exist)&#123;</span><br><span class="line"><span class="comment">//如果某一位bit不存在，则说明该data不存在</span></span><br><span class="line"><span class="keyword">if</span>(!notebook.get(index))&#123;</span><br><span class="line">exist = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//将之前的bit位置为true</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;=i; j++)&#123;</span><br><span class="line">setTrue(indexs[j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//如果不存在则直接置为true</span></span><br><span class="line">setTrue(index);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> exist;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(String data, <span class="keyword">int</span> seeds)</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span>[] value = data.toCharArray();</span><br><span class="line"><span class="keyword">int</span> hash = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(value.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;value.length; i++)&#123;</span><br><span class="line">hash = i * hash + value[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">hash = hash * seeds % size;</span><br><span class="line"><span class="keyword">return</span> Math.abs(hash);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setTrue</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">useCount.incrementAndGet();</span><br><span class="line">notebook.set(index, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//如果BitSet使用比率超过阈值，则将BitSet清零</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkNeedClear</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(autoClearRate != <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(getUseRate() &gt;= autoClearRate)&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(getUseRate() &gt;= autoClearRate)&#123;</span><br><span class="line">notebook.clear();</span><br><span class="line">useCount.set(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">private</span> Double <span class="title">getUseRate</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">double</span>)useCount.intValue()/(<span class="keyword">double</span>)size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveFilterToFile</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> (ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(path))) &#123;</span><br><span class="line">oos.writeObject(<span class="keyword">this</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BloomFilter <span class="title">readFilterFromFile</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> (ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(path))) &#123;</span><br><span class="line"><span class="keyword">return</span> (BloomFilter) ois.readObject();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清空过滤器中的记录信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">useCount.set(<span class="number">0</span>);</span><br><span class="line">notebook.clear();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> MisjudgmentRate <span class="title">getRate</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> rate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分配的位数越多，误判率越低但是越占内存</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 4个位误判率大概是0.14689159766308</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 8个位误判率大概是0.02157714146322</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 16个位误判率大概是0.00046557303372</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 32个位误判率大概是0.00000021167340</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> MisjudgmentRate &#123;</span><br><span class="line"><span class="comment">// 这里要选取质数，能很好的降低错误率</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 每个字符串分配4个位</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">VERY_SMALL(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span> &#125;),</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 每个字符串分配8个位</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SMALL(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span> &#125;), <span class="comment">//</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 每个字符串分配16个位</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MIDDLE(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">37</span>, <span class="number">41</span>, <span class="number">43</span>, <span class="number">47</span>, <span class="number">53</span> &#125;), <span class="comment">//</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 每个字符串分配32个位</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">HIGH(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">37</span>, <span class="number">41</span>, <span class="number">43</span>, <span class="number">47</span>, <span class="number">53</span>, <span class="number">59</span>, <span class="number">61</span>, <span class="number">67</span>, <span class="number">71</span>, <span class="number">73</span>, <span class="number">79</span>, <span class="number">83</span>, <span class="number">89</span>, <span class="number">97</span>,</span><br><span class="line"><span class="number">101</span>, <span class="number">103</span>, <span class="number">107</span>, <span class="number">109</span>, <span class="number">113</span>, <span class="number">127</span>, <span class="number">131</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] seeds;</span><br><span class="line"></span><br><span class="line"><span class="comment">//枚举类型MIDDLE构造函数将seeds数组初始化</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">MisjudgmentRate</span><span class="params">(<span class="keyword">int</span>[] seeds)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.seeds = seeds;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] getSeeds() &#123;</span><br><span class="line"><span class="keyword">return</span> seeds;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSeeds</span><span class="params">(<span class="keyword">int</span>[] seeds)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.seeds = seeds;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">BloomFilter fileter = <span class="keyword">new</span> BloomFilter(<span class="number">7</span>);</span><br><span class="line">System.out.println(fileter.addIfNotExist(<span class="string">"1111111111111"</span>));</span><br><span class="line">System.out.println(fileter.addIfNotExist(<span class="string">"2222222222222222"</span>));</span><br><span class="line">System.out.println(fileter.addIfNotExist(<span class="string">"3333333333333333"</span>));</span><br><span class="line">System.out.println(fileter.addIfNotExist(<span class="string">"444444444444444"</span>));</span><br><span class="line">System.out.println(fileter.addIfNotExist(<span class="string">"5555555555555"</span>));</span><br><span class="line">System.out.println(fileter.addIfNotExist(<span class="string">"6666666666666"</span>));</span><br><span class="line">System.out.println(fileter.addIfNotExist(<span class="string">"1111111111111"</span>));</span><br><span class="line"><span class="comment">//fileter.saveFilterToFile("C:\\Users\\john\\Desktop\\1111\\11.obj");</span></span><br><span class="line"><span class="comment">//fileter = readFilterFromFile("C:\\Users\\john\\Desktop\\111\\11.obj");</span></span><br><span class="line">System.out.println(fileter.getUseRate());</span><br><span class="line">System.out.println(fileter.addIfNotExist(<span class="string">"1111111111111"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Redis如何做持久化的？&quot;&gt;&lt;a href=&quot;#Redis如何做持久化的？&quot; class=&quot;headerlink&quot; title=&quot;Redis如何做持久化的？&quot;&gt;&lt;/a&gt;Redis如何做持久化的？&lt;/h1&gt;&lt;p&gt;bgsave做全量持久化到RDB二进制文件中，aof
      
    
    </summary>
    
    
    
      <category term="Redis面试" scheme="http://kkget.github.io/tags/Redis%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Redis分布式锁的实现原理</title>
    <link href="http://kkget.github.io/2021/02/19/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://kkget.github.io/2021/02/19/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</id>
    <published>2021-02-19T07:15:37.000Z</published>
    <updated>2021-02-20T00:32:49.550Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RLock lock=redisson.getLock(<span class="string">"mylock"</span>);</span><br><span class="line">lock.lock();</span><br><span class="line">lock.unLock();</span><br></pre></td></tr></table></figure><p>支持redis单实例、redis哨兵、redis cluster、redis master-slave等各种部署架构</p><h1 id="Redisson实现Redis分布式锁的底层原理"><a href="#Redisson实现Redis分布式锁的底层原理" class="headerlink" title="Redisson实现Redis分布式锁的底层原理"></a>Redisson实现Redis分布式锁的底层原理</h1><p>（1）加锁机制</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/211901.png" alt="redis分布式锁" title>                </div>                <div class="image-caption">redis分布式锁</div>            </figure> <p>咱们来看上面那张图，现在某个客户端要加锁。如果该客户端面对的是一个redis cluster集群，他首先会根据hash节点选择一台机器。<br>这里注意，仅仅只是选择一台机器！这点很关键！<br>紧接着，就会发送一段lua脚本到redis上，那段lua脚本如下所示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/211902.png" alt="redis分布式锁" title>                </div>                <div class="image-caption">redis分布式锁</div>            </figure><p>为啥要用lua脚本呢？<br>因为一大坨复杂的业务逻辑，可以通过封装在lua脚本中发送给redis，保证这段复杂业务逻辑执行的原子性。<br>那么，这段lua脚本是什么意思呢？<br>KEYS[1]代表的是你加锁的那个key，比如说：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RLock lock = redisson.getLock(<span class="string">"myLock"</span>);</span><br></pre></td></tr></table></figure><p>这里你自己设置了加锁的那个锁key就是“myLock”。<br>ARGV[1]代表的就是锁key的默认生存时间，默认30秒。<br>ARGV[2]代表的是加锁的客户端的ID，类似于下面这样：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8743</span>c9c0<span class="number">-0795</span><span class="number">-4907</span><span class="number">-87</span>fd<span class="number">-6</span>c719a6b4586:<span class="number">1</span></span><br></pre></td></tr></table></figure><p>给大家解释一下，第一段if判断语句，就是用“exists myLock”命令判断一下，如果你要加锁的那个锁key不存在的话，你就进行加锁。<br>如何加锁呢？很简单，用下面的命令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hset myLock </span><br><span class="line"></span><br><span class="line">    <span class="number">8743</span>c9c0-<span class="number">0795</span>-<span class="number">4907</span>-<span class="number">87f</span>d-<span class="number">6</span>c719a6b4586:<span class="number">1</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>通过这个命令设置一个hash数据结构，这行命令执行后，会出现一个类似下面的数据结构：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/211903.png" alt="redis分布式锁" title>                </div>                <div class="image-caption">redis分布式锁</div>            </figure><p>上述就代表“8743c9c0-0795-4907-87fd-6c719a6b4586:1”这个客户端对“myLock”这个锁key完成了加锁。<br>接着会执行“pexpire myLock 30000”命令，设置myLock这个锁key的生存时间是30秒。</p><p>好了，到此为止，ok，加锁完成了。<br>（2）锁互斥机制</p><p>那么在这个时候，如果客户端2来尝试加锁，执行了同样的一段lua脚本，会咋样呢？<br>很简单，第一个if判断会执行“exists myLock”，发现myLock这个锁key已经存在了。<br>接着第二个if判断，判断一下，myLock锁key的hash数据结构中，是否包含客户端2的ID，但是明显不是的，因为那里包含的是客户端1的ID。<br>所以，客户端2会获取到pttl myLock返回的一个数字，这个数字代表了myLock这个锁key的剩余生存时间。比如还剩15000毫秒的生存时间。<br>此时客户端2会进入一个while循环，不停的尝试加锁。<br>（3）watch dog自动延期机制<br>客户端1加锁的锁key默认生存时间才30秒，如果超过了30秒，客户端1还想一直持有这把锁，怎么办呢？<br>简单！只要客户端1一旦加锁成功，就会启动一个watch dog看门狗，他是一个后台线程，会每隔10秒检查一下，如果客户端1还持有锁key，那么就会不断的延长锁key的生存时间。<br>4）可重入加锁机制<br>那如果客户端1都已经持有了这把锁了，结果可重入的加锁会怎么样呢？<br>比如下面这种代码：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/211904.png" alt="redis分布式锁" title>                </div>                <div class="image-caption">redis分布式锁</div>            </figure><p>这时我们来分析一下上面那段lua脚本。<br>第一个if判断肯定不成立，“exists myLock”会显示锁key已经存在了。<br>第二个if判断会成立，因为myLock的hash数据结构中包含的那个ID，就是客户端1的那个ID，也就是“8743c9c0-0795-4907-87fd-6c719a6b4586:1”<br>此时就会执行可重入加锁的逻辑，他会用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">incrby myLock </span><br><span class="line"></span><br><span class="line"> <span class="number">8743</span>c9c0-<span class="number">0795</span>-<span class="number">4907</span>-<span class="number">87f</span>d-<span class="number">6</span>c71a6b4586:<span class="number">1</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>通过这个命令，对客户端1的加锁次数，累加1。<br>此时myLock数据结构变为下面这样：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/211905.png" alt="redis分布式锁" title>                </div>                <div class="image-caption">redis分布式锁</div>            </figure><p>大家看到了吧，那个myLock的hash数据结构中的那个客户端ID，就对应着加锁的次数<br>（5）释放锁机制<br>如果执行lock.unlock()，就可以释放分布式锁，此时的业务逻辑也是非常简单的。<br>其实说白了，就是每次都对myLock数据结构中的那个加锁次数减1。<br>如果发现加锁次数是0了，说明这个客户端已经不再持有锁了，此时就会用：<br>“del myLock”命令，从redis里删除这个key。<br>然后呢，另外的客户端2就可以尝试完成加锁了。<br>这就是所谓的分布式锁的开源Redisson框架的实现机制。<br>一般我们在生产系统中，可以用Redisson框架提供的这个类库来基于redis进行分布式锁的加锁与释放锁。<br>（6）上述Redis分布式锁的缺点</p><p>其实上面那种方案最大的问题，就是如果你对某个redis master实例，写入了myLock这种锁key的value，此时会异步复制给对应的master slave实例。<br>但是这个过程中一旦发生redis master宕机，主备切换，redis slave变为了redis master。<br>接着就会导致，客户端2来尝试加锁的时候，在新的redis master上完成了加锁，而客户端1也以为自己成功加了锁。<br>此时就会导致多个客户端对一个分布式锁完成了加锁。<br>这时系统在业务语义上一定会出现问题，导致各种脏数据的产生。<br>所以这个就是redis cluster，或者是redis master-slave架构的主从异步复制导致的redis分布式锁的最大缺陷：在redis master实例宕机的时候，可能导致多个客户端同时完成加锁。</p><p>手动实现redis分布式锁的正确姿势</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTool</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOCK_SUCCESS = <span class="string">"OK"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SET_IF_NOT_EXIST = <span class="string">"NX"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SET_WITH_EXPIRE_TIME = <span class="string">"PX"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试获取分布式锁</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jedis      Redis客户端</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockKey    锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestId  请求标识</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expireTime 超期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否获取成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">tryGetDistributedLock</span><span class="params">(Jedis jedis, String lockKey, String requestId, <span class="keyword">int</span> expireTime)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        String result = jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);</span><br><span class="line">        <span class="keyword">if</span> (LOCK_SUCCESS.equals(result)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Long RELEASE_SUCCESS = <span class="number">1L</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放分布式锁</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jedis     Redis客户端</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockKey   锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestId 请求标识</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否释放成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">releaseDistributedLock</span><span class="params">(Jedis jedis, String lockKey, String requestId)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        String script = <span class="string">"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end"</span>;</span><br><span class="line">        Object result = jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(requestId));</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (RELEASE_SUCCESS.equals(result)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> acquireTimeout 获取锁的超时时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeOut 锁的过期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRedisLock</span><span class="params">(Long acquireTimeout, Long timeOut)</span> </span>&#123;</span><br><span class="line">        Jedis conn = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            conn = jedisPool.getResource();</span><br><span class="line">            String identifierValue = UUID.randomUUID().toString();</span><br><span class="line">            <span class="keyword">int</span> expireLock = (<span class="keyword">int</span>) (timeOut / <span class="number">1000</span>);</span><br><span class="line">            Long endTime = System.currentTimeMillis() + acquireTimeout;</span><br><span class="line">            <span class="keyword">while</span> (System.currentTimeMillis() &lt; endTime) &#123;</span><br><span class="line">                <span class="keyword">if</span> (conn.setnx(redislockKey, identifierValue) == <span class="number">1</span>) &#123;</span><br><span class="line">                    conn.expire(redislockKey, expireLock);</span><br><span class="line">                    <span class="keyword">return</span> identifierValue;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>注意问题：</p><p>1、要为锁的value设置一个唯一的值，这样就避免了任意线程都能释放锁，因为如果业务时间小于锁的过期时间，锁被释放而业务没有执行完，另一线程获得锁，但会因第一个线程最后的释放锁而受到影响</p><p>2、conn.setnx和con.expire应该用lua脚本，保证其原子操作，上述代码就明显错误了，如果conn.setnx执行完后，redis服务器宕机了那么会导致锁永远无法释放</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> identifierValue 锁的value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unRedisLock</span><span class="params">(String identifierValue)</span> </span>&#123;</span><br><span class="line">        Jedis conn = <span class="keyword">null</span>;</span><br><span class="line">        conn = jedisPool.getResource();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (conn.get(redislockKey).equals(identifierValue)) &#123;</span><br><span class="line">                System.out.println(<span class="string">"释放锁"</span> + Thread.currentThread().getName() + <span class="string">",identifierValue: "</span> + identifierValue);</span><br><span class="line">                conn.del(redislockKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>此处同样要用lua脚本来保证conn.get和conn.del的原子性操作，如果执行到conn.get后刚好锁过期了，而另一线程获得锁，但conn.del会把锁删掉，虽然判断了锁的value后再删除仍会出现一个线程删除了另一线程获得的锁</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
    
      <category term="Redis" scheme="http://kkget.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>重学Java设计模式--on</title>
    <link href="http://kkget.github.io/2021/01/18/%E9%87%8D%E5%AD%A6Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-on/"/>
    <id>http://kkget.github.io/2021/01/18/%E9%87%8D%E5%AD%A6Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-on/</id>
    <published>2021-01-18T07:28:34.000Z</published>
    <updated>2021-02-05T07:47:01.171Z</updated>
    
    <content type="html"><![CDATA[<p>常用的23种设计模式</p><table><thead><tr><th align="left">分类</th><th align="left">设计模式</th></tr></thead><tbody><tr><td align="left">创建型</td><td align="left">工厂方法模式（FactoryMethod）、抽象工厂模式（AbstractFactory）、建造者模式（Builder）、原型模式（Prototype）、单例模式(Singleton)</td></tr><tr><td align="left">结构型</td><td align="left">适配器模式(Adapter)、桥接模式（Bridge）、组合模式（Composite）、装饰器模式（Decorator）、门面模式（Facade）、享元模式（Flyweight）、代理模式（Proxy）</td></tr><tr><td align="left">行为型</td><td align="left">解释器模式（Interpreter）、模板方法模式（TemplateMethod）、责任链模式（ChainofResponsibility）、命令模式（Command）、迭代器模式（Iterator）、调解者模式（Mediator）、备忘录模式（Memento）、观察者模式（Observer）、状态模式（State）、策略模式（Strategy）、访问者模式（Visitor）</td></tr></tbody></table><p>设计模式之间的关系</p><p>1.实现关系：继承抽象类<br>　　用一条带虚线的空心箭头表示</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/1x.png" alt="设计模式之间的关系" title>                </div>                <div class="image-caption">设计模式之间的关系</div>            </figure>               <p>2.泛化关系：继承非抽象类<br>　　用一条带实线的空心箭头表示</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/2x.png" alt="设计模式之间的关系" title>                </div>                <div class="image-caption">设计模式之间的关系</div>            </figure>              <p>3.聚合关系：用于表示实体对象之间的关系,表示整体由部分构成，其中的整体和部分不是强依赖的,即使整体不存在了,部分仍然存在。<br>　　比如，一辆汽车，它由发动机、轮胎以及其它零件等组成。但是将它拆成各种零件以后，这辆汽车就不存在了，但是发动机、轮胎以及其它零件还是存在的。<br>　用一条带实线的空心菱形箭头表示</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/3x.png" alt="设计模式之间的关系" title>                </div>                <div class="image-caption">设计模式之间的关系</div>            </figure>         <p>4.组合关系：同样表示整体由部分构成的语义,其中的整体和部分是一种强依赖的特殊聚合关系,如果整体不存在了,则部分也不存在了。<br>比如，如果公司倒闭了，那公司的各个部门也将不存在了。<br>　　用一条带实线的实心菱形箭头表示</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/4x.png" alt="设计模式之间的关系" title>                </div>                <div class="image-caption">设计模式之间的关系</div>            </figure>           <p>5.关联关系：描述不同类的对象之间的结构关系。它是一种静态关系，通常与运行状态无关，一般由常识等因素决定的。它一般用来定义  对象之间静态的、天然的结构；所以，关联关系是一种“强关联”的关系。<br>　　比如，有一个类Person它有name、age、id(身份证号码)等属性；另一个类IdCard(身份证类)它有picutre、homeAddr、id(身份证号码)等属性。那么它们的对象可以通过id相互关联起来，具体描述一个人的不同方面。感觉有点像数据库不同表之间，根据字段相关联的意思。<br>　　用一条实线表示</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/5x.png" alt="设计模式之间的关系" title>                </div>                <div class="image-caption">设计模式之间的关系</div>            </figure>　　 <p>6.依赖关系：依赖关系描述一个对象在运行期间用到另一个对象的关系；是一种临时性的关系,通常在运行期间产生,并且随着运行时的变    化,依赖关系可能发生变化。依赖也有方向,双向依赖是一种非常糟糕的结构,应该始终保持单向依赖，避免双向依赖。最终代  码中,依赖关系体现为类构造方法和类方法的传入参数，依赖关系除了临时知道对象外,还会使用对方的方法和属性。<br>用一条带虚线的箭头表示</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/6x.png" alt="设计模式之间的关系" title>                </div>                <div class="image-caption">设计模式之间的关系</div>            </figure>  <p>-&lt;作者：小傅哥 链接：<a href="https://bugstack.cn" target="_blank" rel="noopener">https://bugstack.cn</a> 来源：bugstack虫洞栈&gt;<br>-学习记录用<br>一：创建型模式<br>⼯⼚⽅法<br>抽象⼯⼚<br>建造者<br>原型模式<br>单例模式<br>1.设计模式原则</p><p>设计模式遵循六大原则<br>单一职责(一个类和方法只做一件事)<br>里氏替换(多态，子类可扩展父类)<br>依赖倒置(细节依赖抽象，下层依赖上层)<br>接口隔离(建立单一接口)<br>迪米特原则(最少知道，降低耦合)<br>开闭原则(抽象架构，扩展实现)<br>会在具体的设计模式章节中，进行体现。</p><h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><p>⼯⼚模式⼜称⼯⼚⽅法模式，是⼀种创建型设计模式，其在⽗类中提供⼀个创建对象的⽅法,允许⼦类<br>决定实例化对象的类型</p><table><thead><tr><th align="left">类型</th><th align="left">接口</th></tr></thead><tbody><tr><td align="left">优惠券</td><td align="left">CouponResult sendCoupon(String uId, String couponNumber, String uuid)</td></tr><tr><td align="left">实物奖品</td><td align="left">Boolean deliverGoods(DeliverReq req)</td></tr><tr><td align="left">兑换卡</td><td align="left">void grantToken(String bindMobileNumber, String cardId)</td></tr></tbody></table><p>3种业务实现，以往我们都是根据不同的业务类型判断，调用不同的接口实现的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrizeController</span> </span>&#123;</span><br><span class="line"> <span class="keyword">private</span> Logger logger =</span><br><span class="line">LoggerFactory.getLogger(PrizeController<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> AwardRes <span class="title">awardToUser</span><span class="params">(AwardReq req)</span> </span>&#123;</span><br><span class="line"> String reqJson = JSON.toJSONString(req);</span><br><span class="line"> AwardRes awardRes = <span class="keyword">null</span>;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line"> logger.info(<span class="string">"奖品发放开始&#123;&#125;。req:&#123;&#125;"</span>, req.getuId(), reqJson);</span><br><span class="line"> <span class="comment">// 按照不同类型⽅法商品[1优惠券、2实物商品、3第三⽅兑换卡(爱奇艺)]</span></span><br><span class="line"> <span class="keyword">if</span> (req.getAwardType() == <span class="number">1</span>) &#123;</span><br><span class="line"> CouponService couponService = <span class="keyword">new</span> CouponService();</span><br><span class="line"> CouponResult couponResult =</span><br><span class="line">couponService.sendCoupon(req.getuId(), req.getAwardNumber(),</span><br><span class="line">req.getBizId());</span><br><span class="line"> <span class="keyword">if</span> (<span class="string">"0000"</span>.equals(couponResult.getCode())) &#123;</span><br><span class="line"> awardRes = <span class="keyword">new</span> AwardRes(<span class="string">"0000"</span>, <span class="string">"发放成功"</span>);</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> awardRes = <span class="keyword">new</span> AwardRes(<span class="string">"0001"</span>,</span><br><span class="line">couponResult.getInfo());</span><br><span class="line"> &#125;</span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (req.getAwardType() == <span class="number">2</span>) &#123;</span><br><span class="line"> GoodsService goodsService = <span class="keyword">new</span> GoodsService();</span><br><span class="line"> DeliverReq deliverReq = <span class="keyword">new</span> DeliverReq();</span><br><span class="line"> deliverReq.setUserName(queryUserName(req.getuId()));</span><br><span class="line"></span><br><span class="line">deliverReq.setUserPhone(queryUserPhoneNumber(req.getuId()));</span><br><span class="line">deliverReq.setSku(req.getAwardNumber());</span><br><span class="line"> deliverReq.setOrderId(req.getBizId());</span><br><span class="line"></span><br><span class="line">deliverReq.setConsigneeUserName(req.getExtMap().get(<span class="string">"consigneeUserName"</span>))</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">deliverReq.setConsigneeUserPhone(req.getExtMap().get(<span class="string">"consigneeUserPhone"</span></span><br><span class="line">));</span><br><span class="line"></span><br><span class="line">deliverReq.setConsigneeUserAddress(req.getExtMap().get(<span class="string">"consigneeUserAddr</span></span><br><span class="line"><span class="string">ess"</span>));</span><br><span class="line"> Boolean isSuccess = goodsService.deliverGoods(deliverReq);</span><br><span class="line"> <span class="keyword">if</span> (isSuccess) &#123;</span><br><span class="line"> awardRes = <span class="keyword">new</span> AwardRes(<span class="string">"0000"</span>, <span class="string">"发放成功"</span>);</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> awardRes = <span class="keyword">new</span> AwardRes(<span class="string">"0001"</span>, <span class="string">"发放失败"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (req.getAwardType() == <span class="number">3</span>) &#123;</span><br><span class="line"> String bindMobileNumber =</span><br><span class="line">queryUserPhoneNumber(req.getuId());</span><br><span class="line"> IQiYiCardService iQiYiCardService = <span class="keyword">new</span></span><br><span class="line">IQiYiCardService();</span><br><span class="line"> iQiYiCardService.grantToken(bindMobileNumber,</span><br><span class="line">req.getAwardNumber());</span><br><span class="line"> awardRes = <span class="keyword">new</span> AwardRes(<span class="string">"0000"</span>, <span class="string">"发放成功"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> logger.info(<span class="string">"奖品发放完成&#123;&#125;。"</span>, req.getuId());</span><br><span class="line"> &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"> logger.error(<span class="string">"奖品发放失败&#123;&#125;。req:&#123;&#125;"</span>, req.getuId(), reqJson,</span><br><span class="line">e);</span><br><span class="line"> awardRes = <span class="keyword">new</span> AwardRes(<span class="string">"0001"</span>, e.getMessage());</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> awardRes;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">private</span> String <span class="title">queryUserName</span><span class="params">(String uId)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="string">"花花"</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">private</span> String <span class="title">queryUserPhoneNumber</span><span class="params">(String uId)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="string">"15200101232"</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是一但一个业务会增加处理逻辑，就要在一个方法内添加，判断，处理异常等，违反单一职责，开闭原则<br>写mock测试时，就会发现调用一个接口的逻辑3遍，写了很多重复代码<br>工厂模式重构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">itstack-demo-design-<span class="number">1</span>-<span class="number">02</span></span><br><span class="line">!<span class="string">""</span> src</span><br><span class="line"> #"" main</span><br><span class="line"> $ !<span class="string">""</span> java</span><br><span class="line"> $ !<span class="string">""</span> org.itstack.demo.design</span><br><span class="line"> $ #"" store</span><br><span class="line"> $ $ #"" impl</span><br><span class="line"> $ $ $ #"" CardCommodityService.java</span><br><span class="line"> $ $ $ #"" CouponCommodityService.java</span><br><span class="line"> $ $ $ !<span class="string">""</span> GoodsCommodityService.java</span><br><span class="line"> $ $ !<span class="string">""</span> ICommodity.java</span><br><span class="line"> $ !<span class="string">""</span> StoreFactory.java</span><br><span class="line"> !<span class="string">""</span> test</span><br><span class="line"> !<span class="string">""</span> java</span><br><span class="line"> !<span class="string">""</span> org.itstack.demo.design.test</span><br><span class="line"> !<span class="string">""</span> ApiTest.java</span><br></pre></td></tr></table></figure><p>它看上去清晰了、这样分层可以更好扩展了、似乎可以想象到每⼀个类做了什么<br> 定义一个父接口用来实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICommodity</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">sendCommodity</span><span class="params">(String uId, String commodityId, String bizId,</span></span></span><br><span class="line"><span class="function"><span class="params">Map&lt;String, String&gt; extMap)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义三种业务类型的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">优惠券</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CouponCommodityService</span> <span class="keyword">implements</span> <span class="title">ICommodity</span> </span>&#123;</span><br><span class="line"> <span class="keyword">private</span> Logger logger =</span><br><span class="line">LoggerFactory.getLogger(CouponCommodityService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"> <span class="keyword">private</span> CouponService couponService = <span class="keyword">new</span> CouponService();</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendCommodity</span><span class="params">(String uId, String commodityId, String</span></span></span><br><span class="line"><span class="function"><span class="params">bizId, Map&lt;String, String&gt; extMap)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"> CouponResult couponResult = couponService.sendCoupon(uId,</span><br><span class="line">commodityId, bizId);</span><br><span class="line"> logger.info(<span class="string">"请求参数[优惠券] =&gt; uId：&#123;&#125; commodityId：&#123;&#125; bizId：&#123;&#125;</span></span><br><span class="line"><span class="string">extMap：&#123;&#125;"</span>, uId, commodityId, bizId, JSON.toJSON(extMap));</span><br><span class="line"> logger.info(<span class="string">"测试结果[优惠券]：&#123;&#125;"</span>, JSON.toJSON(couponResult));</span><br><span class="line"> <span class="keyword">if</span> (!<span class="string">"0000"</span>.equals(couponResult.getCode())) <span class="keyword">throw</span> <span class="keyword">new</span></span><br><span class="line">RuntimeException(couponResult.getInfo());</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GoodsCommodityService</span> <span class="keyword">implements</span> <span class="title">ICommodity</span> </span>&#123;</span><br><span class="line"> <span class="keyword">private</span> Logger logger =</span><br><span class="line">LoggerFactory.getLogger(GoodsCommodityService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"> <span class="keyword">private</span> GoodsService goodsService = <span class="keyword">new</span> GoodsService();</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendCommodity</span><span class="params">(String uId, String commodityId, String</span></span></span><br><span class="line"><span class="function"><span class="params">bizId, Map&lt;String, String&gt; extMap)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"> DeliverReq deliverReq = <span class="keyword">new</span> DeliverReq();</span><br><span class="line">第三⽅兑换卡</span><br><span class="line"> deliverReq.setUserName(queryUserName(uId));</span><br><span class="line"> deliverReq.setUserPhone(queryUserPhoneNumber(uId));</span><br><span class="line"> deliverReq.setSku(commodityId);</span><br><span class="line"> deliverReq.setOrderId(bizId);</span><br><span class="line"> deliverReq.setConsigneeUserName(extMap.get(<span class="string">"consigneeUserName"</span>));</span><br><span class="line"></span><br><span class="line">deliverReq.setConsigneeUserPhone(extMap.get(<span class="string">"consigneeUserPhone"</span>));</span><br><span class="line"></span><br><span class="line">deliverReq.setConsigneeUserAddress(extMap.get(<span class="string">"consigneeUserAddress"</span>));</span><br><span class="line"> Boolean isSuccess = goodsService.deliverGoods(deliverReq);</span><br><span class="line"> logger.info(<span class="string">"请求参数[优惠券] =&gt; uId：&#123;&#125; commodityId：&#123;&#125; bizId：&#123;&#125;</span></span><br><span class="line"><span class="string">extMap：&#123;&#125;"</span>, uId, commodityId, bizId, JSON.toJSON(extMap));</span><br><span class="line"> logger.info(<span class="string">"测试结果[优惠券]：&#123;&#125;"</span>, isSuccess);</span><br><span class="line"> <span class="keyword">if</span> (!isSuccess) <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"实物商品发放失败"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">private</span> String <span class="title">queryUserName</span><span class="params">(String uId)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="string">"花花"</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">private</span> String <span class="title">queryUserPhoneNumber</span><span class="params">(String uId)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="string">"15200101232"</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CardCommodityService</span> <span class="keyword">implements</span> <span class="title">ICommodity</span> </span>&#123;</span><br><span class="line"> <span class="keyword">private</span> Logger logger =</span><br><span class="line">LoggerFactory.getLogger(CardCommodityService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"> <span class="comment">// 模拟注⼊</span></span><br><span class="line"> <span class="keyword">private</span> IQiYiCardService iQiYiCardService = <span class="keyword">new</span> IQiYiCardService();</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendCommodity</span><span class="params">(String uId, String commodityId, String</span></span></span><br><span class="line"><span class="function"><span class="params">bizId, Map&lt;String, String&gt; extMap)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"> String mobile = queryUserMobile(uId);</span><br><span class="line"> iQiYiCardService.grantToken(mobile, bizId);</span><br><span class="line"> logger.info(<span class="string">"请求参数[爱奇艺兑换卡] =&gt; uId：&#123;&#125; commodityId：&#123;&#125; bizId：</span></span><br><span class="line"><span class="string">&#123;&#125; extMap：&#123;&#125;"</span>, uId, commodityId, bizId, JSON.toJSON(extMap));</span><br><span class="line"> logger.info(<span class="string">"测试结果[爱奇艺兑换卡]：success"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">private</span> String <span class="title">queryUserMobile</span><span class="params">(String uId)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="string">"15200101232"</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工厂类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StoreFactory</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> ICommodity <span class="title">getCommodityService</span><span class="params">(Integer commodityType)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">null</span> == commodityType) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">1</span> == commodityType) <span class="keyword">return</span> <span class="keyword">new</span> CouponCommodityService();</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">2</span> == commodityType) <span class="keyword">return</span> <span class="keyword">new</span> GoodsCommodityService();</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">3</span> == commodityType) <span class="keyword">return</span> <span class="keyword">new</span> CardCommodityService();</span><br><span class="line"> <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"不存在的商品服务类型"</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_commodity</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"> StoreFactory storeFactory = <span class="keyword">new</span> StoreFactory();</span><br><span class="line"> <span class="comment">// 1. 优惠券</span></span><br><span class="line"> ICommodity commodityService_1 = storeFactory.getCommodityService(<span class="number">1</span>);</span><br><span class="line"> commodityService_1.sendCommodity(<span class="string">"10001"</span>, <span class="string">"EGM1023938910232121323432"</span>,</span><br><span class="line"><span class="string">"791098764902132"</span>, <span class="keyword">null</span>);</span><br><span class="line"> <span class="comment">// 2. 实物商品</span></span><br><span class="line"> ICommodity commodityService_2 = storeFactory.getCommodityService(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"> Map&lt;String,String&gt; extMap = <span class="keyword">new</span> HashMap&lt;String,String&gt;();</span><br><span class="line"> extMap.put(<span class="string">"consigneeUserName"</span>, <span class="string">"谢⻜机"</span>);</span><br><span class="line"> extMap.put(<span class="string">"consigneeUserPhone"</span>, <span class="string">"15200292123"</span>);</span><br><span class="line"> extMap.put(<span class="string">"consigneeUserAddress"</span>, <span class="string">"吉林省.⻓春市.双阳区.XX街道.檀溪苑⼩</span></span><br><span class="line"><span class="string">区.#18-2109"</span>);</span><br><span class="line"></span><br><span class="line">commodityService_2.sendCommodity(<span class="string">"10001"</span>,<span class="string">"9820198721311"</span>,<span class="string">"102300002011222</span></span><br><span class="line"><span class="string">1113"</span>, extMap);</span><br><span class="line"> <span class="comment">// 3. 第三⽅兑换卡(爱奇艺)</span></span><br><span class="line"> ICommodity commodityService_3 = storeFactory.getCommodityService(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">commodityService_3.sendCommodity(<span class="string">"10001"</span>,<span class="string">"AQY1xjkUodl8LO975GdfrYUio"</span>,<span class="keyword">null</span></span><br><span class="line">,<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>感觉比较像策略模式吧，但是看过之后确实觉得一些业务代码是可以这么优化，省去很多维护的成本</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;常用的23种设计模式&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;left&quot;&gt;分类&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;设计模式&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;创建型&lt;/
      
    
    </summary>
    
    
    
      <category term="设计模式" scheme="http://kkget.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>如何获取泛型类型信息</title>
    <link href="http://kkget.github.io/2020/12/03/%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF/"/>
    <id>http://kkget.github.io/2020/12/03/%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF/</id>
    <published>2020-12-03T01:23:06.000Z</published>
    <updated>2020-12-03T01:24:25.535Z</updated>
    
    <content type="html"><![CDATA[<p>需求场景:为什么需要获取泛型类型？<br>运行时获取泛型，涉及泛型的对象的序列化/反序列化上<br>java选择的泛型方式是类型擦除式泛型，就是直接把已有的类型泛型化，不需要改变字节码，不需要改动JVM<br>如何获取泛型方法的泛型？<br>1.反射</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">getMethodReturnType</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Method method=MyClass.class.getMethod("getStringList",null);</span><br><span class="line">    System.out.println(method.getReturnType());</span><br><span class="line">    Type retrunType=method.getGenericReturnType();</span><br><span class="line">    System.out.println(retrunType);</span><br><span class="line">    <span class="keyword">if</span>(retrunType <span class="keyword">instanceof</span> ParameterizedType)&#123;</span><br><span class="line">    ParameterizedType type=(ParameterizedType)retrunType;</span><br><span class="line">    Type[] typeArguments=type.getActualTypeArguments();</span><br><span class="line">    <span class="keyword">for</span>(Type typeArgument:typeArguments)&#123;</span><br><span class="line">   Class typeArgClass=(Class)typeArgument;</span><br><span class="line">  System.out.println(<span class="string">"泛型类型："</span>+typeArgClass);        &#125;    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] convert  (List&lt;T&gt; list,Class&lt;T&gt; compoentType)&#123;</span><br><span class="line">    (T[])Array.newInstance(compoentType,List.size()))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对于继承的父类是泛型的情况</span></span><br><span class="line">    ParameterizedType genericSuperclass = (ParameterizedType) Student<span class="class">.<span class="keyword">class</span>.<span class="title">getGenericSuperclass</span>()</span>;</span><br><span class="line">    System.out.println(genericSuperclass);</span><br><span class="line">    Type type = genericSuperclass.getActualTypeArguments()[<span class="number">0</span>];</span><br><span class="line">    System.out.println(type);</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.更优雅地获取泛型方法<br>Spring ResolvableType 官方API<br><a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/core/ResolvableType.html" target="_blank" rel="noopener">https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/core/ResolvableType.html</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Spring的提供工具类,用于获取继承的父类是泛型的信息</span></span><br><span class="line">    ResolvableType resolvableType = ResolvableType.forClass(Student<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    System.out.println(resolvableType);</span><br><span class="line">    Class&lt;?&gt; resolve = resolvableType.getSuperType().getGeneric(<span class="number">0</span>).resolve();</span><br><span class="line">    System.out.println(resolve);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">构造获取 Field 的泛型信息</span><br><span class="line">ResolvableType.forField(Field)</span><br><span class="line">构造获取 Method 的泛型信息</span><br><span class="line">ResolvableType.forMethodParameter(Method, <span class="keyword">int</span>)</span><br><span class="line">构造获取方法返回参数的泛型信息</span><br><span class="line">ResolvableType.forMethodReturnType(Method)</span><br><span class="line">构造获取构造参数的泛型信息</span><br><span class="line">ResolvableType.forConstructorParameter(Constructor, <span class="keyword">int</span>)</span><br><span class="line">构造获取类的泛型信息</span><br><span class="line">ResolvableType.forClass(Class)</span><br><span class="line">构造获取类型的泛型信息</span><br><span class="line">ResolvableType.forClass(Class)</span><br><span class="line">构造获取实例的泛型信息</span><br><span class="line">ResolvableType.forInstance(Object)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;需求场景:为什么需要获取泛型类型？&lt;br&gt;运行时获取泛型，涉及泛型的对象的序列化/反序列化上&lt;br&gt;java选择的泛型方式是类型擦除式泛型，就是直接把已有的类型泛型化，不需要改变字节码，不需要改动JVM&lt;br&gt;如何获取泛型方法的泛型？&lt;br&gt;1.反射&lt;/p&gt;
&lt;figure
      
    
    </summary>
    
    
    
      <category term="泛型" scheme="http://kkget.github.io/tags/%E6%B3%9B%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Linux按时间筛选日志的方法</title>
    <link href="http://kkget.github.io/2020/11/02/Linux%E6%8C%89%E6%97%B6%E9%97%B4%E7%AD%9B%E9%80%89%E6%97%A5%E5%BF%97%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://kkget.github.io/2020/11/02/Linux%E6%8C%89%E6%97%B6%E9%97%B4%E7%AD%9B%E9%80%89%E6%97%A5%E5%BF%97%E7%9A%84%E6%96%B9%E6%B3%95/</id>
    <published>2020-11-02T07:21:03.000Z</published>
    <updated>2020-11-09T06:49:26.644Z</updated>
    
    <content type="html"><![CDATA[<p>日常筛日志时通过ELK去查询的，但是如果脱离工具如何来做？</p><p>通常我们是用ELK去查询过滤的，如果脱离工具，需要运维导出日志，或者直接用grep  sed  awk 命令搭配正则或者编写shell脚本供运维执行后导出分析</p><p>通常查找出错误日志 cat error.log | grep ‘nick’ , 这时候我们还有个需求就是输出当前这个日志的前后几行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat error.log | grep -C <span class="number">5</span> <span class="string">'nick'</span> 显示file文件里匹配foo字串那行以及上下<span class="number">5</span>行</span><br><span class="line">cat error.log | grep -B <span class="number">5</span> <span class="string">'nick'</span> 显示foo及前<span class="number">5</span>行</span><br><span class="line">cat error.log | grep -A <span class="number">5</span> <span class="string">'nick'</span> 显示foo及后<span class="number">5</span>行</span><br></pre></td></tr></table></figure><p>在日常系统维护、问题排查时，经常需要对系统后台日志进行筛选过滤。如果对特定时间段的日志进行筛选，该如何编写Shell脚本（命令）呢？本文给出三种常用的Shell编写方法：grep、gawk和sed。</p><p>日志筛选需求描述：从2017年12月22日的日志文件中，统计时间段13:30~18:00之间包含筛选词“open.app”的日志行数。</p><p>本系统后台日志格式如下图所示：<br>从图中可以看出每行日志以“yyyy-MM-dd HH:mm:ss”开头，故要筛选一段时间的日志，就要匹配该日志的时间前缀。<br>接下来文章分别介绍使用grep、gawk和sed命令，如何进行相关的Shell脚本（命令）的编写。</p><p>1grep命令</p><p>在日志筛选、搜索中，grep是使用频率较高的命令。对于grep命令来说，如果筛选一段时间的日志，需要进行多条件相并过滤，使用正则表达式进行处理。对于13:30~18:00时间段来说，可以转化为下面表格多个时间相并。<br>序号 筛选条件 筛选时间段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2017</span>-<span class="number">12</span>-<span class="number">22</span> <span class="number">13</span>:<span class="number">3</span> <span class="number">13</span>:<span class="number">30</span>:<span class="number">00</span>~<span class="number">13</span>:<span class="number">39</span>:<span class="number">59</span></span><br><span class="line"><span class="number">2</span> <span class="number">2017</span>-<span class="number">12</span>-<span class="number">22</span> <span class="number">13</span>:<span class="number">4</span> <span class="number">13</span>:<span class="number">40</span>:<span class="number">00</span>~<span class="number">13</span>:<span class="number">49</span>:<span class="number">59</span></span><br><span class="line"><span class="number">3</span> <span class="number">2017</span>-<span class="number">12</span>-<span class="number">22</span> <span class="number">13</span>:<span class="number">5</span> <span class="number">13</span>:<span class="number">50</span>:<span class="number">00</span>~<span class="number">13</span>:<span class="number">59</span>:<span class="number">59</span></span><br><span class="line"><span class="number">4</span> <span class="number">2017</span>-<span class="number">12</span>-<span class="number">22</span> <span class="number">14</span> <span class="number">14</span>:<span class="number">00</span>:<span class="number">00</span>~<span class="number">14</span>:<span class="number">59</span>:<span class="number">59</span></span><br><span class="line"><span class="number">5</span> <span class="number">2017</span>-<span class="number">12</span>-<span class="number">22</span> <span class="number">15</span> <span class="number">15</span>:<span class="number">00</span>:<span class="number">00</span>~<span class="number">15</span>:<span class="number">59</span>:<span class="number">59</span></span><br><span class="line"><span class="number">6</span> <span class="number">2017</span>-<span class="number">12</span>-<span class="number">22</span> <span class="number">16</span> <span class="number">16</span>:<span class="number">00</span>:<span class="number">00</span>~<span class="number">16</span>:<span class="number">59</span>:<span class="number">59</span></span><br><span class="line"><span class="number">7</span> <span class="number">2017</span>-<span class="number">12</span>-<span class="number">22</span> <span class="number">17</span> <span class="number">17</span>:<span class="number">00</span>:<span class="number">00</span>~<span class="number">17</span>:<span class="number">59</span>:<span class="number">59</span></span><br></pre></td></tr></table></figure><p>命令如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -E <span class="string">'^2017-12-22  13:3|^2017-12-22 13:4|^2017-12-22 13:5|^2017-12-22 14|^2017-12-22  15|^2017-12-22 16|^2017-12-22 17'</span> <span class="number">2017</span>-<span class="number">12</span>-<span class="number">22</span>.log.txt | grep  <span class="string">'open.app'</span> | wc -l</span><br></pre></td></tr></table></figure><p>运行结果如下图：<br>共检索筛选到71314条。<br>上述命令条件可以使用正则表达式进行缩减，命令如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -E <span class="string">'^2017-12-22  13:[3,4,5]|^2017-12-22 1[4,5,6,7]'</span> <span class="number">2017</span>-<span class="number">12</span>-<span class="number">22</span>.log.txt | grep  <span class="string">'open.app'</span> | wc -l</span><br></pre></td></tr></table></figure><p>运行结果如下图所示：<br>检索筛选到71314条，和上述命令一致。</p><p>2gawk命令</p><p>gawk命令是功能强大、可编程的Linux命令。使用gawk命令筛选一段时间的日志，其思路是首先截取出每行日志的“yyyy-MM-dd HH:mm:ss”19位时间前缀，然后将该前缀字符串与“2017-12-22 13:30:00”、“2017-12-22 18:00:00”进行比较，不在该范围的日志则丢弃。<br>命令脚本如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat <span class="number">2017</span>-<span class="number">12</span>-<span class="number">22</span>.log.txt  | gawk <span class="string">'&#123;    time = substr($0, 1, 19);         if(('</span><span class="number">2017</span>-<span class="number">12</span>-<span class="number">22</span> <span class="number">13</span>:<span class="number">30</span>:<span class="number">00</span><span class="string">' &lt;= time)="" &amp;&amp;=""  (time=""&gt;&lt; '</span><span class="number">2017</span>-<span class="number">12</span>-<span class="number">22</span>=<span class="string">""</span> <span class="number">18</span>:<span class="number">00</span>:<span class="number">00</span><span class="string">'))=""&gt;         &#123;             print($0);         &#125;&#125;'</span> | grep  <span class="string">'open.app'</span> | wc -l</span><br></pre></td></tr></table></figure><p>运行结果如下图所示：<br>共检索筛选到71314条。<br>注：需要注意“2017-12-22 18:00:00”使用的是小于符号，而不是小于等于符号。</p><p>3sed命令</p><p>sed是一种流编辑器命令，它是文本处理中非常中的工具，能够完美的配合正则表达式使用。使用sed命令选定行的范围语法，既是逗号语法。<br>命令如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n <span class="string">'/2017-12-22  13:30:00/,/2017-12-22 18:00:00/p'</span> <span class="number">2017</span>-<span class="number">12</span>-<span class="number">22</span>.log.txt | grep  <span class="string">'open.app'</span> | wc -l</span><br></pre></td></tr></table></figure><p>运行结果如下图所示：<br>共检索筛选到71314条。<br>注：该sed命令含义是选定行范围：从第一行“2017-12-22 13:30:00”开始，到第一行“2017-12-22 18:00:00”结束，包括第一行“2017-12-22 18:00:00”。如果不筛选“open.app”关键字，单纯计数，则sed命令比如上述grep和gawk命令多筛选出一条。</p><p>4命令比较</p><p>对命令运行时间和命令编写的复杂性进行对比，结果如下表所示：<br>命令 耗时（秒） 命令复杂性<br>grep 50 低<br>gawk 122 高<br>sed 61 低<br>从表中可以看出，grep命令运行时间最短；gawk命令运行时间最长，而且命令编写较为复杂。另外sed命令运行时间跟grep相近，但是sed命令对时间段适应性较好。如果时间段扩大，grep命令修改较大，而sed命令修改较小。</p><p>筛选15:05–15:10期间的日志<br> 使用sed </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n <span class="string">'/Apr 22 15:05/,/Apr 22 15:10/p'</span> syslog &gt; test</span><br></pre></td></tr></table></figure><p>使用grep，与sed提取的行数有差异，待查验。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -E <span class="string">'^Apr 22 15:05|^Apr 22 15:06|^Apr 22 15:07|^Apr 22 15:08|^Apr 22 15:09|^Apr 22 15:10'</span></span><br></pre></td></tr></table></figure><p>使用awk，跟grep提取行数一致，不过会因为分隔符原因，时间戳格式被修改，需要额外辨别，待完善。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -F<span class="string">'[:]'</span> <span class="string">'$1 = 15 &amp;&amp; $2 &gt;=5 &amp;&amp; $2 &lt;= 10 &#123;print $0&#125;'</span> syslog</span><br></pre></td></tr></table></figure><p>linux下使用awk命令按时间段筛选日志</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zcat com.log20160529.gz | grep <span class="string">'dianping_reply'</span>| </span><br><span class="line">awk <span class="string">'&#123;split($4,array,"[");if(array[2]&gt;="29/May/2016:00:00:26" &amp;&amp; array[2]&lt;="29/May/2016:00:01:14")&#123;print $0&#125;&#125;'</span></span><br></pre></td></tr></table></figure><p>扫描gz压缩文件，从中寻找带有<code>dianping_reply</code>的行，将改行按照<code>[</code>进行拆分，然后直接使用if条件进行判断，比较，最终输出想要的结果。<br>zcat 直接读取压缩文件的内容<br>grep用来过滤特定字符的行<br>awk 用来执行命令<br>split用来切分字符串</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;日常筛日志时通过ELK去查询的，但是如果脱离工具如何来做？&lt;/p&gt;
&lt;p&gt;通常我们是用ELK去查询过滤的，如果脱离工具，需要运维导出日志，或者直接用grep  sed  awk 命令搭配正则或者编写shell脚本供运维执行后导出分析&lt;/p&gt;
&lt;p&gt;通常查找出错误日志 cat
      
    
    </summary>
    
    
    
      <category term="Linux" scheme="http://kkget.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>redismanager安装失败</title>
    <link href="http://kkget.github.io/2020/10/29/redis%20%20%20manager%20%20%20%E5%AE%89%E8%A3%85%E5%A4%B1%E8%B4%A5/"/>
    <id>http://kkget.github.io/2020/10/29/redis%20%20%20manager%20%20%20%E5%AE%89%E8%A3%85%E5%A4%B1%E8%B4%A5/</id>
    <published>2020-10-29T07:10:44.000Z</published>
    <updated>2020-11-10T06:17:09.073Z</updated>
    
    <content type="html"><![CDATA[<p>关于redis manager安装失败 报错</p><p>install it manually and try again</p><p>需要下载vc_redist.x86.exe</p><p><a href="https://support.microsoft.com/en-us/help/2977003/the-latest-supported-visual-c-downloads" target="_blank" rel="noopener">https://support.microsoft.com/en-us/help/2977003/the-latest-supported-visual-c-downloads</a></p><p>选择x86</p><p>另外如果提示需要更新版本的话，可以关闭后，将系统时间调制16年以前即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;关于redis manager安装失败 报错&lt;/p&gt;
&lt;p&gt;install it manually and try again&lt;/p&gt;
&lt;p&gt;需要下载vc_redist.x86.exe&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://support.microsoft.co
      
    
    </summary>
    
    
    
      <category term="redis" scheme="http://kkget.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Shell脚本</title>
    <link href="http://kkget.github.io/2020/10/19/Shell%E8%84%9A%E6%9C%AC/"/>
    <id>http://kkget.github.io/2020/10/19/Shell%E8%84%9A%E6%9C%AC/</id>
    <published>2020-10-19T01:26:10.000Z</published>
    <updated>2020-10-20T01:51:46.263Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ll |grep bash</span><br><span class="line">echo $SHELL</span><br><span class="line">touch helloword.sh</span><br><span class="line">脚本以#!/bin/bash开头（指定解析器）</span><br></pre></td></tr></table></figure><p>脚本的常用执行方式<br>1.第一种：采用bash或sh+脚本的相对路径或绝对路径（不用赋予脚本+x权限）<br>2.第二种：采用输入脚本的绝对路径或相对路径执行脚本（必须具有可执行权限+x）<br>chmod 777 helloworld.sh</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/shell/1.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>Linux/Unix 的文件调用权限分为三级 : 文件所有者（Owner）、用户组（Group）、其它用户（Other Users）。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/shell/2.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>只有文件所有者和超级用户可以修改文件或目录的权限。可以使用绝对模式（八进制数字模式），符号模式指定文件的权限。</p><p>使用权限 : 所有使用者<br>八进制语法<br>chmod命令可以使用八进制数来指定权限。文件或目录的权限位是由9个权限位来控制，每三位为一组，它们分别是文件所有者（User）的读、写、执行，用户组（Group）的读、写、执行以及其它用户（Other）的读、写、执行。历史上，文件权限被放在一个比特掩码中，掩码中指定的比特位设为1，用来说明一个类具有相应的优先级。</p><h1 id="权限-rwx-二进制"><a href="#权限-rwx-二进制" class="headerlink" title="权限 rwx 二进制"></a>权限 rwx 二进制</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/shell/3.png" alt title>                </div>                <div class="image-caption"></div>            </figure><ol><li>常用系统变量<br>$HOME、$PWD、$SHELL、$USER等<br>自定义变量<br>1．基本语法<br>（1）定义变量：变量=值 等号两边没有空格<br>（2）撤销变量：unset 变量<br>（3）声明静态变量：readonly变量，注意：不能unset<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@zhaokk ~]# readonly B=3</span><br><span class="line">[root@zhaokk ~]# echo $B</span><br><span class="line"><span class="number">3</span></span><br><span class="line">[root@zhaokk ~]# unset B</span><br><span class="line">-bash: unset: B: cannot unset: readonly variable</span><br></pre></td></tr></table></figure>2．变量定义规则<br>（1）变量名称可以由字母、数字和下划线组成，但是不能以数字开头，环境变量名建议大写。<br>（2）等号两侧不能有空格<br>（3）在bash中，变量默认类型都是字符串类型，无法直接进行数值运算。<br>（4）变量的值如果有空格，需要使用双引号或单引号括起来。<h1 id="可把变量提升为全局环境变量，可供其他Shell程序使用"><a href="#可把变量提升为全局环境变量，可供其他Shell程序使用" class="headerlink" title="可把变量提升为全局环境变量，可供其他Shell程序使用"></a>可把变量提升为全局环境变量，可供其他Shell程序使用</h1>export 变量名<br>特殊变量：$n<br>1．基本语法<br>$n （功能描述：n为数字，$0代表该脚本名称，$1-$9代表第一到第九个参数，十以上的参数，十以上的参数需要用大括号包含，如${10}),脚本尽量不能超过5</li><li>4 特殊变量：$#<br>1．基本语法<br>$# （功能描述：获取所有输入参数个数，常用于循环）</li><li>5 特殊变量：$<em>、$@<br>1．基本语法<br>$</em> （功能描述：这个变量代表命令行中所有的参数，$*把所有的参数看成一个整体）<br>$@ （功能描述：这个变量也代表命令行中所有的参数，不过$@把每个参数区分对待）</li><li>6 特殊变量：$？<br>1．基本语法<br>$？ （功能描述：最后一次执行的命令的返回状态。如果这个变量的值为0，证明上一个命令正确执行；如果这个变量的值为非0（具体是哪个数，由命令自己来决定），则证明上一个命令执行不正确了。）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@zhaokk ~]# echo $?</span><br><span class="line"><span class="number">127</span></span><br><span class="line">[root@zhaokk ~]# ./helloword.sh </span><br><span class="line">helloworld</span><br><span class="line"></span><br><span class="line">[root@zhaokk ~]# echo $?</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>运算  expr 运算符间有空格<br>条件判断<br>1．基本语法<br>[ condition ]（注意condition前后要有空格）<br>注意：条件非空即为true，[ atguigu ]返回true，[] 返回false。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ 23 -ge 22 ]</span><br><span class="line">[atguigu@hadoop101 datas]$ echo $? 0</span><br></pre></td></tr></table></figure>Shell工具（重点）</li><li>1 cut<br>cut的工作就是“剪”，具体的说就是在文件中负责剪切数据用的。cut 命令从文件的每一行剪切字节、字符和字段并将这些字节、字符和字段输出。</li><li>基本用法<br>cut [选项参数]  filename<br>说明：默认分隔符是制表符</li><li>选项参数说明<br>表1-55<br>选项参数 功能</li></ol><p>-f 列号，提取第几列<br>-d 分隔符，按照指定分隔符分割列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">由于vi编辑器不能使用鼠标，所以一个大文件如果要到最后一行只用键盘下键的话会是一个很痛苦的过程，还好有各种比较快捷的方法归我们使用：</span><br><span class="line"><span class="number">1</span>. vi 编辑器中跳到文件的第一行：</span><br><span class="line">　　 a  输入 :<span class="number">0</span> 或者 :<span class="number">1</span>   回车</span><br><span class="line">　　 b  键盘按下 小写 gg</span><br><span class="line"> </span><br><span class="line"><span class="number">2</span>.vi 编辑器跳到文件最后一行：</span><br><span class="line">　　 a 输入 :$   回车</span><br><span class="line">　　 b 键盘按下大写 G</span><br><span class="line">　　 c 键盘按 shift + g    (其实和第二种方法一样)</span><br><span class="line"></span><br><span class="line">Vim快速移动光标至行首和行尾</span><br><span class="line"></span><br><span class="line">  <span class="number">1</span>、 需要按行快速移动光标时，可以使用键盘上的编辑键Home，快速将光标移动至当前行的行首。除此之外，也可以在命令模式中使用快捷键<span class="string">"^"</span>（即Shift+<span class="number">6</span>）或<span class="number">0</span>（数字<span class="number">0</span>）。</span><br><span class="line">  <span class="number">2</span>、 如果要快速移动光标至当前行的行尾，可以使用编辑键End。也可以在命令模式中使用快捷键<span class="string">"$"</span>（Shift+<span class="number">4</span>）。与快捷键<span class="string">"^"</span>和<span class="number">0</span>不同，快捷键<span class="string">"$"</span>前可以加上数字表示移动的行数。例如使用<span class="string">"1$"</span>表示当前行的行尾，<span class="string">"2$"</span>表示当前行的下一行的行尾。</span><br></pre></td></tr></table></figure><p>将passwd文件中的用户id增加数值1并输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -F : -v i=<span class="number">1</span> <span class="string">'&#123;print $3+i&#125;'</span> passwd</span><br></pre></td></tr></table></figure><p>统计当月销量的最高TOP10<br>ETL<br>使用Linux命令查询file1中空行所在的行号</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@zhaokk ~]# awk '/^$/&#123;print NR&#125;' cut.txt </span><br><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure><p>Shell脚本里如何检查一个文件是否存在？如果不存在该如何处理？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@zhaokk ~]# touch check.sh</span><br><span class="line">[root@zhaokk ~]# vim check.sh </span><br><span class="line">#!/bin/bash</span><br><span class="line"><span class="keyword">if</span> [ -f file.txt ]</span><br><span class="line">then</span><br><span class="line">        echo <span class="string">"文件存在"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">        echo <span class="string">"文件不存在"</span></span><br><span class="line">fi</span><br><span class="line">[root@zhaokk ~]# chmod 777 check.sh </span><br><span class="line">[root@zhaokk ~]# ./check.sh </span><br><span class="line">文件不存在</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line
      
    
    </summary>
    
    
    
      <category term="不务正业之大数据自学" scheme="http://kkget.github.io/tags/%E4%B8%8D%E5%8A%A1%E6%AD%A3%E4%B8%9A%E4%B9%8B%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%87%AA%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>JVM从入门到放弃</title>
    <link href="http://kkget.github.io/2020/10/13/JVM%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/"/>
    <id>http://kkget.github.io/2020/10/13/JVM%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/</id>
    <published>2020-10-13T03:36:03.000Z</published>
    <updated>2021-02-24T03:45:13.912Z</updated>
    
    <content type="html"><![CDATA[<img src="/2020/10/13/JVM%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/1.png" class title="This is an example image"><p>虚拟机规范<br><a href="https://docs.oracle.com/javase/specs/index.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/index.html</a><br>操作系统不识别字节码指令，虚拟机将其编译为机器指令<br>第一次编译将代码编译成字节码<br>第二次将字节码编译成机器指令并缓存进方法区<br>类加载器分类：启动类加载器，拓展类加载器，应用类加载器<br>双亲委派机制：<br>沙箱安全：<br>GC发生在方法区和堆<br>年轻代：复制算法，幸存者0-1区<br>eden区满时触发第一次GC(Yong GC)，把活着的对象拷贝到SurvivorFrom区，当eden区再次触发GC(Full  GC)的时候，会扫描Eden区和from区进行垃圾回收，经过这次回收还活着的复制到To区，对象年龄+1<br>复制次数到达15次还活下来的存入老年代<br>优点：无内存碎片<br>缺点：浪费空间<br>标记清除：mark–&gt;sweep<br>优点：<br>缺点：会产生磁盘碎片<br>标记压缩：<br>缺点：移动对象需要成本<br>分代收集：<br>GCroot:<br>1.垃圾回收的时候如何确定垃圾？什么是GC Roots<br>可达性分析算法：从GC Roots对象向下搜索，如果遍历对象到GC Roots没有任何引用，则说明此对象不可用<br>2.那些对象可以作为GC Roots</p><p>GC Roots对象</p><p>JVM调优<br>标配: -version<br>-X：<br>-XX：+/-   开启关闭<br>查看jvm参数细节<br>jps -l<br>jinfo<br>jinfo -flag PrintGCDetails 15460是否开启<br>K V 设值<br>-XX:MetaspaceSize=<br>-XX:MaxTenuringThreshold=15<br>永久区几乎不会被回收，但不是不回收<br>只是回收的条件比较苛刻 </p><p>虚拟机栈  局部变量，操作数栈，动态链接<br>java指令是基于栈设计的<br>每个线程创建时都会创建一个虚拟机栈<br>》线程私有<br>》保存的一个个栈帧</p><p>方法与栈帧一对一<br>方法执行：<br>1.正常结束<br>2.抛异常<br>javp -v xx.class  此处没有分号<br>反编译时，方法需是public得<br>返回值是int  ireturn<br>方法虽然是void，但是可以写return，底层指令是存在的<br>47:栈帧的内部结构<br>一共五部分<br>局部变量表+操作数栈的大小影响单个栈帧的大小，单个栈帧的大小影响栈的大小，以及何时出现异常<br>48:局部变量表</p><p>编译器确定，一但确定不会被更改</p><p>Specific info<br>java代码 与字节码指令的对应关系  Slot 变量槽<br>占两个变量槽时，使用起始索引</p><p>静态方法中不能引用this，因为this也是一个变量不存在与当前方法的局部变量表中<br>变量的分类</p><p>操作数栈Operand Stack<br>栈访问数据只能通过入栈出栈来访问<br>上来放的就是1的位置，因为非静态方法，0放入this<br> i++和++i区别</p><p>栈顶缓存<br>将栈顶元素缓存到CPU中，提高执行引擎效率<br>动态链接与常量池</p><p>大部分字节码质量在执行的时候，都需要常量池的访问<br>指向运行时常量池的方法引用</p><img src="/2020/10/13/JVM%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/3.png" class title="This is an example image"><p>方法的绑定机制<br>静态链接:编译期可确定</p><p>动态链接:编译期无法确定</p><p>早期绑定:</p><p>晚期绑定:</p><p>方法调用指令区分虚方法与非虚方法</p><p>invokeinterface  虚方法<br>invokedynamic指令 java7<br>动态类型语言vs静态类型语言</p><p>java仍然是静态的<br>方法重写本质</p><p>虚方法表<br>非虚方法不需要，因为已经确定了哪个方法<br>方法返回地址</p><p>本地方法接口，本地方法库</p><p>一个进程对应一个jvm实例，一个jvm实例对应一个运行时数据区，包含多个进程所以堆方法区共享<br>jvm启动的时候就被创建了，大小也就确定了<br>物理上不连续，逻辑上连续<br>TLAB是私有的</p><p>几乎所有的对象实例都是这里分配内存<br>GC频率过高，影响用户线程，stop the world<br>堆得细分结构</p><p>分代收集<br>jvisualvm</p><p>-Xms： X 参数<br>     ms ：memory start<br>查看某个进程或服务的GC情况<br>jps<br>jmap -heap 2082460</p><p>对象分解过程</p><p>YGC   STW</p><img src="/2020/10/13/JVM%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/4.png" class title="This is an example image"><p>对象分配    老年代 ↓</p><img src="/2020/10/13/JVM%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/5.png" class title="This is an example image"><p>Promotion   晋升 </p><img src="/2020/10/13/JVM%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/6.png" class title="This is an example image"><p>from 区存在垃圾回收，但不触发minor Gc<br>养老区的Major Gc都无法保存的对象触发OOM<br>minor GC老年代回收Full gc还是整堆回收</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;MessageServiceImpl&gt; list = <span class="keyword">new</span> ArrayList&lt;MessageServiceImpl&gt;();</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">        list.add(<span class="keyword">new</span> MessageServiceImpl());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">           Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Minor GC会触发STW</p><p>内存分配自适应<br>TLAB:Thread Local Allotion Buffer 线程本地分配缓冲区</p><h1 id="堆空间一定是共享的吗？"><a href="#堆空间一定是共享的吗？" class="headerlink" title="堆空间一定是共享的吗？"></a>堆空间一定是共享的吗？</h1><p>TLAB是线程私有的<br>堆空间的参数设置<br>堆是分配对象的唯一选择吗？<br>对象经过逃逸分析后并没有逃逸出方法的话，有可能优化成栈上分配<br>线程私有的，无同步执行可能<br>优化也是最终希望减少GC<br>如何快速判断是否发生逃逸分析，看new的对象是否有可能在方法外被调用</p><p>同步省略  锁销除<br>标量替换<br>逃逸分析本身也非常耗时</p><h1 id="如何解决OOM"><a href="#如何解决OOM" class="headerlink" title="如何解决OOM"></a>如何解决OOM</h1><img src="/2020/10/13/JVM%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/7.png" class title="This is an example image"><h1 id="方法区的内部结构"><a href="#方法区的内部结构" class="headerlink" title="方法区的内部结构"></a>方法区的内部结构</h1><img src="/2020/10/13/JVM%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/8.png" class title="This is an example image"><img src="/2020/10/13/JVM%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/9.png" class title="This is an example image"><p>涉及类得加载器也存在与方法区<br>记录方法信息的各个信息<br>异常信息<br>运行时常量池:包含字面量，类型，属性，方法的符号引用<br>字节以符号出现<br>#15   都是使用常量池里的<br>“count =” +count  底层会new StringBuilder<br>运行时常量池:动态性，字节码加载时的动态表现形式<br>方法区的演进</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/jvm/12.png" alt="jvm分区" title>                </div>                <div class="image-caption">jvm分区</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/jvm/13.png" alt="jvm分区" title>                </div>                <div class="image-caption">jvm分区</div>            </figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//openjdk.java.net/jeps/122</span></span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/jvm/14.png" alt="jvm分区" title>                </div>                <div class="image-caption">jvm分区</div>            </figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Motivation</span><br><span class="line">This is part of the JRockit and Hotspot convergence effort. <span class="function">JRockit customers <span class="keyword">do</span> not need to configure the permanent <span class="title">generation</span> <span class="params">(since JRockit does not have a permanent generation)</span> and are accustomed to not configuring the permanent generation.</span></span><br><span class="line"><span class="function">因为别人没有   我也没有</span></span><br></pre></td></tr></table></figure><h1 id="为什么要替换元空间？"><a href="#为什么要替换元空间？" class="headerlink" title="为什么要替换元空间？"></a>为什么要替换元空间？</h1><p>1.永久代设置空间大小很难确定，动态还是不动态都很难<br>2.对永久代调优很困难</p><h1 id="为什么字符常量池和静态变量发生了变化？"><a href="#为什么字符常量池和静态变量发生了变化？" class="headerlink" title="为什么字符常量池和静态变量发生了变化？"></a>为什么字符常量池和静态变量发生了变化？</h1><p>因为永久代回收效率比较低，当创建大量字符串的时候，回收效率低，导致内存不足</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/jvm/15.png" alt="jvm分区" title>                </div>                <div class="image-caption">jvm分区</div>            </figure><p>方法区存在垃圾回收，只不过是回收的条件比较苛刻</p><h1 id="对象实例化的几种方式"><a href="#对象实例化的几种方式" class="headerlink" title="对象实例化的几种方式"></a>对象实例化的几种方式</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/jvm/16.png" alt="jvm分区" title>                </div>                <div class="image-caption">jvm分区</div>            </figure><p>给对象的属性赋值的操作<br>1.属性的默认初始化<br>2.显示初始化<br>3.代码块初始化<br>4构造器初始化<br>既有解释器又有编译器，结合运行<br>机器码 指令 汇编<br>即时编译器<br>热点代码探测方式：依执行频率而定 需要编译为本地代码的<br>只有在server模式下<br>分层编译<br>JDK10 新增编译器 Graal</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">String str=<span class="keyword">new</span> String(<span class="string">"good"</span>);</span><br><span class="line"><span class="keyword">char</span>[] ch=&#123;<span class="string">'t'</span>,<span class="string">'e'</span>,<span class="string">'s'</span>,<span class="string">'t'</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(String str,<span class="keyword">char</span> ch[])</span></span>&#123;</span><br><span class="line">    str=<span class="string">"test ok"</span></span><br><span class="line">    <span class="keyword">char</span>[<span class="number">0</span>]=b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> voud <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    StringExer ex=<span class="keyword">new</span> StingExer();</span><br><span class="line">    xe.change(ex.str,ex.ch);</span><br><span class="line">    sysout(ex.str)<span class="comment">//good</span></span><br><span class="line">    sysout(ex.ch)<span class="comment">//best</span></span><br><span class="line">&#125;</span><br><span class="line">造<span class="number">10</span>万行数据</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenerateString</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        FileWriter fw=<span class="keyword">new</span> FileWriter(word.txt);</span><br><span class="line">        fori100000</span><br><span class="line">        <span class="keyword">int</span> length=(<span class="keyword">int</span>)(Math.random()*(<span class="number">10</span>-<span class="number">1</span>+<span class="number">1</span>)+<span class="number">1</span>);</span><br><span class="line">        fw.write(str.getString(length)+<span class="string">"\n"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    fw.close;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>什么是双亲委派？<br>如果一个类加载器收到了加载某个类的请求,则该类加载器并不会去加载该类,而是把这个请求委派给父类加载器,每一个层次的类加载器都是如此,因此所有的类加载请求最终都会传送到顶端的启动类加载器;只有当父类加载器在其搜索范围内无法找到所需的类,并将该结果反馈给子类加载器,子类加载器会尝试去自己加载。<br>为什么要用双亲委派？<br>如果不是同一个类加载器加载，即时是相同的class文件，也会出现判断不想同的情况，从而引发一些意想不到的情况，为了保证相同的class文件，在使用的时候，是相同的对象，jvm设计的时候，采用了双亲委派的方式来加载类。<br>如何打破双亲委派？</p><p>通过自定义加载器的过程，我们知道，实现自定义的classloader，需要重新loadClass以及findClass<br>为什么要打破双亲委派？<br>主要处于安全性，防止核心类库的类被改写。你要是随便写一些基础String Object 那jvm就乱套了</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/shuangqinweipai.png" alt="jvm分区" title>                </div>                <div class="image-caption">jvm分区</div>            </figure><p>对象是否被回收 经历两次标记过程<br>MAT Jprofiler</p><p>memory  Analyzer<br><a href="http://www.eclipse.org/mat" target="_blank" rel="noopener">http://www.eclipse.org/mat</a><br>jps<br>jmap  -dump:format=b,live,file=test1.bin 14036</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2020/10/13/JVM%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/1.png&quot; class title=&quot;This is an example image&quot;&gt;
&lt;p&gt;虚拟机规范&lt;br&gt;&lt;
      
    
    </summary>
    
    
    
      <category term="JVM" scheme="http://kkget.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>数据库中间件系列</title>
    <link href="http://kkget.github.io/2020/09/30/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%B3%BB%E5%88%97/"/>
    <id>http://kkget.github.io/2020/09/30/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%B3%BB%E5%88%97/</id>
    <published>2020-09-30T02:38:32.000Z</published>
    <updated>2020-09-30T06:11:44.174Z</updated>
    
    <content type="html"><![CDATA[<p>数据库链接池过多，或者导致数据库挂了，如果主备机切换，需要更改配置<br>java应用与数据库紧耦合</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/dbcenter/1.png" alt="图1" title>                </div>                <div class="image-caption">图1</div>            </figure><p>官网:<a href="http://www.mycat.io/" target="_blank" rel="noopener">http://www.mycat.io/</a></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/dbcenter/2.png" alt="图1" title>                </div>                <div class="image-caption">图1</div>            </figure><p>主从复制，主备切换，双主双从</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/dbcenter/3.png" alt="图1" title>                </div>                <div class="image-caption">图1</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/dbcenter/4.png" alt="图1" title>                </div>                <div class="image-caption">图1</div>            </figure><p>Mycat原理:拦截<br>安装<br>Springboot整合</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.0.0&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">            &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p>application.yml配置文件：<br>#设置应用端口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">8080</span></span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    # Mycat连接</span><br><span class="line">    url: jdbc:mysql:<span class="comment">//localhost:8066/springboot?useUnicode=true&amp;characterEncoding=utf-8&amp;autoReconnect=true&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=false&amp;serverTimezone=GMT%2B8</span></span><br><span class="line">    username: root</span><br><span class="line">    password: <span class="number">123456</span></span><br><span class="line"></span><br><span class="line"># MyBatis</span><br><span class="line">mybatis:</span><br><span class="line">    type-aliases-<span class="keyword">package</span>: com.example.springbootmybatismycat.domain</span><br><span class="line">    mapper-locations: classpath:/mybatis<span class="comment">/*.xml</span></span><br><span class="line"><span class="comment">    #sql打印配置</span></span><br><span class="line"><span class="comment">    configuration:</span></span><br><span class="line"><span class="comment">        log-impl: org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br></pre></td></tr></table></figure><p>一、基本概念<br>Sharding-Sphere简介<br>Sharding-Sphere官网：<a href="http://shardingsphere.apache.org/index_zh.html" target="_blank" rel="noopener">http://shardingsphere.apache.org/index_zh.html</a></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/dbcenter/5.png" alt="图1" title>                </div>                <div class="image-caption">图1</div>            </figure><p>一套开源的分布式数据库中间件解决方案。<br>有三个产品，Sharding-JDBC、Sharding-Proxy 和 Sharding-Sidecar。<br>ShardingSphere 定位为关系型数据库中间件，合理地在分布式环境下使用关系型数据库操作。<br>分库分表<br>数据据库数据量是不可控的，随着时间和业务发展，造成表里面数据越来越多，如果再去对数据库表curd操作时，就会有性能问题。<br>解决办法：<br>方案1：从硬件上<br>方案2：分库分表<br>为了解决由于数据量过大而造成数据库性能降低问题。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/dbcenter/6.png" alt="图1" title>                </div>                <div class="image-caption">图1</div>            </figure><p>分库分表的方式<br>分库分表有两种方式：垂直切分和水平切分。<br>垂直切分：垂直分表和垂直分库<br>水平切分：水平分表和水平分库<br>垂直拆字段，水平拆记录。<br>垂直切分的库和表结构是不同的，而水平切分的库和表是相同的。<br>垂直分表<br>操作数据库中某张表，把这张表中一部分字段数据存到一张新表里面，再把这张表另部分字段数据存到另外一张表里面。<br>垂直拆分成的两张表，每张表的数据量和原先的表的数据量相同。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/dbcenter/7.png" alt="图1" title>                </div>                <div class="image-caption">图1</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/dbcenter/8.png" alt="图1" title>                </div>                <div class="image-caption">图1</div>            </figure><p>垂直分库<br>把单一数据库按照业务进行划分，专库专表。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/dbcenter/9.png" alt="图1" title>                </div>                <div class="image-caption">图1</div>            </figure><p>水平分库</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/dbcenter/10.png" alt="图1" title>                </div>                <div class="image-caption">图1</div>            </figure><p>水平分表</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/dbcenter/12.png" alt="图1" title>                </div>                <div class="image-caption">图1</div>            </figure><p>分库分表的应用和问题<br>应用<br>在数据库设计时候就要考虑垂直分库和垂直分表。<br>随着数据库数据量增加，不要马上考虑做水平切分。首先考虑缓存处理，读写分离，使用索引等等方式。如果这些方式不能根本解决问题了，再考虑做水平分库和水平分表。<br>分库分表问题<br>跨节点连接查询问题(分页、排序)。<br>多数据源管理问题。<br>二、Sharding-JDBC 分库分表操作<br>ShardingSphere-JDBC 简介</p><p>Sharding-JDBC是轻量级的Java框架，是增强的JDBC驱动。</p><p>Sharding-JDBC的功能：主要做数据分片和读写分离，不是做分库分表，分库分表由我们自己做。<br>主要的目的：简化分库分表后数据的相关操作。<br>Sharding-JDBC 实现水平分表<br>搭建环境<br>技术：SpringBoot2.2.1 + MybatisPlus + Sharding-JDBC + Druid连接池<br>创建项目</p><p>修改SpringBoot的版本</p><p>pom.xml引入相关的依赖<br>    <dependency><br>        <groupId>com.alibaba</groupId><br>        <artifactId>druid-spring-boot-starter</artifactId><br>        <version>1.1.20</version><br>    </dependency></p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;    &lt;version&gt;8.0.18&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.apache.shardingsphere&lt;/groupId&gt;    &lt;artifactId&gt;sharding-jdbc-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;4.0.0-RC1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;    &lt;version&gt;3.0.5&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;    &lt;artifactId&gt;lombok&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>按照水平分表的方式创建数据库、数据表<br>创建数据库 course_db。<br>在数据库中创建两张表 course_1 和 course_2。<br>数据存放约定规则：添加的数据id为偶数放 course_1 表中，id为奇数放 course_2 表中。<br>create database course_db;</p><p>use course_db;</p><p>create table course_1 (<br>    <code>cid</code> bigint(20) primary key,<br>    <code>cname</code> varchar(50) not null,<br>    <code>user_id</code> bigint(20) not null,<br>    <code>cstatus</code> varchar(10) not null<br>);</p><p>create table course_2 (<br>    <code>cid</code> bigint(20) primary key,<br>    <code>cname</code> varchar(50) not null,<br>    <code>user_id</code> bigint(20) not null,<br>    <code>cstatus</code> varchar(10) not null<br>);</p><p>编写代码实现对分库分表数据的操作<br>在shardingjdbcdemo包下创建 entity.Course 实体类<br>@Data<br>public class Course {<br>    private Long cid;<br>    private String cname;<br>    private Long userId;<br>    private String cstatus;<br>}</p><p>创建mapper.CourseMapper 接口<br>@Repository<br>public interface CourseMapper extends BaseMapper<Course> {}</Course></p><p>在启动类上加上@MapperScan(“com.angenin.shardingjdbcdemo.mapper”)注解<br>配置水平分表策略<br>官网数据分片配置：<a href="https://shardingsphere.apache.org/document/current/cn/user-manual/shardingsphere-jdbc/usage/sharding/spring-boot-starter/" target="_blank" rel="noopener">https://shardingsphere.apache.org/document/current/cn/user-manual/shardingsphere-jdbc/usage/sharding/spring-boot-starter/</a></p><p>在 application.properties 配置文件中配置：（下面数据库密码记得写）</p><h1 id="shardingjdbc-水平分表策略"><a href="#shardingjdbc-水平分表策略" class="headerlink" title="shardingjdbc 水平分表策略"></a>shardingjdbc 水平分表策略</h1><h1 id="配置数据源，给数据源起别名"><a href="#配置数据源，给数据源起别名" class="headerlink" title="配置数据源，给数据源起别名"></a>配置数据源，给数据源起别名</h1><p>spring.shardingsphere.datasource.names=m1</p><h1 id="一个实体类对应两张表，覆盖"><a href="#一个实体类对应两张表，覆盖" class="headerlink" title="一个实体类对应两张表，覆盖"></a>一个实体类对应两张表，覆盖</h1><p>spring.main.allow-bean-definition-overriding=true</p><h1 id="配置数据源的具体内容，包含连接池，驱动，地址，用户名，密码"><a href="#配置数据源的具体内容，包含连接池，驱动，地址，用户名，密码" class="headerlink" title="配置数据源的具体内容，包含连接池，驱动，地址，用户名，密码"></a>配置数据源的具体内容，包含连接池，驱动，地址，用户名，密码</h1><p>spring.shardingsphere.datasource.m1.type=com.alibaba.druid.pool.DruidDataSource<br>spring.shardingsphere.datasource.m1.driver-class-name=com.mysql.cj.jdbc.Driver<br>spring.shardingsphere.datasource.m1.url=jdbc:mysql://localhost:3306/course_db?serverTimezone=GMT%2B8<br>spring.shardingsphere.datasource.m1.username=root<br>spring.shardingsphere.datasource.m1.password=</p><h1 id="指定course表分布的情况，配置表在哪个数据库里，表的名称都是什么-m1-course-1-m1-course-2"><a href="#指定course表分布的情况，配置表在哪个数据库里，表的名称都是什么-m1-course-1-m1-course-2" class="headerlink" title="指定course表分布的情况，配置表在哪个数据库里，表的名称都是什么 m1.course_1,m1.course_2"></a>指定course表分布的情况，配置表在哪个数据库里，表的名称都是什么 m1.course_1,m1.course_2</h1><p>spring.shardingsphere.sharding.tables.course.actual-data-nodes=m1.course_$-&gt;{1..2}</p><h1 id="指定-course-表里面主键-cid-的生成策略-SNOWFLAKE"><a href="#指定-course-表里面主键-cid-的生成策略-SNOWFLAKE" class="headerlink" title="指定 course 表里面主键 cid 的生成策略 SNOWFLAKE"></a>指定 course 表里面主键 cid 的生成策略 SNOWFLAKE</h1><p>spring.shardingsphere.sharding.tables.course.key-generator.column=cid<br>spring.shardingsphere.sharding.tables.course.key-generator.type=SNOWFLAKE</p><h1 id="配置分表策略-约定-cid-值偶数添加到-course-1-表，如果-cid-是奇数添加到-course-2-表"><a href="#配置分表策略-约定-cid-值偶数添加到-course-1-表，如果-cid-是奇数添加到-course-2-表" class="headerlink" title="配置分表策略    约定 cid 值偶数添加到 course_1 表，如果 cid 是奇数添加到 course_2 表"></a>配置分表策略    约定 cid 值偶数添加到 course_1 表，如果 cid 是奇数添加到 course_2 表</h1><p>spring.shardingsphere.sharding.tables.course.table-strategy.inline.shardingcolumn=cid<br>spring.shardingsphere.sharding.tables.course.table-strategy.inline.algorithmexpression=course_$-&gt;{cid % 2 + 1}</p><h1 id="打开-sql-输出日志"><a href="#打开-sql-输出日志" class="headerlink" title="打开 sql 输出日志"></a>打开 sql 输出日志</h1><p>spring.shardingsphere.props.sql.show=true</p><p>编写测试代码<br>在test包中的测试类中进行测试<br>@RunWith(SpringRunner.class)<br>@SpringBootTest<br>public class ShardingjdbcdemoApplicationTests {</p><pre><code>@Autowiredprivate CourseMapper courseMapper;//添加课程@Testpublic void addCourse(){    Course course = new Course();    //cid由我们设置的策略，雪花算法进行生成（至少70年内生成的id不会重复）    course.setCname(&quot;java&quot;);    course.setUserId(100L);    course.setCstatus(&quot;Normal&quot;);    courseMapper.insert(course);}//查询课程@Testpublic void findCourse(){    QueryWrapper&lt;Course&gt; wrapper = new QueryWrapper&lt;&gt;();    wrapper.eq(&quot;cid&quot;, 509755853058867201L);    courseMapper.selectOne(wrapper);}</code></pre><p>}</p><p>addCourse方法执行结果：</p><p>findCourse方法执行结果：</p><p>Sharding-JDBC 实现水平分库<br>需求分析</p><p>创建数据库，数据表<br>create database edu_db_1;<br>create database edu_db_2;</p><p>use edu_db_1;</p><p>create table course_1 (<br>    <code>cid</code> bigint(20) primary key,<br>    <code>cname</code> varchar(50) not null,<br>    <code>user_id</code> bigint(20) not null,<br>    <code>cstatus</code> varchar(10) not null<br>);</p><p>create table course_2 (<br>    <code>cid</code> bigint(20) primary key,<br>    <code>cname</code> varchar(50) not null,<br>    <code>user_id</code> bigint(20) not null,<br>    <code>cstatus</code> varchar(10) not null<br>);</p><p>use edu_db_2;</p><p>create table course_1 (<br>    <code>cid</code> bigint(20) primary key,<br>    <code>cname</code> varchar(50) not null,<br>    <code>user_id</code> bigint(20) not null,<br>    <code>cstatus</code> varchar(10) not null<br>);</p><p>create table course_2 (<br>    <code>cid</code> bigint(20) primary key,<br>    <code>cname</code> varchar(50) not null,<br>    <code>user_id</code> bigint(20) not null,<br>    <code>cstatus</code> varchar(10) not null<br>);</p><p>配置水平分库策略<br>下面数据库的密码填自己的。</p><h1 id="shardingjdbc-水平分库分表策略"><a href="#shardingjdbc-水平分库分表策略" class="headerlink" title="shardingjdbc 水平分库分表策略"></a>shardingjdbc 水平分库分表策略</h1><h1 id="配置数据源，给数据源起别名-1"><a href="#配置数据源，给数据源起别名-1" class="headerlink" title="配置数据源，给数据源起别名"></a>配置数据源，给数据源起别名</h1><h1 id="水平分库需要配置多个数据库"><a href="#水平分库需要配置多个数据库" class="headerlink" title="水平分库需要配置多个数据库"></a>水平分库需要配置多个数据库</h1><p>spring.shardingsphere.datasource.names=m1,m2</p><h1 id="一个实体类对应两张表，覆盖-1"><a href="#一个实体类对应两张表，覆盖-1" class="headerlink" title="一个实体类对应两张表，覆盖"></a>一个实体类对应两张表，覆盖</h1><p>spring.main.allow-bean-definition-overriding=true</p><h1 id="配置第一个数据源的具体内容，包含连接池，驱动，地址，用户名，密码"><a href="#配置第一个数据源的具体内容，包含连接池，驱动，地址，用户名，密码" class="headerlink" title="配置第一个数据源的具体内容，包含连接池，驱动，地址，用户名，密码"></a>配置第一个数据源的具体内容，包含连接池，驱动，地址，用户名，密码</h1><p>spring.shardingsphere.datasource.m1.type=com.alibaba.druid.pool.DruidDataSource<br>spring.shardingsphere.datasource.m1.driver-class-name=com.mysql.cj.jdbc.Driver<br>spring.shardingsphere.datasource.m1.url=jdbc:mysql://localhost:3306/edu_db_1?serverTimezone=GMT%2B8<br>spring.shardingsphere.datasource.m1.username=root<br>spring.shardingsphere.datasource.m1.password=</p><h1 id="配置第二个数据源的具体内容，包含连接池，驱动，地址，用户名，密码"><a href="#配置第二个数据源的具体内容，包含连接池，驱动，地址，用户名，密码" class="headerlink" title="配置第二个数据源的具体内容，包含连接池，驱动，地址，用户名，密码"></a>配置第二个数据源的具体内容，包含连接池，驱动，地址，用户名，密码</h1><p>spring.shardingsphere.datasource.m2.type=com.alibaba.druid.pool.DruidDataSource<br>spring.shardingsphere.datasource.m2.driver-class-name=com.mysql.cj.jdbc.Driver<br>spring.shardingsphere.datasource.m2.url=jdbc:mysql://localhost:3306/edu_db_2?serverTimezone=GMT%2B8<br>spring.shardingsphere.datasource.m2.username=root<br>spring.shardingsphere.datasource.m2.password=</p><h1 id="指定数据库分布的情况和数据表分布的情况"><a href="#指定数据库分布的情况和数据表分布的情况" class="headerlink" title="指定数据库分布的情况和数据表分布的情况"></a>指定数据库分布的情况和数据表分布的情况</h1><h1 id="m1-m2-course-1-course-2"><a href="#m1-m2-course-1-course-2" class="headerlink" title="m1 m2   course_1 course_2"></a>m1 m2   course_1 course_2</h1><p>spring.shardingsphere.sharding.tables.course.actual-data-nodes=m$-&gt;{1..2}.course_$-&gt;{1..2}</p><h1 id="指定-course-表里面主键-cid-的生成策略-SNOWFLAKE-1"><a href="#指定-course-表里面主键-cid-的生成策略-SNOWFLAKE-1" class="headerlink" title="指定 course 表里面主键 cid 的生成策略 SNOWFLAKE"></a>指定 course 表里面主键 cid 的生成策略 SNOWFLAKE</h1><p>spring.shardingsphere.sharding.tables.course.key-generator.column=cid<br>spring.shardingsphere.sharding.tables.course.key-generator.type=SNOWFLAKE</p><h1 id="指定分库策略-约定-user-id-值偶数添加到-m1-库，如果-user-id-是奇数添加到-m2-库"><a href="#指定分库策略-约定-user-id-值偶数添加到-m1-库，如果-user-id-是奇数添加到-m2-库" class="headerlink" title="指定分库策略    约定 user_id 值偶数添加到 m1 库，如果 user_id 是奇数添加到 m2 库"></a>指定分库策略    约定 user_id 值偶数添加到 m1 库，如果 user_id 是奇数添加到 m2 库</h1><h1 id="默认写法（所有的表的user-id）"><a href="#默认写法（所有的表的user-id）" class="headerlink" title="默认写法（所有的表的user_id）"></a>默认写法（所有的表的user_id）</h1><p>#spring.shardingsphere.sharding.default-database-strategy.inline.sharding-column=user_id<br>#spring.shardingsphere.sharding.default-database-strategy.inline.algorithm-expression=m$-&gt;{user_id % 2 + 1}</p><h1 id="指定只有course表的user-id"><a href="#指定只有course表的user-id" class="headerlink" title="指定只有course表的user_id"></a>指定只有course表的user_id</h1><p>spring.shardingsphere.sharding.tables.course.database-strategy.inline.sharding-column=user_id<br>spring.shardingsphere.sharding.tables.course.database-strategy.inline.algorithm-expression=m$-&gt;{user_id % 2 + 1}</p><h1 id="指定分表策略-约定-cid-值偶数添加到-course-1-表，如果-cid-是奇数添加到-course-2-表"><a href="#指定分表策略-约定-cid-值偶数添加到-course-1-表，如果-cid-是奇数添加到-course-2-表" class="headerlink" title="指定分表策略    约定 cid 值偶数添加到 course_1 表，如果 cid 是奇数添加到 course_2 表"></a>指定分表策略    约定 cid 值偶数添加到 course_1 表，如果 cid 是奇数添加到 course_2 表</h1><p>spring.shardingsphere.sharding.tables.course.table-strategy.inline.sharding-column=cid<br>spring.shardingsphere.sharding.tables.course.table-strategy.inline.algorithm-expression=course_$-&gt;{cid % 2 + 1}</p><h1 id="打开-sql-输出日志-1"><a href="#打开-sql-输出日志-1" class="headerlink" title="打开 sql 输出日志"></a>打开 sql 输出日志</h1><p>spring.shardingsphere.props.sql.show=true</p><p>编写测试代码<br>    //添加课程<br>    @Test<br>    public void addCourseDb(){<br>        Course course = new Course();<br>        //cid由我们设置的策略，雪花算法进行生成（至少70年内生成的id不会重复）<br>        course.setCname(“javademo”);<br>        //分库根据user_id<br>        course.setUserId(100L);<br>        course.setCstatus(“Normal”);<br>        courseMapper.insert(course);</p><pre><code>    course.setCname(&quot;javademo2&quot;);    course.setUserId(111L);    courseMapper.insert(course);}//查询课程@Testpublic void findCourseDb(){    QueryWrapper&lt;Course&gt; wrapper = new QueryWrapper&lt;&gt;();    //设置user_id的值    wrapper.eq(&quot;user_id&quot;, 100L);    //设置cid的值    wrapper.eq(&quot;cid&quot;, 509771111076986881L);    Course course = courseMapper.selectOne(wrapper);    System.out.println(course);}</code></pre><p>addCourseDb方法执行结果：</p><p>findCourseDb方法执行结果：</p><p>Sharding-JDBC 实现垂直分库<br>需求分析</p><p>需要查询用户信息的时候，不需要查到课程信息。<br>创建用户数据库、数据表<br>create database user_db;</p><p>use user_db;</p><p>create table t_user(<br>    <code>user_id</code> bigint(20) primary key,<br>    <code>username</code> varchar(100) not null,<br>    <code>ustatus</code> varchar(50) not null<br>);</p><p>编写User代码<br>创建user实体类和对应的mapper<br>@Data<br>@TableName(“t_user”)    //指定对应的表名<br>public class User {<br>    private Long userId;<br>    private String username;<br>    private String ustatus;<br>}</p><p>@Repository<br>public interface UserMapper extends BaseMapper<User> {}</User></p><p>配置垂直分库策略<br>记得写数据库密码。</p><h1 id="shardingjdbc-垂直分库策略"><a href="#shardingjdbc-垂直分库策略" class="headerlink" title="shardingjdbc 垂直分库策略"></a>shardingjdbc 垂直分库策略</h1><h1 id="配置数据源，给数据源起别名-2"><a href="#配置数据源，给数据源起别名-2" class="headerlink" title="配置数据源，给数据源起别名"></a>配置数据源，给数据源起别名</h1><h1 id="水平分库需要配置多个数据库-1"><a href="#水平分库需要配置多个数据库-1" class="headerlink" title="水平分库需要配置多个数据库"></a>水平分库需要配置多个数据库</h1><h1 id="m0为用户数据库"><a href="#m0为用户数据库" class="headerlink" title="m0为用户数据库"></a>m0为用户数据库</h1><p>spring.shardingsphere.datasource.names=m1,m2,m0</p><h1 id="一个实体类对应两张表，覆盖-2"><a href="#一个实体类对应两张表，覆盖-2" class="headerlink" title="一个实体类对应两张表，覆盖"></a>一个实体类对应两张表，覆盖</h1><p>spring.main.allow-bean-definition-overriding=true</p><h1 id="配置第一个数据源的具体内容，包含连接池，驱动，地址，用户名，密码-1"><a href="#配置第一个数据源的具体内容，包含连接池，驱动，地址，用户名，密码-1" class="headerlink" title="配置第一个数据源的具体内容，包含连接池，驱动，地址，用户名，密码"></a>配置第一个数据源的具体内容，包含连接池，驱动，地址，用户名，密码</h1><p>spring.shardingsphere.datasource.m1.type=com.alibaba.druid.pool.DruidDataSource<br>spring.shardingsphere.datasource.m1.driver-class-name=com.mysql.cj.jdbc.Driver<br>spring.shardingsphere.datasource.m1.url=jdbc:mysql://localhost:3306/edu_db_1?serverTimezone=GMT%2B8<br>spring.shardingsphere.datasource.m1.username=root<br>spring.shardingsphere.datasource.m1.password=</p><h1 id="配置第二个数据源的具体内容，包含连接池，驱动，地址，用户名，密码-1"><a href="#配置第二个数据源的具体内容，包含连接池，驱动，地址，用户名，密码-1" class="headerlink" title="配置第二个数据源的具体内容，包含连接池，驱动，地址，用户名，密码"></a>配置第二个数据源的具体内容，包含连接池，驱动，地址，用户名，密码</h1><p>spring.shardingsphere.datasource.m2.type=com.alibaba.druid.pool.DruidDataSource<br>spring.shardingsphere.datasource.m2.driver-class-name=com.mysql.cj.jdbc.Driver<br>spring.shardingsphere.datasource.m2.url=jdbc:mysql://localhost:3306/edu_db_2?serverTimezone=GMT%2B8<br>spring.shardingsphere.datasource.m2.username=root<br>spring.shardingsphere.datasource.m2.password=</p><h1 id="配置user数据源的具体内容，包含连接池，驱动，地址，用户名，密码"><a href="#配置user数据源的具体内容，包含连接池，驱动，地址，用户名，密码" class="headerlink" title="配置user数据源的具体内容，包含连接池，驱动，地址，用户名，密码"></a>配置user数据源的具体内容，包含连接池，驱动，地址，用户名，密码</h1><p>spring.shardingsphere.datasource.m0.type=com.alibaba.druid.pool.DruidDataSource<br>spring.shardingsphere.datasource.m0.driver-class-name=com.mysql.cj.jdbc.Driver<br>spring.shardingsphere.datasource.m0.url=jdbc:mysql://localhost:3306/user_db?serverTimezone=GMT%2B8<br>spring.shardingsphere.datasource.m0.username=root<br>spring.shardingsphere.datasource.m0.password=</p><h1 id="配置user-db数据库里面t-user-专库专表"><a href="#配置user-db数据库里面t-user-专库专表" class="headerlink" title="配置user_db数据库里面t_user  专库专表"></a>配置user_db数据库里面t_user  专库专表</h1><p>spring.shardingsphere.sharding.tables.t_user.actual-data-nodes=m0.t_user</p><h1 id="配置主键的生成策略"><a href="#配置主键的生成策略" class="headerlink" title="配置主键的生成策略"></a>配置主键的生成策略</h1><p>spring.shardingsphere.sharding.tables.t_user.key-generator.column=user_id<br>spring.shardingsphere.sharding.tables.t_user.key-generator.type=SNOWFLAKE</p><h1 id="指定分表策略"><a href="#指定分表策略" class="headerlink" title="指定分表策略"></a>指定分表策略</h1><p>spring.shardingsphere.sharding.tables.t_user.table-strategy.inline.sharding-column=user_id<br>spring.shardingsphere.sharding.tables.t_user.table-strategy.inline.algorithm-expression=t_user</p><h1 id="…-其他配置同上"><a href="#…-其他配置同上" class="headerlink" title="… 其他配置同上"></a>… 其他配置同上</h1><p>编写测试代码<br>    //添加用户<br>    @Test<br>    public void addUserDb(){<br>        User user = new User();<br>        user.setUsername(“张三”);<br>        user.setUstatus(“a”);<br>        userMapper.insert(user);<br>    }</p><pre><code>@Test//查询用户public void findUserDb(){    QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;();    wrapper.eq(&quot;user_id&quot;, 509793334663839745L);    User user = userMapper.selectOne(wrapper);    System.out.println(user);}</code></pre><p>addUserDb方法执行结果：</p><p>findUserDb方法执行结果：</p><p>Sharding-JDBC 公共表<br>公共表概念<br>存储固定数据的表，表数据很少发生变化，查询时经常要进行关联。<br>在每个数据库中都创建出相同结构公共表。<br>操作公共表时，同时操作添加了公共表的数据库中的公共表，添加记录时，同时添加，删除时，同时删除。<br>在多个数据库中创建相同结构的公共表<br>use user_db;<br>#use edu_db_1;<br>#use edu_db_2;</p><p>create table t_udict(<br>    <code>dictid</code> bigint(20) primary key,<br>    <code>ustatus</code> varchar(100) not null,<br>    <code>uvalue</code> varchar(100) not null<br>);</p><p>公共表配置</p><h1 id="其他配置同上"><a href="#其他配置同上" class="headerlink" title="其他配置同上"></a>其他配置同上</h1><h1 id="…"><a href="#…" class="headerlink" title="…"></a>…</h1><h1 id="公共表配置"><a href="#公共表配置" class="headerlink" title="公共表配置"></a>公共表配置</h1><p>spring.shardingsphere.sharding.broadcast-tables=t_udict</p><h1 id="配置主键的生成策略-1"><a href="#配置主键的生成策略-1" class="headerlink" title="配置主键的生成策略"></a>配置主键的生成策略</h1><p>spring.shardingsphere.sharding.tables.t_udict.key-generator.column=dictid<br>spring.shardingsphere.sharding.tables.t_udict.key-generator.type=SNOWFLAKE</p><h1 id="…-1"><a href="#…-1" class="headerlink" title="…"></a>…</h1><p>编写公共表的实体类及mapper<br>@Data<br>@TableName(value = “t_udict”)<br>public class Udict {<br>    private Long dictid;<br>    private String ustatus;<br>    private String uvalue;<br>}</p><p>@Repository<br>public interface UdictMapper extends BaseMapper<Udict> {}</Udict></p><p>编写测试代码<br>    //添加<br>    @Test<br>    public void addDict(){<br>        Udict udict = new Udict();<br>        udict.setUstatus(“a”);<br>        udict.setUvalue(“已启用”);<br>        udictMapper.insert(udict);<br>    }</p><pre><code>//删除@Testpublic void deleteDict(){    QueryWrapper&lt;Udict&gt; wrapper = new QueryWrapper&lt;&gt;();    wrapper.eq(&quot;dictid&quot;, 509811689974136833L);    udictMapper.delete(wrapper);}</code></pre><p>addDict方法执行结果：</p><p>deleteDict方法执行结果：</p><p>Sharding-JDBC 实现读写分离<br>读写分离概念</p><p>读写原理</p><p>Sharding-JDBC 读写分离</p><p>Sharding-JDBC通过sql语句语义分析，当sql语句有insert、update、delete时，Sharding-JDBC就把这次操作在主数据库上执行；当sql语句有select时，就会把这次操作在从数据库上执行，从而实现读写分离过程。但Sharding-JDBC并不会做数据同步，数据同步是配置MySQL后由MySQL自己完成的。<br>MySQL 一主一从读写分离配置<br>我采用的是docker来实现的，单独写在这篇文章里：<a href="https://blog.csdn.net/qq_36903261/article/details/108457759" target="_blank" rel="noopener">https://blog.csdn.net/qq_36903261/article/details/108457759</a><br>使用docker后，需要在主服务器上新建原先的数据库数据表。<br>因为记录的文件名以及位点每次重启或刷新都会改变，所以以下命令放在这里，方便查看。<br>主mysql：<br>#确认位点 记录下文件名以及位点（重启或者刷新都会改变）<br>show master status;</p><p>1<br>2<br>从mysql：<br>#先停止同步<br>STOP SLAVE;</p><p>#修改从库指向到主库，使用上一步记录的文件名以及位点</p><h1 id="master-host-docker容器linux的ip地址"><a href="#master-host-docker容器linux的ip地址" class="headerlink" title="master_host docker容器linux的ip地址"></a>master_host docker容器linux的ip地址</h1><h1 id="master-port-主mysql暴露的端口"><a href="#master-port-主mysql暴露的端口" class="headerlink" title="master_port 主mysql暴露的端口"></a>master_port 主mysql暴露的端口</h1><h1 id="master-user-主mysql的用户名"><a href="#master-user-主mysql的用户名" class="headerlink" title="master_user 主mysql的用户名"></a>master_user 主mysql的用户名</h1><h1 id="master-password-主mysql的密码"><a href="#master-password-主mysql的密码" class="headerlink" title="master_password 主mysql的密码"></a>master_password 主mysql的密码</h1><p>#（最后两项修改成刚刚从主mysql查到的，主mysql每次刷新权限或者重启时，这两个值都会改变，所以每次都需要查看是否相同）<br>CHANGE MASTER TO<br>master_host = ‘10.211.55.26’,<br>master_port = 33060,<br>master_user = ‘db_sync’,<br>master_password = ‘db_sync’,<br>master_log_file = ‘mysql-bin.000001’,<br>master_log_pos = 823;</p><p>#启动同步<br>START SLAVE;</p><p>#查看Slave_IO_Runing和Slave_SQL_Runing字段值都为Yes，表示同步配置成功。<br>show slave status \G;</p><p>Sharding-JDBC 操作<br>配置读写分离策略<br>也使用docker的，复制的时候记得改一下ip地址</p><h1 id="配置数据源，给数据源起别名-3"><a href="#配置数据源，给数据源起别名-3" class="headerlink" title="配置数据源，给数据源起别名"></a>配置数据源，给数据源起别名</h1><h1 id="m0为用户数据库-1"><a href="#m0为用户数据库-1" class="headerlink" title="m0为用户数据库"></a>m0为用户数据库</h1><p>spring.shardingsphere.datasource.names=m0,s0</p><h1 id="一个实体类对应两张表，覆盖-3"><a href="#一个实体类对应两张表，覆盖-3" class="headerlink" title="一个实体类对应两张表，覆盖"></a>一个实体类对应两张表，覆盖</h1><p>spring.main.allow-bean-definition-overriding=true</p><p>#user_db 主服务器<br>spring.shardingsphere.datasource.m0.type=com.alibaba.druid.pool.DruidDataSource<br>spring.shardingsphere.datasource.m0.driver-class-name=com.mysql.cj.jdbc.Driver<br>spring.shardingsphere.datasource.m0.url=jdbc:mysql://10.211.55.26:33060/user_db?serverTimezone=GMT%2B8<br>spring.shardingsphere.datasource.m0.username=root<br>spring.shardingsphere.datasource.m0.password=123456</p><p>#user_db 从服务器<br>spring.shardingsphere.datasource.s0.type=com.alibaba.druid.pool.DruidDataSource<br>spring.shardingsphere.datasource.s0.driver-class-name=com.mysql.cj.jdbc.Driver<br>spring.shardingsphere.datasource.s0.url=jdbc:mysql://10.211.55.26:33061/user_db?serverTimezone=GMT%2B8<br>spring.shardingsphere.datasource.s0.username=root<br>spring.shardingsphere.datasource.s0.password=123456</p><h1 id="主库从库逻辑数据源定义-ds0-为-user-db"><a href="#主库从库逻辑数据源定义-ds0-为-user-db" class="headerlink" title="主库从库逻辑数据源定义 ds0 为 user_db"></a>主库从库逻辑数据源定义 ds0 为 user_db</h1><p>spring.shardingsphere.sharding.master-slave-rules.ds0.master-data-source-name=m0<br>spring.shardingsphere.sharding.master-slave-rules.ds0.slave-data-source-names=s0</p><h1 id="配置user-db数据库里面t-user-专库专表-1"><a href="#配置user-db数据库里面t-user-专库专表-1" class="headerlink" title="配置user_db数据库里面t_user  专库专表"></a>配置user_db数据库里面t_user  专库专表</h1><p>#spring.shardingsphere.sharding.tables.t_user.actual-data-nodes=m0.t_user</p><h1 id="t-user-分表策略，固定分配至-ds0-的-t-user-真实表"><a href="#t-user-分表策略，固定分配至-ds0-的-t-user-真实表" class="headerlink" title="t_user 分表策略，固定分配至 ds0 的 t_user 真实表"></a>t_user 分表策略，固定分配至 ds0 的 t_user 真实表</h1><p>spring.shardingsphere.sharding.tables.t_user.actual-data-nodes=ds0.t_user</p><h1 id="配置主键的生成策略-2"><a href="#配置主键的生成策略-2" class="headerlink" title="配置主键的生成策略"></a>配置主键的生成策略</h1><p>spring.shardingsphere.sharding.tables.t_user.key-generator.column=user_id<br>spring.shardingsphere.sharding.tables.t_user.key-generator.type=SNOWFLAKE</p><h1 id="指定分表策略-1"><a href="#指定分表策略-1" class="headerlink" title="指定分表策略"></a>指定分表策略</h1><p>spring.shardingsphere.sharding.tables.t_user.table-strategy.inline.sharding-column=user_id<br>spring.shardingsphere.sharding.tables.t_user.table-strategy.inline.algorithm-expression=t_user</p><h1 id="打开-sql-输出日志-2"><a href="#打开-sql-输出日志-2" class="headerlink" title="打开 sql 输出日志"></a>打开 sql 输出日志</h1><p>spring.shardingsphere.props.sql.show=true<br>1</p><p>测试代码使用垂直分库时编写的addUserDb和findUserDb方法。<br>addUserDb方法执行结果：</p><p>findUserDb方法执行结果：</p><p>三、Sharding-Proxy 分库分表操作<br>ShardingSphere-Proxy 简介</p><p>ShardingSphere-Proxy定位为透明的数据库代理端。<br>Sharding-Proxy独立应用，使用安装服务，进行分库分表或者读写分离配置、启动。<br>下载安装 Sharding-Proxy<br><a href="https://shardingsphere.apache.org/document/current/cn/downloads/" target="_blank" rel="noopener">https://shardingsphere.apache.org/document/current/cn/downloads/</a></p><p>下载解压后，需要把lib目录下后缀不全的jar包名补全。</p><p>配置 Sharding-Proxy（分库配置）<br>进入conf目录<br>修改 server.yaml 文件（此文件为Sharding-Proxy的配置），去除掉authentication和props的注释。</p><p>修改 config-sharding.yaml 配置文件（此文件为分库分表的配置）</p><p>文件里提示说，如果使用mysql，需要把mysql的驱动jar包放到lib目录下。（到maven下载的jar包里找即可）</p><p>在主mysql上新建一个edu_1数据库（create database edu_1;）<br>然后去掉文件中关于mysql的配置代码的注释，然后进行修改。（这里我连的是docker上的主mysql）<br>schemaName: sharding_db</p><p>dataSources:<br> ds_0:<br>   url: jdbc:mysql://10.211.55.26:33060/edu_1?serverTimezone=UTC&amp;useSSL=false<br>   username: root<br>   password: 123456<br>   connectionTimeoutMilliseconds: 30000<br>   idleTimeoutMilliseconds: 60000<br>   maxLifetimeMilliseconds: 1800000<br>   maxPoolSize: 50</p><p>shardingRule:<br> tables:<br>   t_order:<br>     actualDataNodes: ds_${0}.t_order_${0..1}<br>     tableStrategy:<br>       inline:<br>         shardingColumn: order_id<br>         algorithmExpression: t_order_${order_id % 2}<br>     keyGenerator:<br>       type: SNOWFLAKE<br>       column: order_id<br> bindingTables:</p><ul><li>t_order<br>defaultDatabaseStrategy:<br>inline:<br>shardingColumn: user_id<br>algorithmExpression: ds_${0}<br>defaultTableStrategy:<br>none:</li></ul><p>启动 Sharding-Proxy 服务<br>从终端进入到bin目录，然后./start.sh启动服务。（空格然后加上端口号，可以指定端口，默认3307）</p><p>如果打开logs目录里的stdout.log文件，显示下面这种，说明启动成功。</p><p>通过终端进行连接：<br>mysql -uroot -proot -P3307<br>如果出现下面这种错误，可以尝试连接命令加上-h127.0.0.1。</p><p>mysql -uroot -proot -h127.0.0.1 -P3307</p><p>新建一张表，并插入一条数据。<br>use sharding_db;</p><p>create table if not exists ds_0.t_order(<code>order_id</code> bigint primary key,<code>user_id</code> int not null,<code>status</code> varchar(50));</p><p>insert into t_order(<code>order_id</code>,<code>user_id</code>,<code>status</code>)values(11,1,’test’);</p><p>按照order_id进行分配，因为id是奇数所以被分到了t_order_1表里。</p><p>配置 Sharding-Proxy（读写分离）<br>Sharding-Proxy与Sharding-JDBC一样，并不会进行主从复制，主从复制依然是有MySQL自己完成。<br>mysql主从复制配置<br>把上面mysql主从复制的配置复制下来，方便查看：<a href="https://blog.csdn.net/qq_36903261/article/details/108457759" target="_blank" rel="noopener">https://blog.csdn.net/qq_36903261/article/details/108457759</a><br>使用docker后，需要在主服务器上新建原先的数据库数据表。<br>因为记录的文件名以及位点每次重启或刷新都会改变，所以以下命令放在这里，方便查看。<br>主mysql：<br>#确认位点 记录下文件名以及位点（重启或者刷新都会改变）<br>show master status;</p><p>从mysql：<br>#先停止同步<br>STOP SLAVE;</p><p>#修改从库指向到主库，使用上一步记录的文件名以及位点</p><h1 id="master-host-docker容器linux的ip地址-1"><a href="#master-host-docker容器linux的ip地址-1" class="headerlink" title="master_host docker容器linux的ip地址"></a>master_host docker容器linux的ip地址</h1><h1 id="master-port-主mysql暴露的端口-1"><a href="#master-port-主mysql暴露的端口-1" class="headerlink" title="master_port 主mysql暴露的端口"></a>master_port 主mysql暴露的端口</h1><h1 id="master-user-主mysql的用户名-1"><a href="#master-user-主mysql的用户名-1" class="headerlink" title="master_user 主mysql的用户名"></a>master_user 主mysql的用户名</h1><h1 id="master-password-主mysql的密码-1"><a href="#master-password-主mysql的密码-1" class="headerlink" title="master_password 主mysql的密码"></a>master_password 主mysql的密码</h1><p>#（最后两项修改成刚刚从主mysql查到的，主mysql每次刷新权限或者重启时，这两个值都会改变，所以每次都需要查看是否相同）<br>CHANGE MASTER TO<br>master_host = ‘10.211.55.26’,<br>master_port = 33060,<br>master_user = ‘db_sync’,<br>master_password = ‘db_sync’,<br>master_log_file = ‘mysql-bin.000001’,<br>master_log_pos = 823;</p><p>#启动同步<br>START SLAVE;</p><p>#查看Slave_IO_Runing和Slave_SQL_Runing字段值都为Yes，表示同步配置成功。<br>show slave status \G;</p><p>老师这里只演示读写分离，并没有mysql的主从复制，我写的是主从复制，读写分离。<br>#主mysql<br>create database master_slave_order;</p><p>1<br>2<br>Sharding-Proxy 配置<br>修改 config-master_slave.yaml 文件（此文件为读写分离的配置）<br>schemaName: master_slave_db</p><p>dataSources:<br> master_ds:<br>   url: jdbc:mysql://10.211.55.26:33060/master_slave_order?serverTimezone=UTC&amp;useSSL=false&amp;allowPublicKeyRetrieval=true<br>   username: root<br>   password: 123456<br>   connectionTimeoutMilliseconds: 30000<br>   idleTimeoutMilliseconds: 60000<br>   maxLifetimeMilliseconds: 1800000<br>   maxPoolSize: 50<br> slave_ds_0:<br>   url: jdbc:mysql://10.211.55.26:33061/master_slave_order?serverTimezone=UTC&amp;useSSL=false&amp;allowPublicKeyRetrieval=true<br>   username: root<br>   password: 123456<br>   connectionTimeoutMilliseconds: 30000<br>   idleTimeoutMilliseconds: 60000<br>   maxLifetimeMilliseconds: 1800000<br>   maxPoolSize: 50</p><p>masterSlaveRule:<br> name: ms_ds<br> masterDataSourceName: master_ds<br> slaveDataSourceNames:</p><ul><li>slave_ds_0<h1 id="slave-ds-1"><a href="#slave-ds-1" class="headerlink" title="- slave_ds_1"></a>- slave_ds_1</h1></li></ul><p>测试<br>启动Sharding-Proxy 服务 ./start.sh</p><p>出现这个错误：</p><p>在url上加上&amp;allowPublicKeyRetrieval=true即可。<br>连接sharding-proxy</p><p>创建数据表<br>use master_slave_db;</p><p>create table if not exists master_slave_order.t_order(<code>order_id</code> bigint primary key,<code>user_id</code> int not null,<code>status</code> varchar(50));</p><p>insert into t_order(<code>order_id</code>,<code>user_id</code>,<code>status</code>)values(11,1,’test’);</p><p>只修改从mysql中的数据</p><p>查询数据<br>select * from t_order;</p><p>说明，写入的是主mysql，然后主从复制，从mysql也有了数据，读取的是从mysql。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;数据库链接池过多，或者导致数据库挂了，如果主备机切换，需要更改配置&lt;br&gt;java应用与数据库紧耦合&lt;/p&gt;
&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
         
      
    
    </summary>
    
    
    
      <category term="中间件" scheme="http://kkget.github.io/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>数据库中间件系列[Mycat+Sharding-Sphere]</title>
    <link href="http://kkget.github.io/2020/09/30/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%B3%BB%E5%88%97[Mycat+Sharding-Sphere]/"/>
    <id>http://kkget.github.io/2020/09/30/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%B3%BB%E5%88%97[Mycat+Sharding-Sphere]/</id>
    <published>2020-09-30T02:38:32.000Z</published>
    <updated>2020-10-12T02:21:37.069Z</updated>
    
    <content type="html"><![CDATA[<p>数据库链接池过多，或者导致数据库挂了，如果主备机切换，需要更改配置<br>java应用与数据库紧耦合</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/dbcenter/1.png" alt="图1" title>                </div>                <div class="image-caption">图1</div>            </figure><p>官网:<a href="http://www.mycat.io/" target="_blank" rel="noopener">http://www.mycat.io/</a></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/dbcenter/2.png" alt="图1" title>                </div>                <div class="image-caption">图1</div>            </figure><p>主从复制，主备切换，双主双从</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/dbcenter/3.png" alt="图1" title>                </div>                <div class="image-caption">图1</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/dbcenter/4.png" alt="图1" title>                </div>                <div class="image-caption">图1</div>            </figure><p>Mycat原理:拦截<br>安装<br>Springboot整合</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.0.0&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">            &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p>application.yml配置文件：<br>#设置应用端口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">8080</span></span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    # Mycat连接</span><br><span class="line">    url: jdbc:mysql:<span class="comment">//localhost:8066/springboot?useUnicode=true&amp;characterEncoding=utf-8&amp;autoReconnect=true&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=false&amp;serverTimezone=GMT%2B8</span></span><br><span class="line">    username: root</span><br><span class="line">    password: <span class="number">123456</span></span><br><span class="line"></span><br><span class="line"># MyBatis</span><br><span class="line">mybatis:</span><br><span class="line">    type-aliases-<span class="keyword">package</span>: com.example.springbootmybatismycat.domain</span><br><span class="line">    mapper-locations: classpath:/mybatis<span class="comment">/*.xml</span></span><br><span class="line"><span class="comment">    #sql打印配置</span></span><br><span class="line"><span class="comment">    configuration:</span></span><br><span class="line"><span class="comment">        log-impl: org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br></pre></td></tr></table></figure><p>一、基本概念<br>Sharding-Sphere简介<br>Sharding-Sphere官网：<a href="http://shardingsphere.apache.org/index_zh.html" target="_blank" rel="noopener">http://shardingsphere.apache.org/index_zh.html</a></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/dbcenter/5.png" alt="图1" title>                </div>                <div class="image-caption">图1</div>            </figure><p>一套开源的分布式数据库中间件解决方案。<br>有三个产品，Sharding-JDBC、Sharding-Proxy 和 Sharding-Sidecar。<br>ShardingSphere 定位为关系型数据库中间件，合理地在分布式环境下使用关系型数据库操作。<br>分库分表<br>数据据库数据量是不可控的，随着时间和业务发展，造成表里面数据越来越多，如果再去对数据库表curd操作时，就会有性能问题。<br>解决办法：<br>方案1：从硬件上<br>方案2：分库分表<br>为了解决由于数据量过大而造成数据库性能降低问题。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/dbcenter/6.png" alt="图1" title>                </div>                <div class="image-caption">图1</div>            </figure><p>分库分表的方式<br>分库分表有两种方式：垂直切分和水平切分。<br>垂直切分：垂直分表和垂直分库<br>水平切分：水平分表和水平分库<br>垂直拆字段，水平拆记录。<br>垂直切分的库和表结构是不同的，而水平切分的库和表是相同的。<br>垂直分表<br>操作数据库中某张表，把这张表中一部分字段数据存到一张新表里面，再把这张表另部分字段数据存到另外一张表里面。<br>垂直拆分成的两张表，每张表的数据量和原先的表的数据量相同。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/dbcenter/7.png" alt="图1" title>                </div>                <div class="image-caption">图1</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/dbcenter/8.png" alt="图1" title>                </div>                <div class="image-caption">图1</div>            </figure><p>垂直分库<br>把单一数据库按照业务进行划分，专库专表。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/dbcenter/9.png" alt="图1" title>                </div>                <div class="image-caption">图1</div>            </figure><p>水平分库</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/dbcenter/10.png" alt="图1" title>                </div>                <div class="image-caption">图1</div>            </figure><p>水平分表</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/dbcenter/12.png" alt="图1" title>                </div>                <div class="image-caption">图1</div>            </figure><p>分库分表的应用和问题<br>应用<br>在数据库设计时候就要考虑垂直分库和垂直分表。<br>随着数据库数据量增加，不要马上考虑做水平切分。首先考虑缓存处理，读写分离，使用索引等等方式。如果这些方式不能根本解决问题了，再考虑做水平分库和水平分表。<br>分库分表问题<br>跨节点连接查询问题(分页、排序)。<br>多数据源管理问题。<br>二、Sharding-JDBC 分库分表操作<br>ShardingSphere-JDBC 简介<br>Sharding-JDBC是轻量级的Java框架，是增强的JDBC驱动。<br>Sharding-JDBC的功能：主要做数据分片和读写分离，不是做分库分表，分库分表由我们自己做。<br>主要的目的：简化分库分表后数据的相关操作。<br>Sharding-JDBC 实现水平分表<br>搭建环境<br>技术：SpringBoot2.2.1 + MybatisPlus + Sharding-JDBC + Druid连接池<br>创建项目</p><p>修改SpringBoot的版本</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">pom.xml引入相关的依赖</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.1.20&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;8.0.18&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.shardingsphere&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;sharding-jdbc-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;4.0.0-RC1&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.baomidou&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;3.0.5&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>按照水平分表的方式创建数据库、数据表<br>创建数据库 course_db。<br>在数据库中创建两张表 course_1 和 course_2。<br>数据存放约定规则：添加的数据id为偶数放 course_1 表中，id为奇数放 course_2 表中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">create database course_db;</span><br><span class="line"></span><br><span class="line">use course_db;</span><br><span class="line"></span><br><span class="line"><span class="function">create table <span class="title">course_1</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">`cid` bigint(<span class="number">20</span>)</span> primary key,</span></span><br><span class="line"><span class="function">`cname` <span class="title">varchar</span><span class="params">(<span class="number">50</span>)</span> not <span class="keyword">null</span>,</span></span><br><span class="line"><span class="function">`user_id` <span class="title">bigint</span><span class="params">(<span class="number">20</span>)</span> not <span class="keyword">null</span>,</span></span><br><span class="line"><span class="function">`cstatus` <span class="title">varchar</span><span class="params">(<span class="number">10</span>)</span> not <span class="keyword">null</span></span></span><br><span class="line"><span class="function">)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">create table <span class="title">course_2</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">`cid` bigint(<span class="number">20</span>)</span> primary key,</span></span><br><span class="line"><span class="function">`cname` <span class="title">varchar</span><span class="params">(<span class="number">50</span>)</span> not <span class="keyword">null</span>,</span></span><br><span class="line"><span class="function">`user_id` <span class="title">bigint</span><span class="params">(<span class="number">20</span>)</span> not <span class="keyword">null</span>,</span></span><br><span class="line"><span class="function">`cstatus` <span class="title">varchar</span><span class="params">(<span class="number">10</span>)</span> not <span class="keyword">null</span></span></span><br><span class="line"><span class="function">)</span>;</span><br></pre></td></tr></table></figure><p>编写代码实现对分库分表数据的操作<br>在shardingjdbcdemo包下创建 entity.Course 实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Course</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long cid;</span><br><span class="line">    <span class="keyword">private</span> String cname;</span><br><span class="line">    <span class="keyword">private</span> Long userId;</span><br><span class="line">    <span class="keyword">private</span> String cstatus;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">创建mapper.CourseMapper 接口</span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CourseMapper</span> <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">Course</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>在启动类上加上@MapperScan(“com.angenin.shardingjdbcdemo.mapper”)注解<br>配置水平分表策略<br>官网数据分片配置：<a href="https://shardingsphere.apache.org/document/current/cn/user-manual/shardingsphere-jdbc/usage/sharding/spring-boot-starter/" target="_blank" rel="noopener">https://shardingsphere.apache.org/document/current/cn/user-manual/shardingsphere-jdbc/usage/sharding/spring-boot-starter/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">在 application.properties 配置文件中配置：（下面数据库密码记得写）</span><br><span class="line"># shardingjdbc 水平分表策略</span><br><span class="line"># 配置数据源，给数据源起别名</span><br><span class="line">spring.shardingsphere.datasource.names=m1</span><br><span class="line"></span><br><span class="line"># 一个实体类对应两张表，覆盖</span><br><span class="line">spring.main.allow-bean-definition-overriding=<span class="keyword">true</span></span><br><span class="line"></span><br><span class="line"># 配置数据源的具体内容，包含连接池，驱动，地址，用户名，密码</span><br><span class="line">spring.shardingsphere.datasource.m1.type=com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">spring.shardingsphere.datasource.m1.driver-<span class="class"><span class="keyword">class</span>-<span class="title">name</span></span>=com.mysql.cj.jdbc.Driver</span><br><span class="line">spring.shardingsphere.datasource.m1.url=jdbc:mysql:<span class="comment">//localhost:3306/course_db?serverTimezone=GMT%2B8</span></span><br><span class="line">spring.shardingsphere.datasource.m1.username=root</span><br><span class="line">spring.shardingsphere.datasource.m1.password=</span><br><span class="line"></span><br><span class="line"># 指定course表分布的情况，配置表在哪个数据库里，表的名称都是什么 m1.course_1,m1.course_2</span><br><span class="line">spring.shardingsphere.sharding.tables.course.actual-data-nodes=m1.course_$-&gt;&#123;<span class="number">1</span>..<span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line"># 指定 course 表里面主键 cid 的生成策略 SNOWFLAKE</span><br><span class="line">spring.shardingsphere.sharding.tables.course.key-generator.column=cid</span><br><span class="line">spring.shardingsphere.sharding.tables.course.key-generator.type=SNOWFLAKE</span><br><span class="line"></span><br><span class="line"># 配置分表策略    约定 cid 值偶数添加到 course_1 表，如果 cid 是奇数添加到 course_2 表</span><br><span class="line">spring.shardingsphere.sharding.tables.course.table-strategy.inline.shardingcolumn=cid</span><br><span class="line">spring.shardingsphere.sharding.tables.course.table-strategy.inline.algorithmexpression=course_$-&gt;&#123;cid % <span class="number">2</span> + <span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line"># 打开 sql 输出日志</span><br><span class="line">spring.shardingsphere.props.sql.show=<span class="keyword">true</span></span><br></pre></td></tr></table></figure><p>编写测试代码<br>在test包中的测试类中进行测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">SpringBootTest</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">ShardingjdbcdemoApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CourseMapper courseMapper;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//添加课程</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCourse</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Course course = <span class="keyword">new</span> Course();</span><br><span class="line">        <span class="comment">//cid由我们设置的策略，雪花算法进行生成（至少70年内生成的id不会重复）</span></span><br><span class="line">        course.setCname(<span class="string">"java"</span>);</span><br><span class="line">        course.setUserId(<span class="number">100L</span>);</span><br><span class="line">        course.setCstatus(<span class="string">"Normal"</span>);</span><br><span class="line">    </span><br><span class="line">        courseMapper.insert(course);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//查询课程</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findCourse</span><span class="params">()</span></span>&#123;</span><br><span class="line">        QueryWrapper&lt;Course&gt; wrapper = <span class="keyword">new</span> QueryWrapper&lt;&gt;();</span><br><span class="line">        wrapper.eq(<span class="string">"cid"</span>, <span class="number">509755853058867201L</span>);</span><br><span class="line">        courseMapper.selectOne(wrapper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>addCourse方法执行结果：</p><p>findCourse方法执行结果：</p><p>Sharding-JDBC 实现水平分库<br>需求分析</p><p>创建数据库，数据表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">create database edu_db_1;</span><br><span class="line">create database edu_db_2;</span><br><span class="line"></span><br><span class="line">use edu_db_1;</span><br><span class="line"></span><br><span class="line"><span class="function">create table <span class="title">course_1</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">`cid` bigint(<span class="number">20</span>)</span> primary key,</span></span><br><span class="line"><span class="function">`cname` <span class="title">varchar</span><span class="params">(<span class="number">50</span>)</span> not <span class="keyword">null</span>,</span></span><br><span class="line"><span class="function">`user_id` <span class="title">bigint</span><span class="params">(<span class="number">20</span>)</span> not <span class="keyword">null</span>,</span></span><br><span class="line"><span class="function">`cstatus` <span class="title">varchar</span><span class="params">(<span class="number">10</span>)</span> not <span class="keyword">null</span></span></span><br><span class="line"><span class="function">)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">create table <span class="title">course_2</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">`cid` bigint(<span class="number">20</span>)</span> primary key,</span></span><br><span class="line"><span class="function">`cname` <span class="title">varchar</span><span class="params">(<span class="number">50</span>)</span> not <span class="keyword">null</span>,</span></span><br><span class="line"><span class="function">`user_id` <span class="title">bigint</span><span class="params">(<span class="number">20</span>)</span> not <span class="keyword">null</span>,</span></span><br><span class="line"><span class="function">`cstatus` <span class="title">varchar</span><span class="params">(<span class="number">10</span>)</span> not <span class="keyword">null</span></span></span><br><span class="line"><span class="function">)</span>;</span><br><span class="line"></span><br><span class="line">use edu_db_2;</span><br><span class="line"></span><br><span class="line"><span class="function">create table <span class="title">course_1</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">`cid` bigint(<span class="number">20</span>)</span> primary key,</span></span><br><span class="line"><span class="function">`cname` <span class="title">varchar</span><span class="params">(<span class="number">50</span>)</span> not <span class="keyword">null</span>,</span></span><br><span class="line"><span class="function">`user_id` <span class="title">bigint</span><span class="params">(<span class="number">20</span>)</span> not <span class="keyword">null</span>,</span></span><br><span class="line"><span class="function">`cstatus` <span class="title">varchar</span><span class="params">(<span class="number">10</span>)</span> not <span class="keyword">null</span></span></span><br><span class="line"><span class="function">)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">create table <span class="title">course_2</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">`cid` bigint(<span class="number">20</span>)</span> primary key,</span></span><br><span class="line"><span class="function">`cname` <span class="title">varchar</span><span class="params">(<span class="number">50</span>)</span> not <span class="keyword">null</span>,</span></span><br><span class="line"><span class="function">`user_id` <span class="title">bigint</span><span class="params">(<span class="number">20</span>)</span> not <span class="keyword">null</span>,</span></span><br><span class="line"><span class="function">`cstatus` <span class="title">varchar</span><span class="params">(<span class="number">10</span>)</span> not <span class="keyword">null</span></span></span><br><span class="line"><span class="function">)</span>;</span><br></pre></td></tr></table></figure><p>配置水平分库策略<br>下面数据库的密码填自己的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"># shardingjdbc 水平分库分表策略</span><br><span class="line"># 配置数据源，给数据源起别名</span><br><span class="line"># 水平分库需要配置多个数据库</span><br><span class="line">spring.shardingsphere.datasource.names=m1,m2</span><br><span class="line"></span><br><span class="line"># 一个实体类对应两张表，覆盖</span><br><span class="line">spring.main.allow-bean-definition-overriding=<span class="keyword">true</span></span><br><span class="line"></span><br><span class="line"># 配置第一个数据源的具体内容，包含连接池，驱动，地址，用户名，密码</span><br><span class="line">spring.shardingsphere.datasource.m1.type=com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">spring.shardingsphere.datasource.m1.driver-<span class="class"><span class="keyword">class</span>-<span class="title">name</span></span>=com.mysql.cj.jdbc.Driver</span><br><span class="line">spring.shardingsphere.datasource.m1.url=jdbc:mysql:<span class="comment">//localhost:3306/edu_db_1?serverTimezone=GMT%2B8</span></span><br><span class="line">spring.shardingsphere.datasource.m1.username=root</span><br><span class="line">spring.shardingsphere.datasource.m1.password=</span><br><span class="line"></span><br><span class="line"># 配置第二个数据源的具体内容，包含连接池，驱动，地址，用户名，密码</span><br><span class="line">spring.shardingsphere.datasource.m2.type=com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">spring.shardingsphere.datasource.m2.driver-<span class="class"><span class="keyword">class</span>-<span class="title">name</span></span>=com.mysql.cj.jdbc.Driver</span><br><span class="line">spring.shardingsphere.datasource.m2.url=jdbc:mysql:<span class="comment">//localhost:3306/edu_db_2?serverTimezone=GMT%2B8</span></span><br><span class="line">spring.shardingsphere.datasource.m2.username=root</span><br><span class="line">spring.shardingsphere.datasource.m2.password=</span><br><span class="line"></span><br><span class="line"># 指定数据库分布的情况和数据表分布的情况</span><br><span class="line"># m1 m2   course_1 course_2</span><br><span class="line">spring.shardingsphere.sharding.tables.course.actual-data-nodes=m$-&gt;&#123;<span class="number">1</span>..<span class="number">2</span>&#125;.course_$-&gt;&#123;<span class="number">1</span>..<span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line"># 指定 course 表里面主键 cid 的生成策略 SNOWFLAKE</span><br><span class="line">spring.shardingsphere.sharding.tables.course.key-generator.column=cid</span><br><span class="line">spring.shardingsphere.sharding.tables.course.key-generator.type=SNOWFLAKE</span><br><span class="line"></span><br><span class="line"># 指定分库策略    约定 user_id 值偶数添加到 m1 库，如果 user_id 是奇数添加到 m2 库</span><br><span class="line"># 默认写法（所有的表的user_id）</span><br><span class="line">#spring.shardingsphere.sharding.default-database-strategy.inline.sharding-column=user_id</span><br><span class="line">#spring.shardingsphere.sharding.default-database-strategy.inline.algorithm-expression=m$-&gt;&#123;user_id % 2 + 1&#125;</span><br><span class="line"># 指定只有course表的user_id</span><br><span class="line">spring.shardingsphere.sharding.tables.course.database-strategy.inline.sharding-column=user_id</span><br><span class="line">spring.shardingsphere.sharding.tables.course.database-strategy.inline.algorithm-expression=m$-&gt;&#123;user_id % <span class="number">2</span> + <span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line"># 指定分表策略    约定 cid 值偶数添加到 course_1 表，如果 cid 是奇数添加到 course_2 表</span><br><span class="line">spring.shardingsphere.sharding.tables.course.table-strategy.inline.sharding-column=cid</span><br><span class="line">spring.shardingsphere.sharding.tables.course.table-strategy.inline.algorithm-expression=course_$-&gt;&#123;cid % <span class="number">2</span> + <span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line"># 打开 sql 输出日志</span><br><span class="line">spring.shardingsphere.props.sql.show=<span class="keyword">true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">编写测试代码</span><br><span class="line"><span class="comment">//添加课程</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCourseDb</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Course course = <span class="keyword">new</span> Course();</span><br><span class="line">        <span class="comment">//cid由我们设置的策略，雪花算法进行生成（至少70年内生成的id不会重复）</span></span><br><span class="line">        course.setCname(<span class="string">"javademo"</span>);</span><br><span class="line">        <span class="comment">//分库根据user_id</span></span><br><span class="line">        course.setUserId(<span class="number">100L</span>);</span><br><span class="line">        course.setCstatus(<span class="string">"Normal"</span>);</span><br><span class="line">        courseMapper.insert(course);</span><br><span class="line"></span><br><span class="line">        course.setCname(<span class="string">"javademo2"</span>);</span><br><span class="line">        course.setUserId(<span class="number">111L</span>);</span><br><span class="line">        courseMapper.insert(course);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//查询课程</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findCourseDb</span><span class="params">()</span></span>&#123;</span><br><span class="line">        QueryWrapper&lt;Course&gt; wrapper = <span class="keyword">new</span> QueryWrapper&lt;&gt;();</span><br><span class="line">        <span class="comment">//设置user_id的值</span></span><br><span class="line">        wrapper.eq(<span class="string">"user_id"</span>, <span class="number">100L</span>);</span><br><span class="line">        <span class="comment">//设置cid的值</span></span><br><span class="line">        wrapper.eq(<span class="string">"cid"</span>, <span class="number">509771111076986881L</span>);</span><br><span class="line">        Course course = courseMapper.selectOne(wrapper);</span><br><span class="line">        System.out.println(course);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>addCourseDb方法执行结果：</p><p>findCourseDb方法执行结果：</p><p>Sharding-JDBC 实现垂直分库<br>需求分析</p><p>需要查询用户信息的时候，不需要查到课程信息。<br>创建用户数据库、数据表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">create database user_db;</span><br><span class="line"></span><br><span class="line">use user_db;</span><br><span class="line"></span><br><span class="line"><span class="function">create table <span class="title">t_user</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">`user_id` bigint(<span class="number">20</span>)</span> primary key,</span></span><br><span class="line"><span class="function">`username` <span class="title">varchar</span><span class="params">(<span class="number">100</span>)</span> not <span class="keyword">null</span>,</span></span><br><span class="line"><span class="function">`ustatus` <span class="title">varchar</span><span class="params">(<span class="number">50</span>)</span> not <span class="keyword">null</span></span></span><br><span class="line"><span class="function">)</span>;</span><br><span class="line"></span><br><span class="line">编写User代码</span><br><span class="line">创建user实体类和对应的mapper</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@TableName</span>(<span class="string">"t_user"</span>)    <span class="comment">//指定对应的表名</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long userId;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String ustatus;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">User</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>配置垂直分库策略<br>记得写数据库密码。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"># shardingjdbc 垂直分库策略</span><br><span class="line"># 配置数据源，给数据源起别名</span><br><span class="line"># 水平分库需要配置多个数据库</span><br><span class="line"># m0为用户数据库</span><br><span class="line">spring.shardingsphere.datasource.names=m1,m2,m0</span><br><span class="line"></span><br><span class="line"># 一个实体类对应两张表，覆盖</span><br><span class="line">spring.main.allow-bean-definition-overriding=<span class="keyword">true</span></span><br><span class="line"></span><br><span class="line"># 配置第一个数据源的具体内容，包含连接池，驱动，地址，用户名，密码</span><br><span class="line">spring.shardingsphere.datasource.m1.type=com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">spring.shardingsphere.datasource.m1.driver-<span class="class"><span class="keyword">class</span>-<span class="title">name</span></span>=com.mysql.cj.jdbc.Driver</span><br><span class="line">spring.shardingsphere.datasource.m1.url=jdbc:mysql:<span class="comment">//localhost:3306/edu_db_1?serverTimezone=GMT%2B8</span></span><br><span class="line">spring.shardingsphere.datasource.m1.username=root</span><br><span class="line">spring.shardingsphere.datasource.m1.password=</span><br><span class="line"></span><br><span class="line"># 配置第二个数据源的具体内容，包含连接池，驱动，地址，用户名，密码</span><br><span class="line">spring.shardingsphere.datasource.m2.type=com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">spring.shardingsphere.datasource.m2.driver-<span class="class"><span class="keyword">class</span>-<span class="title">name</span></span>=com.mysql.cj.jdbc.Driver</span><br><span class="line">spring.shardingsphere.datasource.m2.url=jdbc:mysql:<span class="comment">//localhost:3306/edu_db_2?serverTimezone=GMT%2B8</span></span><br><span class="line">spring.shardingsphere.datasource.m2.username=root</span><br><span class="line">spring.shardingsphere.datasource.m2.password=</span><br><span class="line"></span><br><span class="line"># 配置user数据源的具体内容，包含连接池，驱动，地址，用户名，密码</span><br><span class="line">spring.shardingsphere.datasource.m0.type=com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">spring.shardingsphere.datasource.m0.driver-<span class="class"><span class="keyword">class</span>-<span class="title">name</span></span>=com.mysql.cj.jdbc.Driver</span><br><span class="line">spring.shardingsphere.datasource.m0.url=jdbc:mysql:<span class="comment">//localhost:3306/user_db?serverTimezone=GMT%2B8</span></span><br><span class="line">spring.shardingsphere.datasource.m0.username=root</span><br><span class="line">spring.shardingsphere.datasource.m0.password=</span><br><span class="line"># 配置user_db数据库里面t_user  专库专表</span><br><span class="line">spring.shardingsphere.sharding.tables.t_user.actual-data-nodes=m0.t_user</span><br><span class="line"># 配置主键的生成策略</span><br><span class="line">spring.shardingsphere.sharding.tables.t_user.key-generator.column=user_id</span><br><span class="line">spring.shardingsphere.sharding.tables.t_user.key-generator.type=SNOWFLAKE</span><br><span class="line"># 指定分表策略</span><br><span class="line">spring.shardingsphere.sharding.tables.t_user.table-strategy.inline.sharding-column=user_id</span><br><span class="line">spring.shardingsphere.sharding.tables.t_user.table-strategy.inline.algorithm-expression=t_user</span><br><span class="line"></span><br><span class="line"># ... 其他配置同上</span><br></pre></td></tr></table></figure><p>编写测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加用户</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUserDb</span><span class="params">()</span></span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setUsername(<span class="string">"张三"</span>);</span><br><span class="line">    user.setUstatus(<span class="string">"a"</span>);</span><br><span class="line">    userMapper.insert(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">//查询用户</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findUserDb</span><span class="params">()</span></span>&#123;</span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> QueryWrapper&lt;&gt;();</span><br><span class="line">    wrapper.eq(<span class="string">"user_id"</span>, <span class="number">509793334663839745L</span>);</span><br><span class="line">    User user = userMapper.selectOne(wrapper);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>addUserDb方法执行结果：</p><p>findUserDb方法执行结果：</p><p>Sharding-JDBC 公共表<br>公共表概念<br>存储固定数据的表，表数据很少发生变化，查询时经常要进行关联。<br>在每个数据库中都创建出相同结构公共表。<br>操作公共表时，同时操作添加了公共表的数据库中的公共表，添加记录时，同时添加，删除时，同时删除。<br>在多个数据库中创建相同结构的公共表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">use user_db;</span><br><span class="line">#use edu_db_1;</span><br><span class="line">#use edu_db_2;</span><br><span class="line"></span><br><span class="line"><span class="function">create table <span class="title">t_udict</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">`dictid` bigint(<span class="number">20</span>)</span> primary key,</span></span><br><span class="line"><span class="function">`ustatus` <span class="title">varchar</span><span class="params">(<span class="number">100</span>)</span> not <span class="keyword">null</span>,</span></span><br><span class="line"><span class="function">`uvalue` <span class="title">varchar</span><span class="params">(<span class="number">100</span>)</span> not <span class="keyword">null</span></span></span><br><span class="line"><span class="function">)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">公共表配置</span><br><span class="line"># 其他配置同上</span><br><span class="line"></span><br><span class="line"># ...</span><br><span class="line"></span><br><span class="line"># 公共表配置</span><br><span class="line">spring.shardingsphere.sharding.broadcast-tables=t_udict</span><br><span class="line"># 配置主键的生成策略</span><br><span class="line">spring.shardingsphere.sharding.tables.t_udict.key-generator.column=dictid</span><br><span class="line">spring.shardingsphere.sharding.tables.t_udict.key-generator.type=SNOWFLAKE</span><br><span class="line"></span><br><span class="line"># ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">编写公共表的实体类及mapper</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@TableName</span>(value = <span class="string">"t_udict"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Udict</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long dictid;</span><br><span class="line">    <span class="keyword">private</span> String ustatus;</span><br><span class="line">    <span class="keyword">private</span> String uvalue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UdictMapper</span> <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">Udict</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">编写测试代码</span><br><span class="line">    <span class="comment">//添加</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addDict</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Udict udict = <span class="keyword">new</span> Udict();</span><br><span class="line">        udict.setUstatus(<span class="string">"a"</span>);</span><br><span class="line">        udict.setUvalue(<span class="string">"已启用"</span>);</span><br><span class="line">        udictMapper.insert(udict);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteDict</span><span class="params">()</span></span>&#123;</span><br><span class="line">        QueryWrapper&lt;Udict&gt; wrapper = <span class="keyword">new</span> QueryWrapper&lt;&gt;();</span><br><span class="line">        wrapper.eq(<span class="string">"dictid"</span>, <span class="number">509811689974136833L</span>);</span><br><span class="line">        udictMapper.delete(wrapper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">addDict方法执行结果：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">deleteDict方法执行结果：</span><br></pre></td></tr></table></figure><p>Sharding-JDBC 实现读写分离<br>读写分离概念</p><p>读写原理</p><p>Sharding-JDBC 读写分离</p><p>Sharding-JDBC通过sql语句语义分析，当sql语句有insert、update、delete时，Sharding-JDBC就把这次操作在主数据库上执行；当sql语句有select时，就会把这次操作在从数据库上执行，从而实现读写分离过程。但Sharding-JDBC并不会做数据同步，数据同步是配置MySQL后由MySQL自己完成的。<br>MySQL 一主一从读写分离配置<br>我采用的是docker来实现的，单独写在这篇文章里：<a href="https://blog.csdn.net/qq_36903261/article/details/108457759" target="_blank" rel="noopener">https://blog.csdn.net/qq_36903261/article/details/108457759</a><br>使用docker后，需要在主服务器上新建原先的数据库数据表。<br>因为记录的文件名以及位点每次重启或刷新都会改变，所以以下命令放在这里，方便查看。<br>主mysql：<br>#确认位点 记录下文件名以及位点（重启或者刷新都会改变）<br>show master status;</p><p>1<br>2<br>从mysql：<br>#先停止同步<br>STOP SLAVE;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">#修改从库指向到主库，使用上一步记录的文件名以及位点</span><br><span class="line"># master_host docker容器linux的ip地址</span><br><span class="line"># master_port 主mysql暴露的端口</span><br><span class="line"># master_user 主mysql的用户名</span><br><span class="line"># master_password 主mysql的密码</span><br><span class="line">#（最后两项修改成刚刚从主mysql查到的，主mysql每次刷新权限或者重启时，这两个值都会改变，所以每次都需要查看是否相同）</span><br><span class="line">CHANGE MASTER TO</span><br><span class="line">master_host = <span class="string">'10.211.55.26'</span>,</span><br><span class="line">master_port = <span class="number">33060</span>,</span><br><span class="line">master_user = <span class="string">'db_sync'</span>,</span><br><span class="line">master_password = <span class="string">'db_sync'</span>,</span><br><span class="line">master_log_file = <span class="string">'mysql-bin.000001'</span>,</span><br><span class="line">master_log_pos = <span class="number">823</span>;</span><br><span class="line"></span><br><span class="line">#启动同步</span><br><span class="line">START SLAVE;</span><br><span class="line"></span><br><span class="line">#查看Slave_IO_Runing和Slave_SQL_Runing字段值都为Yes，表示同步配置成功。</span><br><span class="line">show slave status \G;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Sharding-JDBC 操作</span><br><span class="line">配置读写分离策略</span><br><span class="line">也使用docker的，复制的时候记得改一下ip地址</span><br><span class="line"># 配置数据源，给数据源起别名</span><br><span class="line"># m0为用户数据库</span><br><span class="line">spring.shardingsphere.datasource.names=m0,s0</span><br><span class="line"></span><br><span class="line"># 一个实体类对应两张表，覆盖</span><br><span class="line">spring.main.allow-bean-definition-overriding=<span class="keyword">true</span></span><br><span class="line"></span><br><span class="line">#user_db 主服务器</span><br><span class="line">spring.shardingsphere.datasource.m0.type=com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">spring.shardingsphere.datasource.m0.driver-<span class="class"><span class="keyword">class</span>-<span class="title">name</span></span>=com.mysql.cj.jdbc.Driver</span><br><span class="line">spring.shardingsphere.datasource.m0.url=jdbc:mysql:<span class="comment">//10.211.55.26:33060/user_db?serverTimezone=GMT%2B8</span></span><br><span class="line">spring.shardingsphere.datasource.m0.username=root</span><br><span class="line">spring.shardingsphere.datasource.m0.password=<span class="number">123456</span></span><br><span class="line"></span><br><span class="line">#user_db 从服务器</span><br><span class="line">spring.shardingsphere.datasource.s0.type=com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">spring.shardingsphere.datasource.s0.driver-<span class="class"><span class="keyword">class</span>-<span class="title">name</span></span>=com.mysql.cj.jdbc.Driver</span><br><span class="line">spring.shardingsphere.datasource.s0.url=jdbc:mysql:<span class="comment">//10.211.55.26:33061/user_db?serverTimezone=GMT%2B8</span></span><br><span class="line">spring.shardingsphere.datasource.s0.username=root</span><br><span class="line">spring.shardingsphere.datasource.s0.password=<span class="number">123456</span></span><br><span class="line"></span><br><span class="line"># 主库从库逻辑数据源定义 ds0 为 user_db</span><br><span class="line">spring.shardingsphere.sharding.master-slave-rules.ds0.master-data-source-name=m0</span><br><span class="line">spring.shardingsphere.sharding.master-slave-rules.ds0.slave-data-source-names=s0</span><br><span class="line"></span><br><span class="line"># 配置user_db数据库里面t_user  专库专表</span><br><span class="line">#spring.shardingsphere.sharding.tables.t_user.actual-data-nodes=m0.t_user</span><br><span class="line"># t_user 分表策略，固定分配至 ds0 的 t_user 真实表</span><br><span class="line">spring.shardingsphere.sharding.tables.t_user.actual-data-nodes=ds0.t_user</span><br><span class="line"></span><br><span class="line"># 配置主键的生成策略</span><br><span class="line">spring.shardingsphere.sharding.tables.t_user.key-generator.column=user_id</span><br><span class="line">spring.shardingsphere.sharding.tables.t_user.key-generator.type=SNOWFLAKE</span><br><span class="line"># 指定分表策略</span><br><span class="line">spring.shardingsphere.sharding.tables.t_user.table-strategy.inline.sharding-column=user_id</span><br><span class="line">spring.shardingsphere.sharding.tables.t_user.table-strategy.inline.algorithm-expression=t_user</span><br><span class="line"></span><br><span class="line"># 打开 sql 输出日志</span><br><span class="line">spring.shardingsphere.props.sql.show=<span class="keyword">true</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">测试代码使用垂直分库时编写的addUserDb和findUserDb方法。</span><br><span class="line">addUserDb方法执行结果：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">findUserDb方法执行结果：</span><br></pre></td></tr></table></figure><p>三、Sharding-Proxy 分库分表操作<br>ShardingSphere-Proxy 简介</p><p>ShardingSphere-Proxy定位为透明的数据库代理端。<br>Sharding-Proxy独立应用，使用安装服务，进行分库分表或者读写分离配置、启动。<br>下载安装 Sharding-Proxy<br><a href="https://shardingsphere.apache.org/document/current/cn/downloads/" target="_blank" rel="noopener">https://shardingsphere.apache.org/document/current/cn/downloads/</a></p><p>下载解压后，需要把lib目录下后缀不全的jar包名补全。</p><p>配置 Sharding-Proxy（分库配置）<br>进入conf目录<br>修改 server.yaml 文件（此文件为Sharding-Proxy的配置），去除掉authentication和props的注释。</p><p>修改 config-sharding.yaml 配置文件（此文件为分库分表的配置）</p><p>文件里提示说，如果使用mysql，需要把mysql的驱动jar包放到lib目录下。（到maven下载的jar包里找即可）</p><p>在主mysql上新建一个edu_1数据库（create database edu_1;）<br>然后去掉文件中关于mysql的配置代码的注释，然后进行修改。（这里我连的是docker上的主mysql）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">schemaName: sharding_db</span><br><span class="line"></span><br><span class="line">dataSources:</span><br><span class="line"> ds_0:</span><br><span class="line">   url: jdbc:mysql:<span class="comment">//10.211.55.26:33060/edu_1?serverTimezone=UTC&amp;useSSL=false</span></span><br><span class="line">   username: root</span><br><span class="line">   password: <span class="number">123456</span></span><br><span class="line">   connectionTimeoutMilliseconds: <span class="number">30000</span></span><br><span class="line">   idleTimeoutMilliseconds: <span class="number">60000</span></span><br><span class="line">   maxLifetimeMilliseconds: <span class="number">1800000</span></span><br><span class="line">   maxPoolSize: <span class="number">50</span></span><br><span class="line"></span><br><span class="line">shardingRule:</span><br><span class="line"> tables:</span><br><span class="line">   t_order:</span><br><span class="line">     actualDataNodes: ds_$&#123;<span class="number">0</span>&#125;.t_order_$&#123;<span class="number">0</span>..<span class="number">1</span>&#125;</span><br><span class="line">     tableStrategy:</span><br><span class="line">       inline:</span><br><span class="line">         shardingColumn: order_id</span><br><span class="line">         algorithmExpression: t_order_$&#123;order_id % <span class="number">2</span>&#125;</span><br><span class="line">     keyGenerator:</span><br><span class="line">       type: SNOWFLAKE</span><br><span class="line">       column: order_id</span><br><span class="line"> bindingTables:</span><br><span class="line">   - t_order</span><br><span class="line"> defaultDatabaseStrategy:</span><br><span class="line">      inline:</span><br><span class="line">     shardingColumn: user_id</span><br><span class="line">     algorithmExpression: ds_$&#123;<span class="number">0</span>&#125;</span><br><span class="line"> defaultTableStrategy:</span><br><span class="line">      none:</span><br></pre></td></tr></table></figure><p>启动 Sharding-Proxy 服务<br>从终端进入到bin目录，然后./start.sh启动服务。（空格然后加上端口号，可以指定端口，默认3307）</p><p>如果打开logs目录里的stdout.log文件，显示下面这种，说明启动成功。</p><p>通过终端进行连接：<br>mysql -uroot -proot -P3307<br>如果出现下面这种错误，可以尝试连接命令加上-h127.0.0.1。</p><p>mysql -uroot -proot -h127.0.0.1 -P3307</p><p>新建一张表，并插入一条数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use sharding_db;</span><br><span class="line"></span><br><span class="line">create table <span class="keyword">if</span> not exists ds_0.t_order(`order_id` bigint primary key,`user_id` <span class="keyword">int</span> not <span class="keyword">null</span>,`status` varchar(<span class="number">50</span>));</span><br><span class="line"></span><br><span class="line"><span class="function">insert into <span class="title">t_order</span><span class="params">(`order_id`,`user_id`,`status`)</span><span class="title">values</span><span class="params">(<span class="number">11</span>,<span class="number">1</span>,<span class="string">'test'</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>按照order_id进行分配，因为id是奇数所以被分到了t_order_1表里。</p><p>配置 Sharding-Proxy（读写分离）<br>Sharding-Proxy与Sharding-JDBC一样，并不会进行主从复制，主从复制依然是有MySQL自己完成。<br>mysql主从复制配置<br>把上面mysql主从复制的配置复制下来，方便查看：<a href="https://blog.csdn.net/qq_36903261/article/details/108457759" target="_blank" rel="noopener">https://blog.csdn.net/qq_36903261/article/details/108457759</a><br>使用docker后，需要在主服务器上新建原先的数据库数据表。<br>因为记录的文件名以及位点每次重启或刷新都会改变，所以以下命令放在这里，方便查看。<br>主mysql：<br>#确认位点 记录下文件名以及位点（重启或者刷新都会改变）<br>show master status;</p><p>从mysql：<br>#先停止同步<br>STOP SLAVE;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">#修改从库指向到主库，使用上一步记录的文件名以及位点</span><br><span class="line"># master_host docker容器linux的ip地址</span><br><span class="line"># master_port 主mysql暴露的端口</span><br><span class="line"># master_user 主mysql的用户名</span><br><span class="line"># master_password 主mysql的密码</span><br><span class="line">#（最后两项修改成刚刚从主mysql查到的，主mysql每次刷新权限或者重启时，这两个值都会改变，所以每次都需要查看是否相同）</span><br><span class="line">CHANGE MASTER TO</span><br><span class="line">master_host = <span class="string">'10.211.55.26'</span>,</span><br><span class="line">master_port = <span class="number">33060</span>,</span><br><span class="line">master_user = <span class="string">'db_sync'</span>,</span><br><span class="line">master_password = <span class="string">'db_sync'</span>,</span><br><span class="line">master_log_file = <span class="string">'mysql-bin.000001'</span>,</span><br><span class="line">master_log_pos = <span class="number">823</span>;</span><br><span class="line"></span><br><span class="line">#启动同步</span><br><span class="line">START SLAVE;</span><br><span class="line"></span><br><span class="line">#查看Slave_IO_Runing和Slave_SQL_Runing字段值都为Yes，表示同步配置成功。</span><br><span class="line">show slave status \G;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">老师这里只演示读写分离，并没有mysql的主从复制，我写的是主从复制，读写分离。</span><br><span class="line">#主mysql</span><br><span class="line">create database master_slave_order;</span><br><span class="line"></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">Sharding-Proxy 配置</span><br><span class="line">修改 config-master_slave.yaml 文件（此文件为读写分离的配置）</span><br><span class="line">schemaName: master_slave_db</span><br><span class="line"></span><br><span class="line">dataSources:</span><br><span class="line"> master_ds:</span><br><span class="line">   url: jdbc:mysql:<span class="comment">//10.211.55.26:33060/master_slave_order?serverTimezone=UTC&amp;useSSL=false&amp;allowPublicKeyRetrieval=true</span></span><br><span class="line">   username: root</span><br><span class="line">   password: <span class="number">123456</span></span><br><span class="line">   connectionTimeoutMilliseconds: <span class="number">30000</span></span><br><span class="line">   idleTimeoutMilliseconds: <span class="number">60000</span></span><br><span class="line">   maxLifetimeMilliseconds: <span class="number">1800000</span></span><br><span class="line">   maxPoolSize: <span class="number">50</span></span><br><span class="line"> slave_ds_0:</span><br><span class="line">   url: jdbc:mysql:<span class="comment">//10.211.55.26:33061/master_slave_order?serverTimezone=UTC&amp;useSSL=false&amp;allowPublicKeyRetrieval=true</span></span><br><span class="line">   username: root</span><br><span class="line">   password: <span class="number">123456</span></span><br><span class="line">   connectionTimeoutMilliseconds: <span class="number">30000</span></span><br><span class="line">   idleTimeoutMilliseconds: <span class="number">60000</span></span><br><span class="line">   maxLifetimeMilliseconds: <span class="number">1800000</span></span><br><span class="line">   maxPoolSize: <span class="number">50</span></span><br><span class="line"></span><br><span class="line">masterSlaveRule:</span><br><span class="line"> name: ms_ds</span><br><span class="line"> masterDataSourceName: master_ds</span><br><span class="line"> slaveDataSourceNames:</span><br><span class="line">   - slave_ds_0</span><br><span class="line">#   - slave_ds_1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">测试</span><br><span class="line">启动Sharding-Proxy 服务 ./start.sh</span><br><span class="line"></span><br><span class="line">出现这个错误：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在url上加上&amp;allowPublicKeyRetrieval=<span class="keyword">true</span>即可。</span><br><span class="line">连接sharding-proxy</span><br><span class="line"></span><br><span class="line">创建数据表</span><br><span class="line">use master_slave_db;</span><br><span class="line"></span><br><span class="line">create table <span class="keyword">if</span> not exists master_slave_order.t_order(`order_id` bigint primary key,`user_id` <span class="keyword">int</span> not <span class="keyword">null</span>,`status` varchar(<span class="number">50</span>));</span><br><span class="line"></span><br><span class="line"><span class="function">insert into <span class="title">t_order</span><span class="params">(`order_id`,`user_id`,`status`)</span><span class="title">values</span><span class="params">(<span class="number">11</span>,<span class="number">1</span>,<span class="string">'test'</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">只修改从mysql中的数据</span><br><span class="line"></span><br><span class="line">查询数据</span><br><span class="line">select * from t_order;</span><br></pre></td></tr></table></figure><p>说明，写入的是主mysql，然后主从复制，从mysql也有了数据，读取的是从mysql。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;数据库链接池过多，或者导致数据库挂了，如果主备机切换，需要更改配置&lt;br&gt;java应用与数据库紧耦合&lt;/p&gt;
&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
         
      
    
    </summary>
    
    
    
      <category term="中间件" scheme="http://kkget.github.io/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>JVM调优相关</title>
    <link href="http://kkget.github.io/2020/09/24/JVM%E8%B0%83%E4%BC%98%E7%9B%B8%E5%85%B3/"/>
    <id>http://kkget.github.io/2020/09/24/JVM%E8%B0%83%E4%BC%98%E7%9B%B8%E5%85%B3/</id>
    <published>2020-09-24T02:35:48.000Z</published>
    <updated>2020-10-26T08:39:08.721Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线上系统CPU，内存与磁盘IO暴增，你会如何调优？"><a href="#线上系统CPU，内存与磁盘IO暴增，你会如何调优？" class="headerlink" title="线上系统CPU，内存与磁盘IO暴增，你会如何调优？"></a>线上系统CPU，内存与磁盘IO暴增，你会如何调优？</h1><p>①首先top命令确定到具体线程，将内存与io异常的线程记录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[root@zhaokk logs]# top</span><br><span class="line">top - <span class="number">16</span>:<span class="number">48</span>:<span class="number">59</span> up <span class="number">2</span> days, <span class="number">23</span>:<span class="number">23</span>,  <span class="number">1</span> user,  load average: <span class="number">0.00</span>, <span class="number">0.01</span>, <span class="number">0.20</span></span><br><span class="line">Tasks: <span class="number">1784</span> total,   <span class="number">2</span> running, <span class="number">1354</span> sleeping,   <span class="number">0</span> stopped, <span class="number">428</span> zombie</span><br><span class="line">%Cpu(s):  <span class="number">0.0</span> us,  <span class="number">0.0</span> sy,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> wa,  <span class="number">0.0</span> hi,  <span class="number">0.0</span> si,  <span class="number">0.0</span> st</span><br><span class="line">KiB Mem :  <span class="number">1882736</span> total,    <span class="number">70640</span> free,  <span class="number">1526212</span> used,   <span class="number">285884</span> buff/cache</span><br><span class="line">KiB Swap:        <span class="number">0</span> total,        <span class="number">0</span> free,        <span class="number">0</span> used.    <span class="number">29260</span> avail Mem </span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND                                                                                                   </span><br><span class="line"><span class="number">17755</span> root      <span class="number">20</span>   <span class="number">0</span>  <span class="number">165676</span>   <span class="number">4060</span>   <span class="number">1600</span> R  <span class="number">3.2</span>  <span class="number">0.2</span>   <span class="number">0</span>:<span class="number">00.79</span> top                                                                                                       </span><br><span class="line"><span class="number">15120</span> root      <span class="number">10</span> -<span class="number">10</span>  <span class="number">134524</span>   <span class="number">6240</span>   <span class="number">1140</span> S  <span class="number">1.0</span>  <span class="number">0.3</span>   <span class="number">1</span>:<span class="number">04.54</span> AliYunDun                                                                                                 </span><br><span class="line"> <span class="number">1325</span> root      <span class="number">10</span> -<span class="number">10</span>  <span class="number">438960</span>    <span class="number">676</span>     <span class="number">80</span> S  <span class="number">0.3</span>  <span class="number">0.0</span>  <span class="number">12</span>:<span class="number">14.54</span> AliSecGuard                                                                                               </span><br><span class="line"> <span class="number">7688</span> root      <span class="number">20</span>   <span class="number">0</span> <span class="number">2522072</span>  <span class="number">86580</span>   <span class="number">2172</span> S  <span class="number">0.3</span>  <span class="number">4.6</span>   <span class="number">0</span>:<span class="number">33.20</span> java                                                                                                      </span><br><span class="line">    <span class="number">1</span> root      <span class="number">20</span>   <span class="number">0</span>  <span class="number">120276</span>  <span class="number">60392</span>    <span class="number">640</span> S  <span class="number">0.0</span>  <span class="number">3.2</span>   <span class="number">4</span>:<span class="number">37.34</span> systemd                                                                                                   </span><br><span class="line">    <span class="number">2</span> root      <span class="number">20</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.01</span> kthreadd                                                                                                  </span><br><span class="line">    <span class="number">3</span> root      <span class="number">20</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">31.43</span> ksoftirqd/<span class="number">0</span>                                                                                               </span><br><span class="line">    <span class="number">5</span> root       <span class="number">0</span> -<span class="number">20</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> kworker/<span class="number">0</span>:<span class="number">0</span>H                                                                                              </span><br><span class="line">    <span class="number">7</span> root      rt   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> migration/<span class="number">0</span>                                                                                               </span><br><span class="line">    <span class="number">8</span> root      <span class="number">20</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> rcu_bh                                                                                                    </span><br><span class="line">    <span class="number">9</span> root      <span class="number">20</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> R  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">6</span>:<span class="number">31.17</span> rcu_sched                                                                                                 </span><br><span class="line">   <span class="number">10</span> root       <span class="number">0</span> -<span class="number">20</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> lru-add-drain                                                                                             </span><br><span class="line">   <span class="number">13</span> root      <span class="number">20</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> kdevtmpfs                                                                                                 </span><br><span class="line">   <span class="number">14</span> root       <span class="number">0</span> -<span class="number">20</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> netns                                                                                                     </span><br><span class="line">   <span class="number">15</span> root      <span class="number">20</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.69</span> khungtaskd                                                                                                </span><br><span class="line">   <span class="number">16</span> root       <span class="number">0</span> -<span class="number">20</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.03</span> writeback                                                                                                 </span><br><span class="line">   <span class="number">17</span> root       <span class="number">0</span> -<span class="number">20</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> kintegrityd                                                                                               </span><br><span class="line">   <span class="number">18</span> root       <span class="number">0</span> -<span class="number">20</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> bioset                                                                                                    </span><br><span class="line">   <span class="number">19</span> root       <span class="number">0</span> -<span class="number">20</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> bioset                                                                                                    </span><br><span class="line">   <span class="number">20</span> root       <span class="number">0</span> -<span class="number">20</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> bioset</span><br></pre></td></tr></table></figure><p>②查看磁盘IO </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sar -d -p <span class="number">1</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="number">09</span>:<span class="number">51</span>:<span class="number">48</span> AM       DEV       tps     rkB/s     wkB/s   areq-sz    aqu-sz     await     svctm     %util</span><br><span class="line"><span class="number">09</span>:<span class="number">51</span>:<span class="number">49</span> AM       vda      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span></span><br><span class="line"><span class="number">09</span>:<span class="number">51</span>:<span class="number">50</span> AM       vda      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span></span><br><span class="line">Average:          vda      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span></span><br></pre></td></tr></table></figure><p>其中， “-d”参数代表查看磁盘性能，“-p”参数代表将 dev 设备按照 sda，sdb……名称显示，“1”代表每隔1s采取一次数值，“2”代表总共采取2次数值。<br>await：平均每次设备 I/O 操作的等待时间（以毫秒为单位）。<br>svctm：平均每次设备 I/O 操作的服务时间（以毫秒为单位）。<br>%util：一秒中有百分之几的时间用于 I/O 操作<br>磁盘IO标准:<br>正常情况下 svctm 应该是小于 await 值的，而 svctm 的大小和磁盘性能有关，CPU 、内存的负荷也会对 svctm 值造成影响，过多的请求也会间接的导致 svctm 值的增加。<br>await 值的大小一般取决与 svctm 的值和 I/O 队列长度以 及I/O 请求模式，如果 svctm 的值与 await 很接近，表示几乎没有 I/O 等待，磁盘性能很好，如果 await 的值远高于 svctm 的值，则表示 I/O 队列等待太长，系统上运行的应用程序将变慢，此时可以通过更换更快的硬盘来解决问题。<br>%util 项的值也是衡量磁盘 I/O 的一个重要指标，如果 %util 接近 100% ，表示磁盘产生的 I/O 请求太多，I/O 系统已经满负荷的在工作，该磁盘可能存在瓶颈。长期下去，势必影响系统的性能，可以通过优化程序或者通过更换更高、更快的磁盘来解决此问题<br>③.确定好具体线程后定位具体代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef|grep <span class="number">2588</span>|grep -v grep</span><br></pre></td></tr></table></figure><p>④定位</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -mp <span class="number">2588</span> -o THREAD,tid,time</span><br></pre></td></tr></table></figure><p>⑤换算16进制后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack <span class="number">2588</span> |grep a1d -A60</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/jvm/1.png" alt="图1" title>                </div>                <div class="image-caption">图1</div>            </figure><p>接下来就处理是逻辑问题，还是代码，还是数据库问题了</p><h1 id="你们JVM线上使用的什么垃圾回收器？CMS还是G1？"><a href="#你们JVM线上使用的什么垃圾回收器？CMS还是G1？" class="headerlink" title="你们JVM线上使用的什么垃圾回收器？CMS还是G1？"></a>你们JVM线上使用的什么垃圾回收器？CMS还是G1？</h1><p>我们线上由于使用的java8，默认垃圾回收器G1，如果不知道，可以打印下GC，-XX:PrintGCDetails,<br>windows查看收集器</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/jvm/2.png" alt="图1" title>                </div>                <div class="image-caption">图1</div>            </figure><p>Linux 查看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+PrintCommandLineFlags -version</span><br><span class="line">-XX:InitialHeapSize=<span class="number">260062400</span> -XX:MaxHeapSize=<span class="number">4160998400</span> -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseParallelGC </span><br><span class="line">java version <span class="string">"1.8.0_261"</span></span><br><span class="line">Java(TM) <span class="function">SE Runtime <span class="title">Environment</span> <span class="params">(build <span class="number">1.8</span><span class="number">.0</span>_261-b12)</span></span></span><br><span class="line"><span class="function">Java <span class="title">HotSpot</span><span class="params">(TM)</span> 64-Bit Server <span class="title">VM</span> <span class="params">(build <span class="number">25.261</span>-b12, mixed mode)</span></span></span><br></pre></td></tr></table></figure><p>-XX:+UseParallelGC</p><h1 id="垃圾收集器种类"><a href="#垃圾收集器种类" class="headerlink" title="垃圾收集器种类"></a>垃圾收集器种类</h1><p>垃圾回收器：并行  串行   并发标记(CMS)  G1    ZGC</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java15 ZGC转正</span><br><span class="line">ZGC 功能转正</span><br><span class="line">ZGC是一个可伸缩、低延迟的垃圾回收器。</span><br><span class="line">ZGC 已由JEP <span class="number">333</span>集成到JDK <span class="number">11</span> 中，其目标是通过减少 GC 停顿时间来提高性能。借助 JEP <span class="number">377</span>，JDK <span class="number">15</span> 将 ZGC 垃圾收集器从预览特性变更为正式特性而已，没错，转正了。</span><br><span class="line">这个 JEP 不会更改默认的 GC，默认仍然是 G1。</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/jvm/3.png" alt="图" title>                </div>                <div class="image-caption">图</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/jvm/4.png" alt="图" title>                </div>                <div class="image-caption">图</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/jvm/5.png" alt="图" title>                </div>                <div class="image-caption">图</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/jvm/6.png" alt="图" title>                </div>                <div class="image-caption">图</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/jvm/7.png" alt="图" title>                </div>                <div class="image-caption">图</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/jvm/8.png" alt="图" title>                </div>                <div class="image-caption">图</div>            </figure><h1 id="CMS的并发更新失败是怎么回事？如何优化？"><a href="#CMS的并发更新失败是怎么回事？如何优化？" class="headerlink" title="CMS的并发更新失败是怎么回事？如何优化？"></a>CMS的并发更新失败是怎么回事？如何优化？</h1><p>CMS垃圾回收失败类型主要是两种：并发失效和晋升失败<br>并发失效<br>在新生代(YoungGen)发生垃圾回收时，达到晋升年龄的对象会被移动到老年代(OldGen)中。<br>如果老年代没有足够的空间容纳这个晋升对象，CMS为了腾出老年代空间，就会从本来的MinorGC退化成FullGC。<br>MinorGC只回收新生代，而FullGC不仅回收新生代，而且还会回收老年代，永久区(PermGen)或元区(MetaSpace)空间回收也可能随FullGC顺便执行。<br>本来只是简单的新生代回收工作扩大到老年代甚至更大。除此之外，老年代空间通常比新生代的Eden和Survivor区大得多，检查和清理无效对象的时间要多得多。<br>还有，FullGC回收的同时，所有进程必须StopTheWorld，并用单线程(SerialGC)开始垃圾回收。导致本来可以并发的MinorGC变得缓慢无比。<br>晋升失败<br>晋升失败同样是老年代导致的问题。<br>CMS开启新生代垃圾收集的时候，判断老年代似乎有足够空间容纳所有晋升对象。<br>然而晋升的时候才发现老年代的空间竟然都是碎片化的，根本容纳不了一个完整的晋升对象。<br>剩下出路只有内存整理。所有应用运行的线程停止，CMS开始对老年代进行整理和压缩。<br>空间压缩要通过移动里面的对象，令这些对象排列好，所以晋升失败比不需要移动对象的并发失效更加浪费时间。<br>完成清理的堆空间变得规整和空余，继续运行应用。<br>调优<br>并发失效调优：<br>令老生代垃圾回收提早，增大回收频率<br>增大老年代空间<br>增大新生代空间，提高对象滞留时间，更多新对象被回收而不是晋升。<br>增加更多后台回收线程<br>晋升失败调优：<br>有难度，因为CMS本身不能规整Compat内存，只能退化到SerialGC来做<br>尝试用G1，G1的内存模型更加先进</p><h1 id="JVM是任何时刻都可以STW吗？为什么？"><a href="#JVM是任何时刻都可以STW吗？为什么？" class="headerlink" title="JVM是任何时刻都可以STW吗？为什么？"></a>JVM是任何时刻都可以STW吗？为什么？</h1><p>STW即停顿类型<br>垃圾回收并不会阻塞我们程序的线程，他是与当前程序并发执行的。所以问题就出在这里，当GC线程标记好了一个对象的时候，此时我们程序的线程又将该对象重新加入了“关系网”中，当执行二次标记的时候，该对象也没有重写finalize()方法，因此回收的时候就会回收这个不该回收的对象。<br>  虚拟机的解决方法就是在一些特定指令位置设置一些“安全点”，当程序运行到这些“安全点”的时候就会暂停所有当前运行的线程（Stop The World 所以叫STW），暂停后再找到“GC Roots”进行关系的组建，进而执行标记和清除<br>这些特定的指令（安全点）位置主要在：<br>1、循环的末尾<br>2、方法临返回前 / 调用方法的call指令后<br>3、可能抛异常的位置<br>那个停顿类型就是STW，至于有GC和Full GC之分，还有Full GC (System)。个人认为主要是Full GC时STW的时间相对GC来说时间很长，因为Full GC针对整个堆以及永久代的，因此整个GC的范围大大增加；还有就是他的回收算法就是我们之前说过的“标记–清除–整理”，这里也会损耗一定的时间。所以我们在优化JVM的时候，减少Full GC的次数也是经常用到的办法。</p><h1 id="线上系统GC问题如何快速定位与分析？阿里巴巴的Arthas用过吗？"><a href="#线上系统GC问题如何快速定位与分析？阿里巴巴的Arthas用过吗？" class="headerlink" title="线上系统GC问题如何快速定位与分析？阿里巴巴的Arthas用过吗？"></a>线上系统GC问题如何快速定位与分析？阿里巴巴的Arthas用过吗？</h1><p>Arthas单独去学就好</p><h1 id="单机几十万并发的系统JVM如何优化？"><a href="#单机几十万并发的系统JVM如何优化？" class="headerlink" title="单机几十万并发的系统JVM如何优化？"></a>单机几十万并发的系统JVM如何优化？</h1><p>既然说了单机了，服务单机，就把中间件去集群化<br>redis+二级缓存+mq+数据库优化</p><h1 id="高并发系统为何建议选择G1垃圾收集器？"><a href="#高并发系统为何建议选择G1垃圾收集器？" class="headerlink" title="高并发系统为何建议选择G1垃圾收集器？"></a>高并发系统为何建议选择G1垃圾收集器？</h1><p>上面G1特点已经讲过了</p><h1 id="能说说Mysql索引底层B-树结构与算法吗？"><a href="#能说说Mysql索引底层B-树结构与算法吗？" class="headerlink" title="能说说Mysql索引底层B+树结构与算法吗？"></a>能说说Mysql索引底层B+树结构与算法吗？</h1><p>B+树中的B代表平衡（balance），而不是二叉（binary）<br>B-Tree：平衡二叉树<br>特点：<br>        1.具有数据节点<br>        2.指向下层指针<br>        3.指向数据指针<br>缺页查询,产生IO<br>B+Tree：<br>特点:<br>       1.具有数据节点<br>       2.指向下层指针<br>命中数据3层查找后查询数据指针<br>加载更快，产生更少IO</p><p>效率上BTree更高，但从IO角度，Mysql选择B+Tree</p><p>B+tree算法<br>插入算法<br>删除算法</p><p><a href="https://www.codedump.info/post/20200615-btree-2/" target="_blank" rel="noopener">https://www.codedump.info/post/20200615-btree-2/</a></p><h1 id="聚集索引与覆盖索引与索引下推到底是什么？"><a href="#聚集索引与覆盖索引与索引下推到底是什么？" class="headerlink" title="聚集索引与覆盖索引与索引下推到底是什么？"></a>聚集索引与覆盖索引与索引下推到底是什么？</h1><p>聚集索引和组合索引<br>索引<br>表的数据量比较大时，查询操作会很耗时。建立索引是加快查询速度的有效手段。<br>数据库索引就类似于书签，可以快速定位到要查询的内容。数据库索引类型<br>有顺序文件索引，B+树索引，散列索引，位图索引。其中B+树索引应用广泛。<br>在B+树上的查找，删除，插入的代价为O ( l o g N ) O(log N)O(logN)。建立索引有好处，当然也有<br>缺点。索引会占额外存储空间。每次数据更新时，也要用额外的时间来维护索引。</p><h1 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h1><p>一张表里面只能有一个聚集索引，一般设置主键为索引。<br>数据库中行数据的物理顺序和索引顺序相同。这样的索引称为聚集索引。<br>一张表只有一个物理顺序，也就只能有一个聚集索引。</p><h1 id="组合索引-覆盖索引"><a href="#组合索引-覆盖索引" class="headerlink" title="组合索引(覆盖索引)"></a>组合索引(覆盖索引)</h1><p>定义：包含两个或多个属性列的索引称为复合索引。</p><h1 id="索引下推-Index-Condition-Pushdown"><a href="#索引下推-Index-Condition-Pushdown" class="headerlink" title="索引下推 Index Condition Pushdown"></a>索引下推 Index Condition Pushdown</h1><p>官网描述</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">The goal of ICP is to reduce the number of full-record </span><br><span class="line">reads and thereby reduce IO operations. For InnoDB clustered indexes,</span><br><span class="line">the complete record is already read into the InnoDB buffer.</span><br><span class="line">Using ICP in <span class="keyword">this</span> <span class="keyword">case</span> does not reduce IO.</span><br><span class="line">ICP的目标是减少完整记录读取的次数，从而减少IO操作。对于InnoDB聚集索引，</span><br><span class="line">完整的记录已经被读入InnoDB缓冲区。在这种情况下使用ICP不会减少IO。</span><br></pre></td></tr></table></figure><h1 id="能说说Mysql并发支撑底层Buffer-Pool机制吗？"><a href="#能说说Mysql并发支撑底层Buffer-Pool机制吗？" class="headerlink" title="能说说Mysql并发支撑底层Buffer Pool机制吗？"></a>能说说Mysql并发支撑底层Buffer Pool机制吗？</h1><p>一个缓冲池，来来回回还是缓存+池化思想那一套</p><h1 id="一线互联网公司的数据库架构是如何设计的"><a href="#一线互联网公司的数据库架构是如何设计的" class="headerlink" title="一线互联网公司的数据库架构是如何设计的?"></a>一线互联网公司的数据库架构是如何设计的?</h1><p>我愿意咋设计就咋设计(*￣︶￣)<br>先从业务逻辑上避免复杂关联库，冗余字段等<br>记录表等多次查询的字段建索引<br>多用标识性字段不用 is null等操作<br>阿里微服务分布式事务Seata源码深度剖析</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/jvm/9.png" alt="图" title>                </div>                <div class="image-caption">图</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/jvm/10.png" alt="图" title>                </div>                <div class="image-caption">图</div>            </figure><h1 id="动态链接与常量池"><a href="#动态链接与常量池" class="headerlink" title="动态链接与常量池"></a>动态链接与常量池</h1><p>大部分字节码质量在执行的时候，都需要常量池的访问<br>指向运行时常量池的方法引用<br>方法的绑定机制<br>静态链接:编译期可确定</p><p>动态链接:编译期无法确定</p><p>早期绑定:同理</p><p>晚期绑定:同理</p><p>方法调用指令区分虚方法与非虚方法</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/jvm/11.png" alt="图" title>                </div>                <div class="image-caption">图</div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;线上系统CPU，内存与磁盘IO暴增，你会如何调优？&quot;&gt;&lt;a href=&quot;#线上系统CPU，内存与磁盘IO暴增，你会如何调优？&quot; class=&quot;headerlink&quot; title=&quot;线上系统CPU，内存与磁盘IO暴增，你会如何调优？&quot;&gt;&lt;/a&gt;线上系统CPU，内存与
      
    
    </summary>
    
    
    
      <category term="JVM" scheme="http://kkget.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>【声明】阿里云服务器导致图片不显示</title>
    <link href="http://kkget.github.io/2020/08/17/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AF%BC%E8%87%B4%E5%9B%BE%E7%89%87%E4%B8%8D%E6%98%BE%E7%A4%BA%E3%80%90%E5%9C%A8%E6%AD%A4%E7%95%99%E8%A8%80%E3%80%91/"/>
    <id>http://kkget.github.io/2020/08/17/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AF%BC%E8%87%B4%E5%9B%BE%E7%89%87%E4%B8%8D%E6%98%BE%E7%A4%BA%E3%80%90%E5%9C%A8%E6%AD%A4%E7%95%99%E8%A8%80%E3%80%91/</id>
    <published>2020-08-17T02:13:48.000Z</published>
    <updated>2021-02-04T09:03:23.256Z</updated>
    
    <content type="html"><![CDATA[<p>1.图片服务器原因不定期修复…紧急修复中….2021年1月8日<br>2.重要重要【图片不显示，请更换为火狐浏览器打开！！！或者手机在微信中打开也可食用】,放大图片更清晰<br>3.服务器内存过小，2020年10月13日后续内容将图片转至git存储<br>4.2d妹子没事不要点，会叫，尽可能别白嫖，留个言就行</p><!-- <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/009.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure> --><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/ss.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.图片服务器原因不定期修复…紧急修复中….2021年1月8日&lt;br&gt;2.重要重要【图片不显示，请更换为火狐浏览器打开！！！或者手机在微信中打开也可食用】,放大图片更清晰&lt;br&gt;3.服务器内存过小，2020年10月13日后续内容将图片转至git存储&lt;br&gt;4.2d妹子没事不
      
    
    </summary>
    
    
      <category term="置顶" scheme="http://kkget.github.io/categories/%E7%BD%AE%E9%A1%B6/"/>
    
    
      <category term="声明" scheme="http://kkget.github.io/tags/%E5%A3%B0%E6%98%8E/"/>
    
  </entry>
  
  <entry>
    <title>有没有有顺序的Map实现类，如果有，他们是怎么保证有序的。</title>
    <link href="http://kkget.github.io/2020/08/05/%E6%9C%89%E6%B2%A1%E6%9C%89%E6%9C%89%E9%A1%BA%E5%BA%8F%E7%9A%84Map%E5%AE%9E%E7%8E%B0%E7%B1%BB%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%9C%89%EF%BC%8C%E4%BB%96%E4%BB%AC%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E6%9C%89%E5%BA%8F%E7%9A%84%E3%80%82/"/>
    <id>http://kkget.github.io/2020/08/05/%E6%9C%89%E6%B2%A1%E6%9C%89%E6%9C%89%E9%A1%BA%E5%BA%8F%E7%9A%84Map%E5%AE%9E%E7%8E%B0%E7%B1%BB%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%9C%89%EF%BC%8C%E4%BB%96%E4%BB%AC%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E6%9C%89%E5%BA%8F%E7%9A%84%E3%80%82/</id>
    <published>2020-08-05T03:26:52.000Z</published>
    <updated>2020-09-30T08:43:25.784Z</updated>
    
    <content type="html"><![CDATA[<h1 id="sortedMap，NavigableMap，TreeMap，ConcurrentSkipListMap"><a href="#sortedMap，NavigableMap，TreeMap，ConcurrentSkipListMap" class="headerlink" title="sortedMap，NavigableMap，TreeMap，ConcurrentSkipListMap"></a>sortedMap，NavigableMap，TreeMap，ConcurrentSkipListMap</h1><p>主要看下ConcurrentSkipListMap</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentSkipListMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">ConcurrentNavigableMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>1.类图</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/skipListMap.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>底层数据结构是skipList(跳表)<br><a href="https://segmentfault.com/a/1190000016168566?utm_source=tag-newest" target="_blank" rel="noopener">https://segmentfault.com/a/1190000016168566?utm_source=tag-newest</a><br>这篇文章对跳表解析的比较清晰<br>2.构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentSkipListMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.comparator = <span class="keyword">null</span>;</span><br><span class="line">        initialize();</span><br><span class="line">    &#125;</span><br><span class="line">ConcurrentSkipListMap会基于比较器——Comparator ，来进行键Key的比较，如果构造时未指定Comparator ，那么就会按照Key的自然顺序进行比较，所谓Key的自然顺序是指key实现Comparable接口。</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentSkipListMap</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> K&gt; comparator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">        initialize();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentSkipListMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.comparator = <span class="keyword">null</span>;</span><br><span class="line">        initialize();</span><br><span class="line">        putAll(m);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentSkipListMap</span><span class="params">(SortedMap&lt;K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.comparator = m.comparator();</span><br><span class="line">        initialize();</span><br><span class="line">        buildFromSorted(m);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>put方法 K,V都不能为null</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">return</span> doPut(key, value, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">doPut</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; z;             <span class="comment">// added node</span></span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        Comparator&lt;? <span class="keyword">super</span> K&gt; cmp = comparator;</span><br><span class="line">        outer: <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;K,V&gt; b = findPredecessor(key, cmp), n = b.next;;) &#123;</span><br><span class="line">                <span class="keyword">if</span> (n != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Object v; <span class="keyword">int</span> c;</span><br><span class="line">                    Node&lt;K,V&gt; f = n.next;</span><br><span class="line">                    <span class="keyword">if</span> (n != b.next)               <span class="comment">// inconsistent read</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">if</span> ((v = n.value) == <span class="keyword">null</span>) &#123;   <span class="comment">// n is deleted</span></span><br><span class="line">                        n.helpDelete(b, f);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (b.value == <span class="keyword">null</span> || v == n) <span class="comment">// b is deleted</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">if</span> ((c = cpr(cmp, key, n.key)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        b = n;</span><br><span class="line">                        n = f;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (onlyIfAbsent || n.casValue(v, value)) &#123;</span><br><span class="line">                            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) V vv = (V)v;</span><br><span class="line">                            <span class="keyword">return</span> vv;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>; <span class="comment">// restart if lost race to replace value</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// else c &lt; 0; fall through</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                z = <span class="keyword">new</span> Node&lt;K,V&gt;(key, value, n);</span><br><span class="line">                <span class="keyword">if</span> (!b.casNext(n, z))</span><br><span class="line">                    <span class="keyword">break</span>;         <span class="comment">// restart if lost race to append to b</span></span><br><span class="line">                <span class="keyword">break</span> outer;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> rnd = ThreadLocalRandom.nextSecondarySeed();</span><br><span class="line">        <span class="keyword">if</span> ((rnd &amp; <span class="number">0x80000001</span>) == <span class="number">0</span>) &#123; <span class="comment">// test highest and lowest bits</span></span><br><span class="line">            <span class="keyword">int</span> level = <span class="number">1</span>, max;</span><br><span class="line">            <span class="keyword">while</span> (((rnd &gt;&gt;&gt;= <span class="number">1</span>) &amp; <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">                ++level;</span><br><span class="line">            Index&lt;K,V&gt; idx = <span class="keyword">null</span>;</span><br><span class="line">            HeadIndex&lt;K,V&gt; h = head;</span><br><span class="line">            <span class="keyword">if</span> (level &lt;= (max = h.level)) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= level; ++i)</span><br><span class="line">                    idx = <span class="keyword">new</span> Index&lt;K,V&gt;(z, idx, <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// try to grow by one level</span></span><br><span class="line">                level = max + <span class="number">1</span>; <span class="comment">// hold in array and later pick the one to use</span></span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)Index&lt;K,V&gt;[] idxs =</span><br><span class="line">                    (Index&lt;K,V&gt;[])<span class="keyword">new</span> Index&lt;?,?&gt;[level+<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= level; ++i)</span><br><span class="line">                    idxs[i] = idx = <span class="keyword">new</span> Index&lt;K,V&gt;(z, idx, <span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                    h = head;</span><br><span class="line">                    <span class="keyword">int</span> oldLevel = h.level;</span><br><span class="line">                    <span class="keyword">if</span> (level &lt;= oldLevel) <span class="comment">// lost race to add level</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    HeadIndex&lt;K,V&gt; newh = h;</span><br><span class="line">                    Node&lt;K,V&gt; oldbase = h.node;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = oldLevel+<span class="number">1</span>; j &lt;= level; ++j)</span><br><span class="line">                        newh = <span class="keyword">new</span> HeadIndex&lt;K,V&gt;(oldbase, newh, idxs[j], j);</span><br><span class="line">                    <span class="keyword">if</span> (casHead(h, newh)) &#123;</span><br><span class="line">                        h = newh;</span><br><span class="line">                        idx = idxs[level = oldLevel];</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// find insertion points and splice in</span></span><br><span class="line">            splice: <span class="keyword">for</span> (<span class="keyword">int</span> insertionLevel = level;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = h.level;</span><br><span class="line">                <span class="keyword">for</span> (Index&lt;K,V&gt; q = h, r = q.right, t = idx;;) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (q == <span class="keyword">null</span> || t == <span class="keyword">null</span>)</span><br><span class="line">                        <span class="keyword">break</span> splice;</span><br><span class="line">                    <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; n = r.node;</span><br><span class="line">                        <span class="comment">// compare before deletion check avoids needing recheck</span></span><br><span class="line">                        <span class="keyword">int</span> c = cpr(cmp, key, n.key);</span><br><span class="line">                        <span class="keyword">if</span> (n.value == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (!q.unlink(r))</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            r = q.right;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (c &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            q = r;</span><br><span class="line">                            r = r.right;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (j == insertionLevel) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!q.link(r, t))</span><br><span class="line">                            <span class="keyword">break</span>; <span class="comment">// restart</span></span><br><span class="line">                        <span class="keyword">if</span> (t.node.value == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            findNode(key);</span><br><span class="line">                            <span class="keyword">break</span> splice;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (--insertionLevel == <span class="number">0</span>)</span><br><span class="line">                            <span class="keyword">break</span> splice;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (--j &gt;= insertionLevel &amp;&amp; j &lt; level)</span><br><span class="line">                        t = t.down;</span><br><span class="line">                    q = q.down;</span><br><span class="line">                    r = q.right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> doGet(key);</span><br><span class="line">    &#125;</span><br><span class="line">Comparator方法比较后保证key来排序的，</span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">doGet</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        Comparator&lt;? <span class="keyword">super</span> K&gt; cmp = comparator;</span><br><span class="line">        outer: <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;K,V&gt; b = findPredecessor(key, cmp), n = b.next;;) &#123;</span><br><span class="line">                Object v; <span class="keyword">int</span> c;</span><br><span class="line">                <span class="keyword">if</span> (n == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">break</span> outer;</span><br><span class="line">                Node&lt;K,V&gt; f = n.next;</span><br><span class="line">                <span class="keyword">if</span> (n != b.next)                <span class="comment">// inconsistent read</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> ((v = n.value) == <span class="keyword">null</span>) &#123;    <span class="comment">// n is deleted</span></span><br><span class="line">                    n.helpDelete(b, f);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (b.value == <span class="keyword">null</span> || v == n)  <span class="comment">// b is deleted</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> ((c = cpr(cmp, key, n.key)) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) V vv = (V)v;</span><br><span class="line">                    <span class="keyword">return</span> vv;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (c &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span> outer;</span><br><span class="line">                b = n;</span><br><span class="line">                n = f;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;sortedMap，NavigableMap，TreeMap，ConcurrentSkipListMap&quot;&gt;&lt;a href=&quot;#sortedMap，NavigableMap，TreeMap，ConcurrentSkipListMap&quot; class=&quot;headerl
      
    
    </summary>
    
    
    
      <category term="Map" scheme="http://kkget.github.io/tags/Map/"/>
    
  </entry>
  
  <entry>
    <title>重视Netty源码解析</title>
    <link href="http://kkget.github.io/2020/08/03/%E9%87%8D%E8%A7%86Netty%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://kkget.github.io/2020/08/03/%E9%87%8D%E8%A7%86Netty%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</id>
    <published>2020-08-03T07:01:15.000Z</published>
    <updated>2020-08-03T07:50:10.737Z</updated>
    
    <content type="html"><![CDATA[<p>第一次学习Netty可追溯到2019年1月，现在重新阅读多篇资料和源码后自己以个人能够理解的方式总结下Netty，参考多篇资料<br>1.Netty是啥<br>官网定义<br>Netty是 一个异步事件驱动的网络应用程序框架，用于快速开发可维护的高性能协议服务器和客户端。<br>学习Netty之前，通篇讲述了Channel，selector，selectionKey，以便于理解Netty的Reactor模型，并且从AIO，BIO,NIO讲解<br>从服务端代码入手</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WSServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        EventLoopGroup mainGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup subGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap server = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            server.group(mainGroup, subGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                    .<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">WSServerInitialzer</span>())</span>;</span><br><span class="line"></span><br><span class="line">            ChannelFuture future = server.bind(<span class="number">8088</span>).sync();</span><br><span class="line">            <span class="keyword">if</span> (future.isSuccess()) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Netty启动成功.............."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainGroup.shutdownGracefully();</span><br><span class="line">            subGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1：这里官方定义的mainGroup和subGroup命名为boss和worker，从这里第一时间就想到了Nginx的工作原理master-workers机制，像不像？相似度90%。<br>首先，对于每个worker进程来说，独立的进程，不需要加锁，<br>所以省掉了锁带来的开销，同时在编程以及问题查找时，也会方<br>便很多。<br>其次，采用独立的进程，可以让互相之间不会影响，一个进程<br>退出后，其它进程还在工作，服务不会中断，master进程则很快启<br>动新的worker进程。当然，worker进程的异常退出，肯定是程序有<br>bug了，异常退出，会导致当前worker上的所有请求失败，不过不<br>会影响到所有请求，所以降低了风险<br>并且Nginx也采用了多路Io复用机制</p><p>#Reactor线程模型<br>Reactor 对应的叫法: 1. 反应器模式 2. 分发者模式(Dispatcher) 3. 通知者模式(notifier)</p><p>Netty模型 Reactor<br>1.Reactor对象通过select监控客户端请求事件，收到后通过dispatch分发<br>2.建立连接请求，由acceptor通过accept处理，创建一个handler对象处理完成连接后的事件。<br>3.如果不是连接请求，则由Reactor对象分发调用连接对应的handler响应<br>4.handler只负责响应事件，不做具体业务处理，通过read方法读取数据后分发给work线程池里的线程处理<br>5.work线程池分配独立线程完成真正的业务，并将结果返回<br>优点：充分利用多核CPU能力<br>缺点：多个线程会数据共享和访问比较复杂，多线程场景出现性能瓶颈</p><p>主从reactor多线程模式<br>1.主线程只管连接<br>2.子线程管处理请求，一个子线程监听多个client，io读取，业务处理往下分配<br>3.当有新事件发生，subReactor调用对应的handler处理</p><p>2：NioEventGroup类图</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/NioEventGroup.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>最上层是什么？不就是线程池的执行接口么，启动时，真正执行的方法是其父类的父类MultithreadEventExecutorGroup的方法调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">MultithreadEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor, Object... args)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>(nThreads == <span class="number">0</span> ? DEFAULT_EVENT_LOOP_THREADS : nThreads, executor, args);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>调到这时，传入的nThreads为0，DEFAULT_EVENT_LOOP_THREADS进行赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_EVENT_LOOP_THREADS;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> &#123;</span><br><span class="line">       DEFAULT_EVENT_LOOP_THREADS = Math.max(<span class="number">1</span>, SystemPropertyUtil.getInt(</span><br><span class="line">               <span class="string">"io.netty.eventLoopThreads"</span>, NettyRuntime.availableProcessors() * <span class="number">2</span>));</span><br><span class="line">       <span class="comment">//CPU核心数的数量乘2</span></span><br><span class="line">       <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">           logger.debug(<span class="string">"-Dio.netty.eventLoopThreads: &#123;&#125;"</span>, DEFAULT_EVENT_LOOP_THREADS);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>那么到MultithreadEventExecutorGroup方法时就变成了8  executor为null</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/debug1.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/debug2.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">MultithreadEventExecutorGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           EventExecutorChooserFactory chooserFactory, Object... args)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (nThreads &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(<span class="string">"nThreads: %d (expected: &gt; 0)"</span>, nThreads));</span><br><span class="line">       &#125;</span><br><span class="line">executor初始化</span><br><span class="line">       <span class="keyword">if</span> (executor == <span class="keyword">null</span>) &#123;</span><br><span class="line">           executor = <span class="keyword">new</span> ThreadPerTaskExecutor(newDefaultThreadFactory());</span><br><span class="line">       &#125;</span><br><span class="line">      children 在最上层定义<span class="comment">// private final EventExecutor[] children;</span></span><br><span class="line">       children = <span class="keyword">new</span> EventExecutor[nThreads];</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nThreads; i ++) &#123;</span><br><span class="line">           <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//进入循环就是8次么</span></span><br><span class="line">           <span class="comment">//第一次success为false</span></span><br><span class="line">           .</span><br><span class="line">           .</span><br><span class="line">           .</span><br><span class="line">           i=<span class="number">7</span>时  success=<span class="keyword">true</span></span><br><span class="line">               children[i] = newChild(executor, args);</span><br><span class="line">               success = <span class="keyword">true</span>;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">               <span class="comment">// <span class="doctag">TODO:</span> Think about if this is a good exception type</span></span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"failed to create a child event loop"</span>, e);</span><br><span class="line">           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">                   <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j ++) &#123;</span><br><span class="line">                       children[j].shutdownGracefully();</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j ++) &#123;</span><br><span class="line">                       EventExecutor e = children[j];</span><br><span class="line">                       <span class="keyword">try</span> &#123;</span><br><span class="line">                           <span class="keyword">while</span> (!e.isTerminated()) &#123;</span><br><span class="line">                               e.awaitTermination(Integer.MAX_VALUE, TimeUnit.SECONDS);</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125; <span class="keyword">catch</span> (InterruptedException interrupted) &#123;</span><br><span class="line">                           <span class="comment">// Let the caller handle the interruption.</span></span><br><span class="line">                           Thread.currentThread().interrupt();</span><br><span class="line">                           <span class="keyword">break</span>;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       chooser = chooserFactory.newChooser(children);</span><br><span class="line">       <span class="comment">//任务监听</span></span><br><span class="line">       <span class="keyword">final</span> FutureListener&lt;Object&gt; terminationListener = <span class="keyword">new</span> FutureListener&lt;Object&gt;() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(Future&lt;Object&gt; future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">               <span class="keyword">if</span> (terminatedChildren.incrementAndGet() == children.length) &#123;</span><br><span class="line">                   terminationFuture.setSuccess(<span class="keyword">null</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (EventExecutor e: children) &#123;</span><br><span class="line">           e.terminationFuture().addListener(terminationListener);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//addAll()方法用于将所有指定的元素添加到指定的集合中</span></span><br><span class="line">       Set&lt;EventExecutor&gt; childrenSet = <span class="keyword">new</span> LinkedHashSet&lt;EventExecutor&gt;(children.length);</span><br><span class="line">       Collections.addAll(childrenSet, children);</span><br><span class="line">       readonlyChildren = Collections.unmodifiableSet(childrenSet);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ChannelFuture future = server.bind(<span class="number">8088</span>).sync();</span><br><span class="line">异步绑定端口号</span><br><span class="line">mainGroup.shutdownGracefully();</span><br><span class="line">优雅关闭</span><br></pre></td></tr></table></figure><p>实际应用个人流程总结</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/nettyserver.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>这里的流程基本就是企业实际应用的流程<br>注解@ChannelHandler.Sharable，标识此Handler可应用于多个NettyClientHandlerInitializer<br>下面代码来自芋道源码github</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClientHandlerInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">Channel</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 心跳超时时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer READ_TIMEOUT_SECONDS = <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MessageDispatcher messageDispatcher;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> NettyClientHandler nettyClientHandler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> </span>&#123;</span><br><span class="line">        ch.pipeline()</span><br><span class="line">                <span class="comment">// 空闲检测</span></span><br><span class="line">                .addLast(<span class="keyword">new</span> IdleStateHandler(READ_TIMEOUT_SECONDS, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">                .addLast(<span class="keyword">new</span> ReadTimeoutHandler(<span class="number">3</span> * READ_TIMEOUT_SECONDS))</span><br><span class="line">                <span class="comment">// 编码器</span></span><br><span class="line">                .addLast(<span class="keyword">new</span> InvocationEncoder())</span><br><span class="line">                <span class="comment">// 解码器</span></span><br><span class="line">                .addLast(<span class="keyword">new</span> InvocationDecoder())</span><br><span class="line">                <span class="comment">// 消息分发器</span></span><br><span class="line">                .addLast(messageDispatcher)</span><br><span class="line">                <span class="comment">// 客户端处理器</span></span><br><span class="line">                .addLast(nettyClientHandler)</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;第一次学习Netty可追溯到2019年1月，现在重新阅读多篇资料和源码后自己以个人能够理解的方式总结下Netty，参考多篇资料&lt;br&gt;1.Netty是啥&lt;br&gt;官网定义&lt;br&gt;Netty是 一个异步事件驱动的网络应用程序框架，用于快速开发可维护的高性能协议服务器和客户端。&lt;
      
    
    </summary>
    
    
    
      <category term="Netty" scheme="http://kkget.github.io/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>CompletableFuture</title>
    <link href="http://kkget.github.io/2020/07/29/CompletableFuture/"/>
    <id>http://kkget.github.io/2020/07/29/CompletableFuture/</id>
    <published>2020-07-29T07:04:59.000Z</published>
    <updated>2020-07-29T08:14:38.394Z</updated>
    
    <content type="html"><![CDATA[<p>想学习CompletableFuture，因此查询资料发现<br>CompletableFuture是JDK8中的新特性，主要用于对JDK5中加入的Future的补充。<br>CompletableFuture实现了CompletionStage和Future接口。<br>需要先了解Future接口<br>什么是Future？<br>简单来说future就是一个Future<T>对象，当执行return await。。。的时候，实际上返回的是一个延迟计算的Future对象，这个Future对象是Dart内置的，有自己的队列策略，它将要操作的事件放入EventQueue中，在队列中的事件按照先进先出的原则去逐一处理事件，当事件处理完成后，将结果返回给Future对象。</T></p><p>在这个过程中涉及到了异步和等待：</p><p>异步：就是不用阻塞当前线程，来等待该线程任务处理完成再去执行其他任务。<br>等待：await，声明运算为延迟执行<br>async和await<br>首先看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getData() async&#123;</span><br><span class="line">   <span class="keyword">return</span> await http.get(Uri.encodeFull(url), headers: &#123;<span class="string">"Accept"</span>: <span class="string">"application/json"</span>&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//然后调用函数来获取结果</span></span><br><span class="line">String data = getData();</span><br></pre></td></tr></table></figure><p>这段代码在运行的时候会报错。<br>因为data是String类型，而函数getData()是一个异步操作函数，其返回值是一个await延迟执行的结果。<br>在Dart中，有await标记的运算，结果都是一个Future对象，Future不是String类型，所以就报错了。<br>如何获取异步函数的结果呢？Dart规定有async标记的函数，只能由await来调用，那么我们可以在函数前加一个await关键字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String data = <span class="function">await <span class="title">getData</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>但是这违背了await必须要在async标记的函数中使用，所以赋值代码可以改成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String data;</span><br><span class="line">setData() async &#123;</span><br><span class="line">  data = <span class="function">await <span class="title">getData</span><span class="params">()</span></span>;    <span class="comment">//getData()延迟执行后赋值给data</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>async和await的使用其实就只有两点：</p><p>await关键字必须在async函数内部使用<br>调用async函数必须使用await关键字</p><p>Dart(释义：镖)异步<br>Dart是单线程模型，是一种Event-Looper以及Event-Queue的模型，所有的事件都是通过EventLooper的依次执行。</p><p>Event-Looper与Netty的NioEventLoopGroup异曲同工，都是线程模型</p><p>作者：zhaoolee<br>链接：<a href="https://www.jianshu.com/p/aefd0e50b802" target="_blank" rel="noopener">https://www.jianshu.com/p/aefd0e50b802</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br>单线程模型<br>所谓单线程，就是一旦一个函数开始执行，就必须将这个函数执行完，才能去执行其他函数</p><p>作者：MakerChin<br>链接：<a href="https://www.jianshu.com/p/890df7ea8f87" target="_blank" rel="noopener">https://www.jianshu.com/p/890df7ea8f87</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br>Future接口的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//取消任务。参数:是否立即中断任务执行，或者等等任务结束</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//任务是否已经取消，若已取消，返回true</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//任务是否已经完成。包括任务正常完成、抛出异常或被取消，都返回true</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*等待任务执行结束，获得V类型的结果。InterruptedException: 线程被中断异常， ExecutionException: 任务执行异常，如果任务被取消，还会抛出CancellationException*/</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*参数timeout指定超时时间，uint指定时间的单位，在枚举类TimeUnit中有相关的定义。如果计算超时，将抛出TimeoutException*/</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用不带参数的get方法的调用被阻塞，直到计算完成。如果在计算完成之前，调用带参get()方法超时时，会抛出TimeoutException异常。若运行该计算的线程被中断，两种get()方法都会抛出InterruptedException。如果计算已经完成，那么get方法立即返回。<br>若计算还在进行，isDone方法返回false；如果完成了，则返回true。<br>调用cancel()时，若计算还没有开始，它被取消且不再开始。若计算处于运行之中，那么如果mayInterrupt参数为true，它就被中断。<br>相比future.get()，其实更推荐使用get (long timeout, TimeUnit unit) 方法，因为设置了超时时间可以防止程序无限制的等待future的返回结果。<br>FutureTask源码解析<br>构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (callable == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">this</span>.callable = callable;</span><br><span class="line">        <span class="comment">//状态为NEW</span></span><br><span class="line">        <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.callable = Executors.callable(runnable, result);</span><br><span class="line">        <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>实际上Callable = Runnable + result，继续看上面的第二个构造方法，看看Executors.callable(runnable, result)的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Callable&lt;T&gt; <span class="title">callable</span><span class="params">(Runnable task, T result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="comment">//new了一个RunnableAdapter,返回Callable,说明RunnableAdapter实现了Callable</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RunnableAdapter&lt;T&gt;(task, result);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>状态值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Possible state transitions:</span></span><br><span class="line"><span class="comment"> * NEW -&gt; COMPLETING -&gt; NORMAL</span></span><br><span class="line"><span class="comment"> * NEW -&gt; COMPLETING -&gt; EXCEPTIONAL</span></span><br><span class="line"><span class="comment"> * NEW -&gt; CANCELLED</span></span><br><span class="line"><span class="comment"> * NEW -&gt; INTERRUPTING -&gt; INTERRUPTED</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"><span class="comment">//初始化状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NEW          = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//正在执行</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COMPLETING   = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//正常完成</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NORMAL       = <span class="number">2</span>;</span><br><span class="line"><span class="comment">//出现异常</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCEPTIONAL  = <span class="number">3</span>;</span><br><span class="line"><span class="comment">//被取消</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED    = <span class="number">4</span>;</span><br><span class="line"><span class="comment">//正被中断</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTING = <span class="number">5</span>;</span><br><span class="line"><span class="comment">//已被中断</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTED  = <span class="number">6</span>;</span><br></pre></td></tr></table></figure><p>FutureTask的run方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*compareAndSwapObject(this, runnerOffset,]null, Thread.currentThread()))</span></span><br><span class="line"><span class="comment">         其中第一个参数为需要改变的对象，第二个为偏移量，第三个参数为期待的值，第四个为更新后的值。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">            !UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, runnerOffset,</span><br><span class="line">                                         <span class="keyword">null</span>, Thread.currentThread()))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Callable&lt;V&gt; c = callable;</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">                V result;</span><br><span class="line">                <span class="keyword">boolean</span> ran;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//call()方法是由FutureTask调用的,说明call()不是异步执行的</span></span><br><span class="line">                    result = c.call();</span><br><span class="line">                    ran = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                    result = <span class="keyword">null</span>;</span><br><span class="line">                    ran = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="comment">//设置异常</span></span><br><span class="line">                    setException(ex);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (ran)</span><br><span class="line">                    set(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// runner must be non-null until state is settled to</span></span><br><span class="line">            <span class="comment">// prevent concurrent calls to run()</span></span><br><span class="line">            runner = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// state must be re-read after nulling runner to prevent</span></span><br><span class="line">            <span class="comment">// leaked interrupts</span></span><br><span class="line">            <span class="keyword">int</span> s = state;</span><br><span class="line">            <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">                handlePossibleCancellationInterrupt(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>set方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(V v)</span> </span>&#123;</span><br><span class="line">           <span class="comment">// NEW -&gt; COMPLETING</span></span><br><span class="line">        <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line">            <span class="comment">//返回结果,也包括异常</span></span><br><span class="line">            outcome = v;</span><br><span class="line">            <span class="comment">//COMPLETING -&gt; NORMAL</span></span><br><span class="line">            UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, NORMAL); <span class="comment">// final state</span></span><br><span class="line">            <span class="comment">//唤醒等待的线程</span></span><br><span class="line">            finishCompletion();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>get方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="comment">//是否是未完成状态,是则等待</span></span><br><span class="line">        <span class="keyword">if</span> (s &lt;= COMPLETING)</span><br><span class="line">            <span class="comment">//等待过程</span></span><br><span class="line">            s = awaitDone(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">        <span class="keyword">return</span> report(s);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> CancellationException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (unit == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="keyword">if</span> (s &lt;= COMPLETING &amp;&amp;</span><br><span class="line">            (s = awaitDone(<span class="keyword">true</span>, unit.toNanos(timeout))) &lt;= COMPLETING)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">        <span class="keyword">return</span> report(s);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。<br>本文链接：<a href="https://blog.csdn.net/itcats_cn/article/details/81322122" target="_blank" rel="noopener">https://blog.csdn.net/itcats_cn/article/details/81322122</a></p><p>CompletableFuture类的官方API文档解释：</p><p>CompletableFuture是一个在完成时可以触发相关方法和操作的Future，并且它可以视作为CompletableStage。<br>除了直接操作状态和结果的这些方法和相关方法外（CompletableFuture API提供的方法），CompletableFuture还实现了以下的CompletionStage的相关策略：<br>① 非异步方法的完成，可以由当前CompletableFuture的线程提供，也可以由其他调用完方法的线程提供。<br>② 所有没有显示使用Executor的异步方法，会使用ForkJoinPool.commonPool()（那些并行度小于2的任务会创建一个新线程来运行）。为了简化监视、调试和跟踪异步方法，所有异步任务都被标记为CompletableFuture.AsynchronouseCompletionTask。<br>③ 所有CompletionStage方法都是独立于其他公共方法实现的，因此一个方法的行为不受子类中其他方法的覆盖影响。<br>CompletableFuture还实现了Future的以下策略<br>① 不像FutureTask，因CompletableFuture无法直接控制计算任务的完成，所以CompletableFuture的取消会被视为异常完成。调用cancel()方法会和调用completeExceptionally（）方法一样，具有同样的效果。isCompletedEceptionally()方法可以判断CompletableFuture是否是异常完成。<br>② 在调用get()和get(long, TimeUnit)方法时以异常的形式完成，则会抛出ExecutionException,大多数情况下都会使用join()和getNow(T)，它们会抛出CompletionException。<br>小结：</p><p>Concurrent包中的Future在获取结果时会发生阻塞，而CompletableFuture则不会，它可以通过触发异步方法来获取结果。<br>在CompletableFuture中，如果没有显示指定的Executor的参数，则会调用默认的ForkJoinPool.commonPool()。<br>调用CompletableFuture的cancel()方法和调用completeExceptionally()方法的效果一样。<br>在JDK5中，使用Future来获取结果时都非常的不方便，只能通过get()方法阻塞线程或者通过轮询isDone()的方式来获取任务结果，这种阻塞或轮询的方式会无畏的消耗CPU资源，而且还不能及时的获取任务结果，因此JDK8中提供了CompletableFuture来实现异步的获取任务结果。</p><p>使用下CompletableFuture的API<br>CompletableFuture类提供了非常多的方法供我们使用，包括了runAsync()、supplyAsync()、thenAccept()等方法。<br>runAsync()，异步运行:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runAsyncExample</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class="line">        CompletableFuture cf = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">        &#125;, executorService);</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cf.isDone()) &#123;</span><br><span class="line">                System.out.println(<span class="string">"CompletedFuture...isDown"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">main</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">CompletedFuture…isDown</span><br></pre></td></tr></table></figure><p>这里调用的runAsync()方法没有使用ForkJoinPool的线程，而是使用了Executors.newSingleThreadExecutor()中的线程。runAsync()其实效果跟单开一个线程一样。<br>supplyAsync()</p><p>supply有供应的意思，supplyAsync就可以理解为异步供应，查看supplyAsync()方法入参可以知道，其有两个入参：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Supplier supplier,</span><br><span class="line">Executor executor</span><br></pre></td></tr></table></figure><p>这里先简单介绍下Supplier接口，Supplier接口是JDK8引入的新特性，它也是用于创建对象的，只不过调用Supplier的get()方法时，才会去通过构造方法去创建对象，并且每次创建出的对象都不一样。Supplier常用语法为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Supplier&lt;MySupplier&gt; sup= MySupplier::<span class="keyword">new</span>;</span><br></pre></td></tr></table></figure><p>1<br>再展示代码例子之前，再讲一个thenAccept()方法，可以发现thenAccept()方法的入参如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Comsumer&lt;? <span class="keyword">super</span> T&gt;</span><br><span class="line">Comsumer接口同样是java8新引入的特性，它有两个重要接口方法：</span><br><span class="line"></span><br><span class="line">accept()</span><br><span class="line">andThen()</span><br><span class="line">thenAccept()可以理解为接收CompletableFuture的结果然后再进行处理。</span><br></pre></td></tr></table></figure><p>下面看下supplyAsync()和thenAccept()的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">thenApply</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        CompletableFuture cf = CompletableFuture.supplyAsync(() -&gt; &#123; <span class="comment">//实现了Supplier的get()方法</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"supplyAsync "</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"hello "</span>;</span><br><span class="line">        &#125;,executorService).thenAccept(s -&gt; &#123; <span class="comment">//实现了Comsumper的accept()方法</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                thenApply_test(s + <span class="string">"world"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cf.isDone()) &#123;</span><br><span class="line">                System.out.println(<span class="string">"CompletedFuture...isDown"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main</span><br><span class="line">supplyAsync pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">thenApply_test hello world</span><br><span class="line">thenApply_test pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br></pre></td></tr></table></figure><p>从代码逻辑可以看出，thenApply_test等到了pool-1-thread-1线程完成任务后，才进行的调用，并且拿到了supplye()方法返回的结果，而main则异步执行了，这就避免了Future获取结果时需要阻塞或轮询的弊端。<br>exceptionally<br>当任务在执行过程中报错了咋办？exceptionally()方法很好的解决了这个问题，当报错时会去调用exceptionally()方法，它的入参为：Function&lt;Throwable, ? extends T&gt; fn，fn为执行任务报错时的回调方法，下面看看代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionally</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class="line">        CompletableFuture cf = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"测试exceptionally..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"s1"</span>;</span><br><span class="line">        &#125;, executorService).exceptionally(e -&gt; &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"helloworld "</span> + e.getMessage();</span><br><span class="line">        &#125;);</span><br><span class="line">        cf.thenAcceptAsync(s -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"thenAcceptAsync: "</span> + s);</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">"main: "</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main: main</span><br><span class="line">java.lang.RuntimeException: 测试exceptionally…</span><br><span class="line">CompletableFuture is Down…helloworld java.lang.RuntimeException: 测试exceptionally…</span><br><span class="line">thenAcceptAsync: helloworld java.lang.RuntimeException: 测试exceptionally…</span><br></pre></td></tr></table></figure><p>从代码以及运行结果来看，当任务执行过程中报错时会执行exceptionally()中的代码，thenAcceptAsync()会获取抛出的异常并输出到控制台，不管CompletableFuture()执行过程中报错、正常完成、还是取消，都会被标示为已完成，所以最后CompletableFuture.isDown()为true。</p><p>在Java8中，新增的ForkJoinPool.commonPool()方法，这个方法可以获得一个公共的ForkJoin线程池，这个公共线程池中的所有线程都是Daemon线程，意味着如果主线程退出，这些线程无论是否执行完毕，都会退出系统。</p><p>2.3 源码分析<br>CompletableFuture类实现了Future接口和CompletionStage接口，Future大家都经常遇到，但是这个CompletionStage接口就有点陌生了，这里的CompletionStage实际上是一个任务执行的一个“阶段”，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompletableFuture</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Future</span>&lt;<span class="title">T</span>&gt;, <span class="title">CompletionStage</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">volatile</span> Object result;       <span class="comment">// CompletableFuture的结果值或者是一个异常的报装对象AltResult</span></span><br><span class="line">    <span class="keyword">volatile</span> Completion stack;    <span class="comment">// 依赖操作栈的栈顶</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// CompletableFuture的方法</span></span><br><span class="line">    ... </span><br><span class="line"><span class="comment">// Unsafe mechanics</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> RESULT;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> STACK;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> NEXT;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> sun.misc.Unsafe u;</span><br><span class="line">            UNSAFE = u = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            Class&lt;?&gt; k = CompletableFuture<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">            RESULT = u.objectFieldOffset(k.getDeclaredField(<span class="string">"result"</span>)); <span class="comment">//计算result属性的位偏移量</span></span><br><span class="line">            STACK = u.objectFieldOffset(k.getDeclaredField(<span class="string">"stack"</span>)); <span class="comment">//计算stack属性的位偏移量</span></span><br><span class="line">            NEXT = u.objectFieldOffset </span><br><span class="line">                (Completion.class.getDeclaredField("next"));  //计算next属性的位偏移量</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception x) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在CompletableFuture中有一个静态代码块，在CompletableFuture类初始化之前就进行调用，代码块里的内容就是通过Unsafe类去获取CompletableFuture的result、stack和next属性的“偏移量”，这个偏移量主要用于Unsafe的CAS操作时进行位移量的比较。<br>runAsync(Runnable, Executor) &amp; runAsync(Runnable)<br>runAsync()做的事情就是异步的执行任务，返回的是CompletableFuture对象，不过CompletableFuture对象不包含结果。runAsync()方法有两个重载方法，这两个重载方法的区别是Executor可以指定为自己想要使用的线程池，而runAsync(Runnable)则使用的是ForkJoinPool.commonPool()。</p><p>下面先来看看runAsync(Runnable)的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title">runAsync</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> asyncRunStage(asyncPool, runnable);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这里的asyncPool是一个静态的成员变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> useCommonPool =</span><br><span class="line">        (ForkJoinPool.getCommonPoolParallelism() &gt; <span class="number">1</span>); <span class="comment">// 并行级别</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor asyncPool = useCommonPool ?  </span><br><span class="line">ForkJoinPool.commonPool() : <span class="keyword">new</span> ThreadPerTaskExecutor();</span><br></pre></td></tr></table></figure><p>回到asyncRunStage()源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title">asyncRunStage</span><span class="params">(Executor e, Runnable f)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (f == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">       CompletableFuture&lt;Void&gt; d = <span class="keyword">new</span> CompletableFuture&lt;Void&gt;();</span><br><span class="line">       e.execute(<span class="keyword">new</span> AsyncRun(d, f));</span><br><span class="line">       <span class="keyword">return</span> d;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>看到asyncRunStage()源码，可以知道任务是由Executor来执行的，那么可想而知Async类一定是实现了Callable接口或者继承了Runnable类，查看Async类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncRun</span> <span class="keyword">extends</span> <span class="title">ForkJoinTask</span>&lt;<span class="title">Void</span>&gt;</span></span><br><span class="line"><span class="class">            <span class="keyword">implements</span> <span class="title">Runnable</span>, <span class="title">AsynchronousCompletionTask</span> </span>&#123;</span><br><span class="line">        CompletableFuture&lt;Void&gt; dep; Runnable fn;</span><br><span class="line">        AsyncRun(CompletableFuture&lt;Void&gt; dep, Runnable fn) &#123;</span><br><span class="line">            <span class="keyword">this</span>.dep = dep; <span class="keyword">this</span>.fn = fn;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Void <span class="title">getRawResult</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">null</span>; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setRawResult</span><span class="params">(Void v)</span> </span>&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">exec</span><span class="params">()</span> </span>&#123; run(); <span class="keyword">return</span> <span class="keyword">true</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            CompletableFuture&lt;Void&gt; d; Runnable f;</span><br><span class="line">            <span class="keyword">if</span> ((d = dep) != <span class="keyword">null</span> &amp;&amp; (f = fn) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                dep = <span class="keyword">null</span>; fn = <span class="keyword">null</span>;<span class="comment">//释放掉内存</span></span><br><span class="line">                <span class="keyword">if</span> (d.result == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        f.run();</span><br><span class="line">                        d.completeNull();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                        d.completeThrowable(ex);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                d.postComplete(); <span class="comment">// 任务结束后，会执行所有依赖此任务的其他任务，这些任务以一个无锁并发栈的形式存在</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在AsyncRun类中，实现了Runnable接口的run()方法，在run()方法内部，会调用传进来的Runnable对象的run()方法，这里就需要用户自己去实现了，上文中的实例代码就是通过Lambda表达式来实现了Runnable接口。调用了f.run()之后，然后就是completeNull()方法了，改方法底层通过调用UNSAFE类的compareAndSwapObject()方法，来以CAS的方式将CompletableFuture的结果赋为null。postComplete()就是任务结束后，会执行所有依赖此任务的其他任务，这些任务以一个无锁并发栈的形式存在。<br>postComplete()的源码还是有点复杂的，先不急着分析。先看看Completion这个抽象类的数据结构组成：</p><p>Completion<br>下面先看看Completion的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Completion</span> <span class="keyword">extends</span> <span class="title">ForkJoinTask</span>&lt;<span class="title">Void</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Runnable</span>, <span class="title">AsynchronousCompletionTask</span> </span>&#123;</span><br><span class="line">        <span class="keyword">volatile</span> Completion next;      </span><br><span class="line">        <span class="keyword">abstract</span> CompletableFuture&lt;?&gt; tryFire(<span class="keyword">int</span> mode);</span><br><span class="line">        <span class="function"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">isLive</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span>                </span>&#123; tryFire(ASYNC); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">exec</span><span class="params">()</span>            </span>&#123; tryFire(ASYNC); <span class="keyword">return</span> <span class="keyword">true</span>; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Void <span class="title">getRawResult</span><span class="params">()</span>       </span>&#123; <span class="keyword">return</span> <span class="keyword">null</span>; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setRawResult</span><span class="params">(Void v)</span> </span>&#123;&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Completion是一个抽象类，分别实现了Runnable、AsynchronousCompletionTask接口，继承了ForkJoinPoolTask类，而ForJoinPoolTask抽象类又实现了Future接口，因此Completion实际上就是一个Future。可以看到Completion的抽象方法和成员方法的实现逻辑都短短一行或者没有，可以猜到这些方法的实现都是在其子类中。其实现类包括了UniCompletion、BiCompletion、UniAccept、BiAccept等，如下图：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/complete1.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>而Completion类中还有一个非常重要的成员属性</p><p>volatile Completion next;<br>1<br>有印象的读者应该能记得，CompletableFuture中有一个属性——stack，就是Completion类的。</p><p>volatile Completion stack;<br>1<br>由这个属性可以看出，CompletableFuture其实就是一个链表的一个数据结构。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UniCompletion</span>&lt;<span class="title">T</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Completion</span> </span>&#123;</span><br><span class="line">        Executor executor;                 <span class="comment">// executor to use (null if none)</span></span><br><span class="line">        CompletableFuture&lt;V&gt; dep;          <span class="comment">// 代表的依赖的CompletableFuture</span></span><br><span class="line">        CompletableFuture&lt;T&gt; src;          <span class="comment">// 代表的是源CompletableFuture</span></span><br><span class="line"></span><br><span class="line">        UniCompletion(Executor executor, CompletableFuture&lt;V&gt; dep,</span><br><span class="line">                      CompletableFuture&lt;T&gt; src) &#123;</span><br><span class="line">            <span class="keyword">this</span>.executor = executor; <span class="keyword">this</span>.dep = dep; <span class="keyword">this</span>.src = src;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 确保当前Completion可以被调用；并且使用ForkJoinPool标记为来确保只有一个线程可以调用，</span></span><br><span class="line"><span class="comment">         * 如果是异步的，则在任务启动之后通过tryFire来进行调用。tryFire方法时在UniAccept类中。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">claim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Executor e = executor;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetForkJoinTaskTag((<span class="keyword">short</span>)<span class="number">0</span>, (<span class="keyword">short</span>)<span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                executor = <span class="keyword">null</span>; <span class="comment">// disable</span></span><br><span class="line">                e.execute(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isLive</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> dep != <span class="keyword">null</span>; &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>claim方法要在执行action前调用，若claim方法返回false，则不能调用action，原则上要保证action只执行一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">UniAccept</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">UniCompletion</span>&lt;<span class="title">T</span>,<span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line">        Consumer&lt;? <span class="keyword">super</span> T&gt; fn;</span><br><span class="line">        UniAccept(Executor executor, CompletableFuture&lt;Void&gt; dep,</span><br><span class="line">                  CompletableFuture&lt;T&gt; src, Consumer&lt;? <span class="keyword">super</span> T&gt; fn) &#123;</span><br><span class="line">            <span class="keyword">super</span>(executor, dep, src); <span class="keyword">this</span>.fn = fn;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 尝试去调用当前任务。uniAccept()方法为核心逻辑。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> CompletableFuture&lt;Void&gt; <span class="title">tryFire</span><span class="params">(<span class="keyword">int</span> mode)</span> </span>&#123;</span><br><span class="line">            CompletableFuture&lt;Void&gt; d; CompletableFuture&lt;T&gt; a;</span><br><span class="line">            <span class="keyword">if</span> ((d = dep) == <span class="keyword">null</span> ||</span><br><span class="line">                !d.uniAccept(a = src, fn, mode &gt; <span class="number">0</span> ? <span class="keyword">null</span> : <span class="keyword">this</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            dep = <span class="keyword">null</span>; src = <span class="keyword">null</span>; fn = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> d.postFire(a, mode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> &lt;S&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">uniAccept</span><span class="params">(CompletableFuture&lt;S&gt; a,</span></span></span><br><span class="line"><span class="function"><span class="params">                                Consumer&lt;? <span class="keyword">super</span> S&gt; f, UniAccept&lt;S&gt; c)</span> </span>&#123;</span><br><span class="line">        Object r; Throwable x;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="keyword">null</span> || (r = a.result) == <span class="keyword">null</span> || f == <span class="keyword">null</span>) <span class="comment">//判断源任务是否已经完成了，a表示的就是源任务，a.result就代表的是原任务的结果。</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        tryComplete: <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r <span class="keyword">instanceof</span> AltResult) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((x = ((AltResult)r).ex) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    completeThrowable(x, r);</span><br><span class="line">                    <span class="keyword">break</span> tryComplete;</span><br><span class="line">                &#125;</span><br><span class="line">                r = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; !c.claim())</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) S s = (S) r;</span><br><span class="line">                f.accept(s);  <span class="comment">//去调用Comsumer</span></span><br><span class="line">                completeNull();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                completeThrowable(ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>对于Completion的执行，还有几个关键的属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SYNC   =  <span class="number">0</span>;<span class="comment">//同步</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ASYNC  =  <span class="number">1</span>;<span class="comment">//异步</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NESTED = -<span class="number">1</span>;<span class="comment">//嵌套</span></span><br></pre></td></tr></table></figure><p>Completion在CompletableFuture中是如何工作的呢？现在先不着急了解其原理，下面再去看下一个重要的接口——CompletionStage。</p><p>CompletionStage<br>下面介绍下CompletionStage接口。看字面意思可以理解为“完成动作的一个阶段”，查看官方注释文档：CompletionStage是一个可能执行异步计算的“阶段”，这个阶段会在另一个CompletionStage完成时调用去执行动作或者计算，一个CompletionStage会以正常完成或者中断的形式“完成”，并且它的“完成”会触发其他依赖的CompletionStage。CompletionStage 接口的方法一般都返回新的CompletionStage，因此构成了链式的调用。<br>【下文中Stage代表CompletionStage】</p><p>那么在Java中什么是CompletionStage呢？<br>官方定义中，一个Function，Comsumer或者Runnable都会被描述为一个CompletionStage，相关方法比如有apply，accept，run等，这些方法的区别在于它们有些是需要传入参，有些则会产生“结果”。</p><p>Funtion方法会产生结果<br>Comsumer会消耗结果<br>Runable既不产生结果也不消耗结果<br>下面看看一个Stage的调用例子：</p><p>stage.thenApply(x -&gt; square(x)).thenAccept(x -&gt; System.out.println(x)).thenRun(() -&gt; System.out.println())<br>1<br>这里x -&gt; square(x)就是一个Function类型的Stage，它返回了x。x -&gt; System.out.println(x)就是一个Comsumer类型的Stage，用于接收上一个Stage的结果x。() -&gt;System.out.println()就是一个Runnable类型的Stage，既不消耗结果也不产生结果。</p><p>一个、两个或者任意一个CompletionStage的完成都会触发依赖的CompletionStage的执行，CompletionStage的依赖动作可以由带有then的前缀方法来实现。如果一个Stage被两个Stage的完成给触发，则这个Stage可以通过相应的Combine方法来结合它们的结果，相应的Combine方法包括：thenCombine、thenCombineAsync。但如果一个Stage是被两个Stage中的其中一个触发，则无法去combine它们的结果，因为这个Stage无法确保这个结果是那个与之依赖的Stage返回的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCombine</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       String result = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">       &#125;).thenCombine(CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="string">" world"</span>;</span><br><span class="line">       &#125;), (s1, s2) -&gt; s1 + <span class="string">" "</span> + s2).join();</span><br><span class="line"></span><br><span class="line">       System.out.println(result);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>虽然Stage之间的依赖关系可以控制触发计算，但是并不能保证任何的顺序。</p><p>另外，可以用一下三种的任何一种方式来安排一个新Stage的计算：default execution、default asynchronous execution（方法后缀都带有async）或者custom（自定义一个executor）。默认和异步模式的执行属性由CompletionStage实现而不是此接口指定。</p><p>小结：CompletionStage确保了CompletableFuture能够进行链式调用。</p><p>下面开始介绍CompletableFuture的几个核心方法：</p><p>postComplete</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">postComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CompletableFuture&lt;?&gt; f = <span class="keyword">this</span>; Completion h;    <span class="comment">//this表示当前的CompletableFuture</span></span><br><span class="line">        <span class="keyword">while</span> ((h = f.stack) != <span class="keyword">null</span> ||                                  <span class="comment">//判断stack栈是否为空</span></span><br><span class="line">               (f != <span class="keyword">this</span> &amp;&amp; (h = (f = <span class="keyword">this</span>).stack) != <span class="keyword">null</span>)) &#123;    </span><br><span class="line">            CompletableFuture&lt;?&gt; d; Completion t;      </span><br><span class="line">            <span class="keyword">if</span> (f.casStack(h, t = h.next)) &#123;                          <span class="comment">//通过CAS出栈，</span></span><br><span class="line">                <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (f != <span class="keyword">this</span>) &#123;</span><br><span class="line">                        pushStack(h);             <span class="comment">//如果f不是this，将刚出栈的h入this的栈顶</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    h.next = <span class="keyword">null</span>;    <span class="comment">// detach   帮助GC</span></span><br><span class="line">                &#125;</span><br><span class="line">                f = (d = h.tryFire(NESTED)) == <span class="keyword">null</span> ? <span class="keyword">this</span> : d;        <span class="comment">//调用tryFire</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>postComplete()方法可以理解为当任务完成之后，调用的一个“后完成”方法，主要用于触发其他依赖任务。</p><p>uniAccept</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> &lt;S&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">uniAccept</span><span class="params">(CompletableFuture&lt;S&gt; a,</span></span></span><br><span class="line"><span class="function"><span class="params">                                Consumer&lt;? <span class="keyword">super</span> S&gt; f, UniAccept&lt;S&gt; c)</span> </span>&#123;</span><br><span class="line">        Object r; Throwable x;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="keyword">null</span> || (r = a.result) == <span class="keyword">null</span> || f == <span class="keyword">null</span>)    <span class="comment">//判断当前CompletableFuture是否已完成，如果没完成则返回false；如果完成了则执行下面的逻辑。</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        tryComplete: <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r <span class="keyword">instanceof</span> AltResult) &#123;   <span class="comment">//判断任务结果是否是AltResult类型</span></span><br><span class="line">                <span class="keyword">if</span> ((x = ((AltResult)r).ex) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    completeThrowable(x, r);</span><br><span class="line">                    <span class="keyword">break</span> tryComplete;</span><br><span class="line">                &#125;</span><br><span class="line">                r = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; !c.claim()) <span class="comment">//判断当前任务是否可以执行</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) S s = (S) r;   <span class="comment">//获取任务结果</span></span><br><span class="line">                f.accept(s);    <span class="comment">//执行Comsumer</span></span><br><span class="line">                completeNull();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                completeThrowable(ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里有一个很巧妙的地方，就是uniAccept的入参中，CompletableFuture a表示的是源任务，UniAccept c中报装有依赖的任务，这点需要清除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pushStack</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">pushStack</span><span class="params">(Completion c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (!tryPushStack(c));      <span class="comment">//使用CAS自旋方式压入栈，避免了加锁竞争</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryPushStack</span><span class="params">(Completion c)</span> </span>&#123;</span><br><span class="line">        Completion h = stack;         </span><br><span class="line">        lazySetNext(c, h);   <span class="comment">//将当前stack设置为c的next</span></span><br><span class="line">        <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, STACK, h, c); <span class="comment">//尝试把当前栈（h）更新为新值（c）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lazySetNext</span><span class="params">(Completion c, Completion next)</span> </span>&#123;</span><br><span class="line">        UNSAFE.putOrderedObject(c, NEXT, next);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>光分析源码也没法深入理解其代码原理，下面结合一段示例代码来对代码原理进行分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">thenApply</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">       CompletableFuture cf = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//休眠200秒</span></span><br><span class="line">               Thread.sleep(<span class="number">200000</span>);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">           System.out.println(<span class="string">"supplyAsync "</span> + Thread.currentThread().getName());</span><br><span class="line">           <span class="keyword">return</span> <span class="string">"hello "</span>;</span><br><span class="line">       &#125;,executorService).thenAccept(s -&gt; &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               thenApply_test(s + <span class="string">"world"</span>);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       System.out.println(Thread.currentThread().getName());</span><br><span class="line">       <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (cf.isDone()) &#123;</span><br><span class="line">               System.out.println(<span class="string">"CompletedFuture...isDown"</span>);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 运行结果：</span></span><br><span class="line"><span class="comment">    main</span></span><br><span class="line"><span class="comment">    supplyAsync pool-1-thread-1</span></span><br><span class="line"><span class="comment">    thenApply_test hello world</span></span><br><span class="line"><span class="comment">    thenApply_test pool-1-thread-1</span></span><br><span class="line"><span class="comment">    CompletedFuture...isDown</span></span><br><span class="line"><span class="comment">    */</span></span><br></pre></td></tr></table></figure><p>这段示例代码所做的事情就是supplyAsync(Supplier supplier)休眠200秒之后，返回一个字符串，thenAccept(Consumer&lt;? super T&gt; action)等到任务完成之后接收这个字符串，并且调用thenApply_test()方法，随后输出 hello world。<br>代码中让线程休眠200秒是为了方便观察CompletableFuture的传递过程。</p><p>下面就描述下程序的整个运作流程。<br>① 主线程调用CompletableFuture的supplyAsync()方法，传入Supplier和Executor。在supplyAsync()中又继续调用CompletableFuture的asyncSupplyStage(Executor, Supplier)方法。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/complete2.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>来到asyncSupplyStage()方法中，调用指定的线程池，并执行execute(new AsyncSupply(d,f))，这里d就是我们的“源任务”，接下来thenApply()要依赖着这个源任务进行后续逻辑操作，f就是Supplier的函数式编程。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/complete3.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>AsyncSupply实现了Runnable的run()方法，核心逻辑就在run()方法里。在run()方法里，先判断d.result == null，判断该任务是否已经完成，防止并发情况下其他线程完成此任务了。f.get()就是调用的Supplier的函数式编程，这里会休眠200秒，所以executor线程池开启的线程会在这里阻塞200秒。</p><p>② 虽然executor线程池线程阻塞了，但是main线程任然会继续执行接下来的代码。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/complete4.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>main线程会在asyncSupplyStage()方法中返回d，就是我们的“依赖任务”，而这个任务此时还处在阻塞中。接下来main线程会继续执行CompletableFuture的thenAccept(Comsumer&lt;? super T&gt; action)方法，然后调用CompletableFuture的uniAcceptStage()方法。<br>在这里插入图片描述<br>在uniAcceptStage()方法中，会将“依赖任务”、“源任务”、线程池以及Comsumer报装程一个UniAccept对象，然后调用push()压入stack的栈顶中。随后调用UniAccept的tryFire()方法。<br>在这里插入图片描述<br>其中的CompletableFuture的uniAccept()方法会判断任务是否完成，判断依据是a.result 是否为空，这里的a就是之前传入的“源任务”，等到“源任务”阻塞200秒过后，就会完成任务，并将字符串存入到 result中。<br>在这里插入图片描述<br>判断到“源任务”完成之后，就会调用接下来的逻辑。s拿到的值就是“源”任务返回的字符串，并且传入到了Comsumer.accept()方法中。然而“源任务”还在阻塞中，main线程会跳出uniAccept()，继续执行接下来的逻辑。接下来就是输出当前线程的名字，然后调用while(true)，结束条件为CompletableFuture.isDone()，当任务完成时则结束while(true)循环。</p><p>③ 回到“源任务”，虽然main线程已经结束了整个生命周期，但是executor线程池的线程任然阻塞着的，休眠了200秒之后，继续执行任务。<br>在这里插入图片描述<br>然后来到了postComplete()方法。这个方法在前面已经介绍到了，它是CompletableFuture的核心方法之一，做了许多事情。最重要的一件事情就是触发其他依赖任务，接下来调用的方法依次为：UniAccept.tryFire(mode) ——&gt; CompletableFuture.uniAccept(…) ——&gt; Comsumer.accept(s) ——&gt; 输出“hello world”，并输出当前调用线程的线程名。因这个调用链已经在②中介绍过了，所以就不再详细介绍其运作逻辑。<br>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">      runAsync();</span><br><span class="line">      supplyAsync();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//无返回值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runAsync</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        CompletableFuture&lt;Void&gt; future = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"run end ..."</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        future.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有返回值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">supplyAsync</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        CompletableFuture&lt;Long&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"run end ..."</span>);</span><br><span class="line">            <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> time = future.get();</span><br><span class="line">        System.out.println(<span class="string">"time = "</span>+time);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">run end ...</span><br><span class="line">run end ...</span><br><span class="line">time = <span class="number">1596010020281</span></span><br></pre></td></tr></table></figure><p>小结： 通过这个小示例，终于理解到了“源任务”和“依赖任务”之间的调用关系，以及CompletableFuture的基本运作原理。然而CompletableFuture还有其他的方法需要去深入分析，由于篇幅所限就不再赘述，感兴趣的读者可以以debug的模式去一点一点分析CompletableFuture其他方法的底层原理。这里不得不说Java并发包作者Doug Lea大神真的太厉害了，阅读他的源码之后，可以发现他写的代码不能以技术来形容，而应该使用“艺术”来形容。</p><p>总结<br>CompletableFuture底层由于借助了魔法类Unsafe的相关CAS方法，除了get或join结果之外，其他方法都实现了无锁操作。<br>CompletableFuture实现了CompletionStage接口，因而具备了链式调用的能力，CompletionStage提供了either、apply、run以及then等相关方法，使得CompletableFuture可以使用各种应用场景。<br>CompletableFuture中有“源任务”和“依赖任务”，“源任务”的完成能够触发“依赖任务”的执行，这里的完成可以是返回正常结果或者是异常。<br>CompletableFuture默认使用ForkJoinPool，也可以使用指定线程池来执行任务。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;想学习CompletableFuture，因此查询资料发现&lt;br&gt;CompletableFuture是JDK8中的新特性，主要用于对JDK5中加入的Future的补充。&lt;br&gt;CompletableFuture实现了CompletionStage和Future接口。&lt;br&gt;
      
    
    </summary>
    
    
    
      <category term="CompletableFuture" scheme="http://kkget.github.io/tags/CompletableFuture/"/>
    
  </entry>
  
  <entry>
    <title>优雅永不过时</title>
    <link href="http://kkget.github.io/2020/07/22/%E4%BC%98%E9%9B%85%E6%B0%B8%E4%B8%8D%E8%BF%87%E6%97%B6/"/>
    <id>http://kkget.github.io/2020/07/22/%E4%BC%98%E9%9B%85%E6%B0%B8%E4%B8%8D%E8%BF%87%E6%97%B6/</id>
    <published>2020-07-22T09:12:30.000Z</published>
    <updated>2020-10-23T03:22:29.713Z</updated>
    
    <content type="html"><![CDATA[<p>无论是日常编码，还是业务涉及，能够优雅的表达思想，提高代码简洁度，阅读性都是一种能力，总结一下优雅的做法</p><h1 id="优雅的关闭流"><a href="#优雅的关闭流" class="headerlink" title="优雅的关闭流"></a>优雅的关闭流</h1><p>java7 try with resource，针对实现了AutoCloseable接口的类，都可优雅的关闭流，从而舍弃finally关闭</p><p>try catch finally</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader in = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">....</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (in != <span class="keyword">null</span>) &#123;</span><br><span class="line">in.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e2) &#123;</span><br><span class="line">e2.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>try  winth resource</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="keyword">final</span> BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader((<span class="keyword">new</span> URL(url + <span class="string">"?"</span> + param)).openConnection().getInputStream()));PrintWriter out =<span class="keyword">new</span> PrintWriter(response.getWriter()))&#123;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;<span class="keyword">catch</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Netty-优雅的关闭流程"><a href="#Netty-优雅的关闭流程" class="headerlink" title="Netty 优雅的关闭流程"></a>Netty 优雅的关闭流程</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shutdownGracefully()</span><br></pre></td></tr></table></figure><h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><p>list求交集</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Long&gt; collect = list1.stream().filter(list2::contains).collect(Collectors.toList());</span><br></pre></td></tr></table></figure><h1 id="设计模式代替if-else-策略模式，模板模式"><a href="#设计模式代替if-else-策略模式，模板模式" class="headerlink" title="设计模式代替if else,策略模式，模板模式"></a>设计模式代替if else,策略模式，模板模式</h1><h1 id="代码整洁度，例如多注入service，按着高矮胖瘦排列，视觉舒适，controller求求你别写业务代码了"><a href="#代码整洁度，例如多注入service，按着高矮胖瘦排列，视觉舒适，controller求求你别写业务代码了" class="headerlink" title="代码整洁度，例如多注入service，按着高矮胖瘦排列，视觉舒适，controller求求你别写业务代码了"></a>代码整洁度，例如多注入service，按着高矮胖瘦排列，视觉舒适，controller求求你别写业务代码了</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  List <span class="title">getRandomList</span><span class="params">(List&lt;?&gt; paramList,<span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(count==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Random random=<span class="keyword">new</span> Random();</span><br><span class="line">        List&lt;Integer&gt; tempList=<span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//临时存放产生的list索引，去除重复的索引</span></span><br><span class="line">        List newList=<span class="keyword">new</span> ArrayList();<span class="comment">//生成新的list集合</span></span><br><span class="line">        <span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(count&lt;=<span class="number">1</span>)&#123;<span class="comment">//如果数据小于1，取一条数据</span></span><br><span class="line">            temp = random.nextInt(paramList.size());</span><br><span class="line">            newList.add(paramList.get(temp));</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Math.ceil(count);i++)&#123;</span><br><span class="line">                temp=random.nextInt(paramList.size());<span class="comment">//初始化一个随机数，将产生的随机数作为被抽list的索引</span></span><br><span class="line">                <span class="keyword">if</span>(!tempList.contains(temp))&#123;<span class="comment">//判断随机抽取的随机数</span></span><br><span class="line">                    tempList.add(temp);</span><br><span class="line">                    newList.add(paramList.get(temp));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    i--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newList;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="优雅判空"><a href="#优雅判空" class="headerlink" title="优雅判空"></a>优雅判空</h1><p>个人喜欢Assert判空，至于java8的Optional并没体会到优雅之处，日常StringUtils，Collections，isNoBlank等，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testOptional</span><span class="params">(Test test)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.ofNullable(test).flatMap(Test::getTest3)</span><br><span class="line">                .flatMap(Test3::getTest2)</span><br><span class="line">                .map(Test2::getInfo)</span><br><span class="line">                .orElse(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">看起来挺优雅，但日常没体会到</span><br></pre></td></tr></table></figure><p>还有日常常用的instanceof</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">        validated = <span class="keyword">true</span>;</span><br><span class="line">        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">        TreeNode&lt;K,V&gt; r, p;</span><br><span class="line">        <span class="keyword">if</span> ((r = t.root) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            (p = r.findTreeNode(hash, key, <span class="keyword">null</span>)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            V pv = p.val;</span><br><span class="line">            <span class="keyword">if</span> (cv == <span class="keyword">null</span> || cv == pv ||</span><br><span class="line">                (pv != <span class="keyword">null</span> &amp;&amp; cv.equals(pv))) &#123;</span><br><span class="line">                oldVal = pv;</span><br><span class="line">                <span class="keyword">if</span> (value != <span class="keyword">null</span>)</span><br><span class="line">                    p.val = value;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (t.removeTreeNode(p))</span><br><span class="line">                    setTabAt(tab, i, untreeify(t.first));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;无论是日常编码，还是业务涉及，能够优雅的表达思想，提高代码简洁度，阅读性都是一种能力，总结一下优雅的做法&lt;/p&gt;
&lt;h1 id=&quot;优雅的关闭流&quot;&gt;&lt;a href=&quot;#优雅的关闭流&quot; class=&quot;headerlink&quot; title=&quot;优雅的关闭流&quot;&gt;&lt;/a&gt;优雅的关闭流&lt;/
      
    
    </summary>
    
    
    
      <category term="代码优化" scheme="http://kkget.github.io/tags/%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>面试题---小马哥次灵均阁</title>
    <link href="http://kkget.github.io/2020/07/21/java%E5%B8%B8%E8%A7%8110%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%B0%8F%E9%A9%AC%E5%93%A5/"/>
    <id>http://kkget.github.io/2020/07/21/java%E5%B8%B8%E8%A7%8110%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%B0%8F%E9%A9%AC%E5%93%A5/</id>
    <published>2020-07-21T06:40:31.000Z</published>
    <updated>2020-09-30T08:42:57.221Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java允许多继承吗？"><a href="#java允许多继承吗？" class="headerlink" title="java允许多继承吗？"></a>java允许多继承吗？</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/Q2.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>必须针对Autocloseable<br>FileInputStream   最终继承Autocloseable<br>找到字节码文件  javap -p  -v  .class<br>invokrvitrual   java 7编译器做的字节码提升</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/Q3.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>intern   reference   unique<br>B</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/Q3-1.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>//变量，对象，引用<br>//变量：局部变量，成员变量(实例，static)，lable标签（变量名称，变量类型，引用指向）<br>//对象：java  Heap new 实例<br>//引用：强软弱虚</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/Q4.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>D<br>Finally 除了JVM退出  都会执行<br>如果Boolean flag=null;</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/Q5.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>muti -catch 无法使用子类关联<br>RuntimeException  非checked 异常  不需要throws</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/Q7.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>CopyOnwriteArrayList</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/Q8.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/Q8-1.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/Q8-2.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/Q9.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>否</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/Q8-4.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/Q8-5.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/Q10.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>D</p><h1 id="HashMap并发读是线程安全的"><a href="#HashMap并发读是线程安全的" class="headerlink" title="HashMap并发读是线程安全的"></a>HashMap并发读是线程安全的</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/Q10-1.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/Q10-2.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>//合理关闭线程池<br>//Daemon线程</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;java允许多继承吗？&quot;&gt;&lt;a href=&quot;#java允许多继承吗？&quot; class=&quot;headerlink&quot; title=&quot;java允许多继承吗？&quot;&gt;&lt;/a&gt;java允许多继承吗？&lt;/h1&gt;&lt;figure class=&quot;image-bubble&quot;&gt;
       
      
    
    </summary>
    
    
    
      <category term="面经" scheme="http://kkget.github.io/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>编程算法题</title>
    <link href="http://kkget.github.io/2020/07/08/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    <id>http://kkget.github.io/2020/07/08/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95%E9%A2%98/</id>
    <published>2020-07-08T01:36:18.000Z</published>
    <updated>2020-09-30T08:44:17.825Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一：力扣第14题-编写一个函数来查找字符串数组中的最长公共前缀"><a href="#一：力扣第14题-编写一个函数来查找字符串数组中的最长公共前缀" class="headerlink" title="一：力扣第14题 编写一个函数来查找字符串数组中的最长公共前缀"></a>一：力扣第14题 编写一个函数来查找字符串数组中的最长公共前缀</h1><p>官方解法：<br>##方法一：<strong>横向扫描</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/leetcode/1.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/leetcode/2.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>如果在尚未遍历完所有的字符串时，最长公共前缀已经是空串，则最长公共前缀一定是空串，因此不需要继续遍历剩下的字符串，直接返回空串即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String prefix = strs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> count = strs.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; count; i++) &#123;</span><br><span class="line">            prefix = longestCommonPrefix(prefix, strs[i]);</span><br><span class="line">            <span class="keyword">if</span> (prefix.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prefix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = Math.min(str1.length(), str2.length());</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; length &amp;&amp; str1.charAt(index) == str2.charAt(index)) &#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str1.substring(<span class="number">0</span>, index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析<br>时间复杂度：O(mn)O(mn)，其中 mm 是字符串数组中的字符串的平均长度，nn 是字符串的数量。最坏情况下，字符串数组中的每个字符串的每个字符都会被比较一次。<br>空间复杂度：O(1)O(1)。使用的额外空间复杂度为常数。<br>作者：LeetCode-Solution<br>链接：<a href="https://leetcode-cn.com/problems/longest-common-prefix/solution/zui-chang-gong-gong-qian-zhui-by-leetcode-solution/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-common-prefix/solution/zui-chang-gong-gong-qian-zhui-by-leetcode-solution/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><hr><p>#leetcode  用户灵魂画手<br><strong><em>思路</em></strong><br>标签：链表<br>当字符串数组长度为 0 时则公共前缀为空，直接返回<br>令最长公共前缀 ans 的值为第一个字符串，进行初始化<br>遍历后面的字符串，依次将其与 ans 进行比较，两两找出公共前缀，最终结果即为最长公共前缀<br>如果查找过程中出现了 ans 为空的情况，则公共前缀不存在直接返回<br>时间复杂度：O(s)O(s)，s 为所有字符串的长度之和<br><strong><em>代码</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(strs.length == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        String ans = strs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>;i&lt;strs.length;i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(;j&lt;ans.length() &amp;&amp; j &lt; strs[i].length();j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(ans.charAt(j) != strs[i].charAt(j))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = ans.substring(<span class="number">0</span>, j);</span><br><span class="line">            <span class="keyword">if</span>(ans.equals(<span class="string">""</span>))</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作者：guanpengchn<br>链接：<a href="https://leetcode-cn.com/problems/longest-common-prefix/solution/hua-jie-suan-fa-14-zui-chang-gong-gong-qian-zhui-b/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-common-prefix/solution/hua-jie-suan-fa-14-zui-chang-gong-gong-qian-zhui-b/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>#最易理解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        String s=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> judge=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(strs.length==<span class="number">0</span>)&#123;<span class="comment">//数组为空直接返回""</span></span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;strs[<span class="number">0</span>].length();i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> a=strs[<span class="number">0</span>].charAt(i);<span class="comment">//直接选择第一个数组元素，依次取这个字符串的字符</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;strs.length;j++)&#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(i&gt;=strs[j].length())&#123;<span class="comment">//因为每个字符串长度不同，防止溢出</span></span><br><span class="line">                    judge=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(a!=strs[j].charAt(i))&#123;</span><br><span class="line">                    judge=<span class="number">0</span>;<span class="comment">//只要存在不同，直接退出</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j==strs.length-<span class="number">1</span>)&#123;</span><br><span class="line">                        s=s+a;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(judge==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">版权声明：本文为博主原创文章，遵循 CC <span class="number">4.0</span> BY-SA 版权协议，转载请附上原文出处链接和本声明。</span><br><span class="line">本文链接：https:<span class="comment">//blog.csdn.net/shancx/article/details/82746264</span></span><br></pre></td></tr></table></figure><h1 id="二：未排序正整数数组中累加和为给定值的最长子数组长度"><a href="#二：未排序正整数数组中累加和为给定值的最长子数组长度" class="headerlink" title="二：未排序正整数数组中累加和为给定值的最长子数组长度"></a>二：未排序正整数数组中累加和为给定值的最长子数组长度</h1><p>给定一个数组arr，该数组无序，每个数正数，给定一个K，求arr的所有子数组中所有元素相加和为k的最长子数组的长度。</p><p>例如：arr=[1,2,1,1,1],k=3</p><p>结果是3，[1,1,1]的长度。</p><p>思路：</p><p>首先用两个位置来标记子数组左右两头，记为left与right，开始的时候都在数组的最左边即left=right=0，过程如下：</p><p>1，开始变量left=0，right=0，代表子数组arr[left,right];</p><p>2，变量sum始终表示子数组arr[left,right]的和，开始的时候sum= arr[0],即是arr[0,0]的和；</p><p>3，变量len一直记录累加和为k的所有子数组中最大子数组的长度，开始的时候len=0;</p><p>4，根据sum与k的比较结果决定是left移动还right移动。若干sum==K，说明arr[left,right]累加和为k,如果长度大于len，更新len</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Array;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by wuxiaosi on 2017/9/24.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">getMaxLength</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span>[] arr=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        System.out.println(getMaxLengthK(arr,k));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMaxLengthK</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr==<span class="keyword">null</span>||arr.length==<span class="number">0</span>||k&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum=arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(right&lt;arr.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum==k)&#123;</span><br><span class="line">                len = Math.max(len,right-left+<span class="number">1</span>);</span><br><span class="line">                sum=sum-arr[left++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(sum&lt;k)&#123;</span><br><span class="line">                right++;<span class="comment">//向右移动</span></span><br><span class="line">                <span class="keyword">if</span>(right==arr.length)&#123;<span class="comment">//right到数组边界长度，就break</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                sum=sum+arr[right];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sum=sum-arr[left++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">————————————————</span><br><span class="line">版权声明：本文为CSDN博主「wuxiaosi808」的原创文章，遵循CC <span class="number">4.0</span> BY-SA版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https:<span class="comment">//blog.csdn.net/wuxiaosi808/article/details/78079574</span></span><br></pre></td></tr></table></figure><h1 id="三-有两个整数数组A1，A2，设计函数求其两个数组的最大值和第二大的值"><a href="#三-有两个整数数组A1，A2，设计函数求其两个数组的最大值和第二大的值" class="headerlink" title="三 有两个整数数组A1，A2，设计函数求其两个数组的最大值和第二大的值"></a>三 有两个整数数组A1，A2，设计函数求其两个数组的最大值和第二大的值</h1><p>思路一：</p><p>1.获取最值需要进行比较，每一次比较都会有一个较大的值，因为该值的不确定性，通过一个变量进行临时存储。</p><p>2.让数组中的每一个元素都和这个变量中的值进行比较，如果大于变量中的值，就用该变量记录较大值。</p><p>3.当所有的元素都比较完成，那么该变量中的存储就是数组中的最大值了。</p><p>步骤：</p><p>1.定义变量，初始化为数组中的任意一个元素。</p><p>2.通过循环语句对数组进行遍历。</p><p>3.在变量过程中定义判断条件，如果遍历到的元素比变量中的元素大，就赋值给该变量。</p><p>注意：</p><p>通过定义一个功能来完成，以便提高代码的复用性。该功能结果为数组中的最大元素，未知内容为数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr1 = &#123;<span class="number">9</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">7</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> max1 = getMax(arr1);</span><br><span class="line">System.out.println(<span class="string">"max1="</span>+max1);</span><br><span class="line"><span class="keyword">double</span>[] arr2 = &#123;<span class="number">9.0</span>,<span class="number">5.0</span>,<span class="number">6.0</span>,<span class="number">3.0</span>,<span class="number">1.0</span>,<span class="number">2.0</span>,<span class="number">8.0</span>,<span class="number">7.0</span>&#125;;</span><br><span class="line"><span class="keyword">double</span> max2 = getMax(arr2);</span><br><span class="line">System.out.println(<span class="string">"max2="</span>+max2);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取int类型数组最大值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMax</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(arr[i]&gt;max)</span><br><span class="line">max = arr[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取double类型数组最大值，功能相似，以重载的形式存在</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">getMax</span><span class="params">(<span class="keyword">double</span>[] arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">double</span> max = arr[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(arr[i]&gt;max)</span><br><span class="line">max = arr[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路二：</p><p>1.定义变量，初始化为数组角标0。</p><p>2.通过循环语句对数组进行遍历。</p><p>3.在变量过程中定义判断条件，如果遍历到的元素比角标所在的元素中的数值大，就将较大值的角标赋值给变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr1 = &#123;<span class="number">9</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">7</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> max1 = getMax(arr1);</span><br><span class="line">System.out.println(<span class="string">"max1="</span>+max1);</span><br><span class="line"><span class="keyword">double</span>[] arr2 = &#123;<span class="number">9.0</span>,<span class="number">5.0</span>,<span class="number">6.0</span>,<span class="number">3.0</span>,<span class="number">1.0</span>,<span class="number">2.0</span>,<span class="number">8.0</span>,<span class="number">7.0</span>&#125;;</span><br><span class="line"><span class="keyword">double</span> max2 = getMax(arr2);</span><br><span class="line">System.out.println(<span class="string">"max2="</span>+max2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取int类型数组最大值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMax</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(arr[i]&gt;arr[max])</span><br><span class="line">max = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arr[max];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取double类型数组最大值，功能相似，以重载的形式存在</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">getMax</span><span class="params">(<span class="keyword">double</span>[] arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">double</span> max = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(arr[i]&gt;arr[max])</span><br><span class="line">max = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arr[max];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>————————————————<br>版权声明：本文为CSDN博主「Destiny_lt」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/ytu_lt/article/details/70160598" target="_blank" rel="noopener">https://blog.csdn.net/ytu_lt/article/details/70160598</a></p><h1 id="四-翻转单词顺序列（I-am-a-student-gt-student-a-am-I）"><a href="#四-翻转单词顺序列（I-am-a-student-gt-student-a-am-I）" class="headerlink" title="四 翻转单词顺序列（I am a student.-&gt;student. a am I）"></a>四 翻转单词顺序列（I am a student.-&gt;student. a am I）</h1><p>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student. “，则输出”student. a am I”<br>方法一：双指针<br>算法解析：<br>倒序遍历字符串 ss ，记录单词左右索引边界 ii , jj ；<br>每确定一个单词的边界，则将其添加至单词列表 resres ；<br>最终，将单词列表拼接为字符串，并返回即可。<br>复杂度分析：<br>时间复杂度 O(N)O(N) ： 其中 NN 为字符串 ss 的长度，线性遍历字符串。<br>空间复杂度 O(N)O(N) ： 新建的 list(Python) 或 StringBuilder(Java) 中的字符串总长度 \leq N≤N ，占用 O(N)O(N) 大小的额外空间。<br><strong><em>代码</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        s = s.trim(); <span class="comment">// 删除首尾空格</span></span><br><span class="line">        <span class="keyword">int</span> j = s.length() - <span class="number">1</span>, i = j;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; s.charAt(i) != <span class="string">' '</span>) i--; <span class="comment">// 搜索首个空格</span></span><br><span class="line">            res.append(s.substring(i + <span class="number">1</span>, j + <span class="number">1</span>) + <span class="string">" "</span>); <span class="comment">// 添加单词</span></span><br><span class="line">            <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; s.charAt(i) == <span class="string">' '</span>) i--; <span class="comment">// 跳过单词间空格</span></span><br><span class="line">            j = i; <span class="comment">// j 指向下个单词的尾字符</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString().trim(); <span class="comment">// 转化为字符串并返回</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：分割 + 倒序<br>利用 “字符串分割”、“列表倒序” 的内置函数 （面试时不建议使用） ，可简便地实现本题的字符串翻转要求<br>复杂度分析：<br>时间复杂度 O(N)O(N) ： 总体为线性时间复杂度，各函数时间复杂度和参考资料链接如下。<br>split() 方法： 为 O(N)O(N) ；<br>trim() 和 strip() 方法： 最差情况下（当字符串全为空格时），为 O(N)O(N) ；<br>join() 方法： 为 O(N)O(N) ；<br>reverse() 方法： 为 O(N)O(N) ；<br>空间复杂度 O(N)O(N) ： 单词列表 strsstrs 占用线性大小的额外空间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        String[] strs = s.trim().split(<span class="string">" "</span>); <span class="comment">// 删除首尾空格，分割字符串</span></span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = strs.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">// 倒序遍历单词列表</span></span><br><span class="line">            <span class="keyword">if</span>(strs[i].equals(<span class="string">""</span>)) <span class="keyword">continue</span>; <span class="comment">// 遇到空单词则跳过</span></span><br><span class="line">            res.append(strs[i] + <span class="string">" "</span>); <span class="comment">// 将单词拼接至 StringBuilder</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString().trim(); <span class="comment">// 转化为字符串，删除尾部空格，并返回</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：jyd</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/solution/mian-shi-ti-58-i-fan-zhuan-dan-ci-shun-xu-shuang-z/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><p>方法二</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">ReverseSentence</span><span class="params">(String str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//先单个单词反转,再整体反转。I am a student.》》I ma a .tneduts 》》student. a am I</span></span><br><span class="line">        <span class="keyword">if</span>(str.length()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[]chs=str.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对单个字符数组元素进行反转</span></span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;<span class="comment">//定义两个指针进行遍历</span></span><br><span class="line">        <span class="keyword">while</span>(j&lt;=str.length())&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//以空格作为区分，对每个单词进行反转</span></span><br><span class="line">            <span class="keyword">if</span>(j==str.length()||chs[j]==<span class="string">' '</span>)&#123;<span class="comment">//j==str.length()不要忘记</span></span><br><span class="line">                reverse(chs,i,j-<span class="number">1</span>);</span><br><span class="line">                i=j+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果chs[j]!=' '那么继续遍历直到找到空格</span></span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//整体字符串反转</span></span><br><span class="line">        reverse(chs,<span class="number">0</span>,str.length()-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(chs);<span class="comment">//学习</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">char</span>[]ch,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            <span class="comment">//反转交换,代码是一样的</span></span><br><span class="line">            <span class="keyword">char</span> temp=ch[i];</span><br><span class="line">            ch[i]=ch[j];</span><br><span class="line">            ch[j]=temp;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">版权声明：本文为博主原创文章，遵循 CC <span class="number">4.0</span> BY-SA 版权协议，转载请附上原文出处链接和本声明。</span><br><span class="line">本文链接：https:<span class="comment">//blog.csdn.net/hefenglian/article/details/79932709</span></span><br></pre></td></tr></table></figure><p>#最牛逼的解法：JavaScript<br>解法：先用trim()把字符串两端空格去掉，split(‘ ‘)把字符串切割成以空格为界限的单词块，filter()过滤掉数组中的纯空格，reverse()进行数组反转，join(‘ ‘)把数组变成中间只带一个空格的字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">var</span> reverseWords = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> str = s.trim().split(<span class="string">' '</span>).filter(<span class="function"><span class="params">item</span> =&gt;</span> item!=<span class="string">''</span>).reverse().join(<span class="string">' '</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(str)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">作者：CHH_</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/solution/yi-xing-dai-ma-jie-jue-suo-you-by-chen-1wz/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h1 id="暴力求解法-百度百科"><a href="#暴力求解法-百度百科" class="headerlink" title="暴力求解法(百度百科)"></a>暴力求解法(百度百科)</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">暴力求解法, 又名直接带入法（Directly Calculating）它是已知最古老的算法之一，与&quot;直观目测法&quot;，&quot;心灵感应法&quot;并称世界三大不可思议数学计算法则， 其可追溯至3200年前，古老的埃及人便开始使用象形文字进行复杂的数学演算。它首次的文本出现是欧几里德的《几何原本》（第V卷，命题i和ii）中，而在中国则可以追溯至宋朝末年出现的沈括《梦溪笔谈》</span><br></pre></td></tr></table></figure><p>暴力求解法的由来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在汉高祖时期有一个有趣的小故事是这样的:</span><br><span class="line">“高祖年间,大将军韩信征讨突厥得胜,七月七日凯旋而归，其时举国腾。信进宫，高祖曰:’淮阴侯乃真人也，战无不功克，朕三年尝闻智勇，招为爱卿，果其然，甚好甚慰。’信曰:’大王聪明仁惠，敬贤礼士，江表英豪贤归附，臣听闻蜀地龙光射牛斗之墟，人杰多地灵，又适王举兵招马，无怪骏才星驰。’高祖对曰:’今汝方成大业，且问卿求?’信:’乃望众亲赐匹布，以二渐累。’回:’善，明日使文库之卿，方得人数。’隔日使返，帝问:”需布甚许?”曰:”臣不才，方得淮阴侯亲友八十五者，食客则七百七十六人之众，臣斗胆以树枝编排数之方得须七三万千三百二十馀一匹”帝惊道:”甚许!乃至库之空不能所期，淮阴岂谋他意?”遂隔日将信斩之，不知了了。”</span><br></pre></td></tr></table></figure><p>暴力求解法的演算<br>1.例题:在地面上的同一1地点分别以速率V1、V2先后竖直像上抛出两个可视为质点的小球。第二个小球抛出后经过T时间与第一个小球相遇。改变两小球抛出的时间间隔，若V1&lt;V2，不计空气阻力，则T的最大值为<strong><strong><strong>__</strong></strong></strong><br>解:依照暴力求解法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">设第一小球抛出后t0时间与第二小球相遇 (此时第二小球已运动T,T&lt;t0)</span><br><span class="line">因为 h1 &#x3D; h2</span><br><span class="line">v1t0 - 1&#x2F;2g(t0)^2 &#x3D; v2T -1&#x2F;2gT^2</span><br><span class="line">所以 T &#x3D; (v2+√(v2^2-2g(v1t0 - 1&#x2F;2g(t0)^2))) &#x2F; g</span><br><span class="line">又 T &lt; v2&#x2F;g</span><br><span class="line">根据复杂计算</span><br><span class="line">可得 T &#x3D; (v2-√v2^2-v1^2) &#x2F; g</span><br><span class="line">所以 Tmax &#x3D; (v2-√v2^2-v1^2) &#x2F; g</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一：力扣第14题-编写一个函数来查找字符串数组中的最长公共前缀&quot;&gt;&lt;a href=&quot;#一：力扣第14题-编写一个函数来查找字符串数组中的最长公共前缀&quot; class=&quot;headerlink&quot; title=&quot;一：力扣第14题 编写一个函数来查找字符串数组中的最长公共前
      
    
    </summary>
    
    
    
      <category term="算法" scheme="http://kkget.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
