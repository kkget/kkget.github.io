<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>赵KK的个人博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="zhaozhenkun888.github.io/"/>
  <updated>2020-06-01T09:04:08.932Z</updated>
  <id>zhaozhenkun888.github.io/</id>
  
  <author>
    <name>赵KK</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>第一篇博客</title>
    <link href="zhaozhenkun888.github.io/2020/06/01/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <id>zhaozhenkun888.github.io/2020/06/01/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</id>
    <published>2020-06-01T08:48:28.000Z</published>
    <updated>2020-06-01T09:04:08.932Z</updated>
    
    <content type="html"><![CDATA[<p>author:赵KK</p><p> 在日常工作中，不管是因为接收前端返回约定格式的JSON字符串，还是因为需要约定格式请求第三方服务，或者需要将前端画像xml解析成JSON，再或者需要接入第三方短信，供应商，数据提供商的JSON数据，或是需要提供对外暴露接口的API，可见解析JSON是一个常见操作。</p><p>JSON是一个轻量级的数据交换格式。</p><p>一：表单数据由数据库实体对象接收</p><p>常见的前后端约定字段，指定字段名称后，由数据库实体接收序列化后的表单数据，无序解析。</p><p>二：JSONObject解析</p><p>前后端约定格式，实体接收String类型，通过JSONObject解析JSON，JSONArray等操作</p><p>例如：</p><p>[<br>    {<br>        “children”: [</p><pre><code>    ],    &quot;createBy&quot;: &quot;admin&quot;,    &quot;createTime&quot;: 1521171180000,    &quot;icon&quot;: &quot;fa fa-gear&quot;,    &quot;menuId&quot;: 1,    &quot;menuName&quot;: &quot;系统管理&quot;,    &quot;menuType&quot;: &quot;M&quot;,    &quot;orderNum&quot;: &quot;1&quot;,    &quot;params&quot;: {    },    &quot;parentId&quot;: 0,    &quot;perms&quot;: &quot;&quot;,    &quot;target&quot;: &quot;&quot;,    &quot;url&quot;: &quot;#&quot;,    &quot;visible&quot;: &quot;0&quot;},{    &quot;children&quot;: [    ],    &quot;createBy&quot;: &quot;admin&quot;,    &quot;createTime&quot;: 1521171180000,    &quot;icon&quot;: &quot;fa fa-video-camera&quot;,    &quot;menuId&quot;: 2,    &quot;menuName&quot;: &quot;系统监控&quot;,    &quot;menuType&quot;: &quot;M&quot;,    &quot;orderNum&quot;: &quot;2&quot;,    &quot;params&quot;: {    },    &quot;parentId&quot;: 0,    &quot;perms&quot;: &quot;&quot;,    &quot;target&quot;: &quot;&quot;,    &quot;url&quot;: &quot;#&quot;,    &quot;visible&quot;: &quot;0&quot;},{    &quot;children&quot;: [    ],    &quot;createBy&quot;: &quot;admin&quot;,    &quot;createTime&quot;: 1521171180000,    &quot;icon&quot;: &quot;fa fa-bars&quot;,    &quot;menuId&quot;: 3,    &quot;menuName&quot;: &quot;系统工具&quot;,    &quot;menuType&quot;: &quot;M&quot;,    &quot;orderNum&quot;: &quot;3&quot;,    &quot;params&quot;: {    },    &quot;parentId&quot;: 0,    &quot;perms&quot;: &quot;&quot;,    &quot;target&quot;: &quot;&quot;,    &quot;url&quot;: &quot;#&quot;,    &quot;visible&quot;: &quot;0&quot;},{    &quot;children&quot;: [    ],    &quot;createBy&quot;: &quot;admin&quot;,    &quot;createTime&quot;: 1590568770000,    &quot;icon&quot;: &quot;fa fa-hand-peace-o&quot;,    &quot;menuId&quot;: 1062,    &quot;menuName&quot;: &quot;我的朋友&quot;,    &quot;menuType&quot;: &quot;C&quot;,    &quot;orderNum&quot;: &quot;1&quot;,    &quot;params&quot;: {    },    &quot;parentId&quot;: 1,    &quot;perms&quot;: &quot;system:friends:view&quot;,    &quot;target&quot;: &quot;menuItem&quot;,    &quot;url&quot;: &quot;/system/friends&quot;,    &quot;visible&quot;: &quot;0&quot;},{    &quot;children&quot;: [    ],    &quot;createBy&quot;: &quot;admin&quot;,    &quot;createTime&quot;: 1521171180000,    &quot;icon&quot;: &quot;#&quot;,    &quot;menuId&quot;: 100,    &quot;menuName&quot;: &quot;用户管理&quot;,    &quot;menuType&quot;: &quot;C&quot;,    &quot;orderNum&quot;: &quot;1&quot;,    &quot;params&quot;: {    },    &quot;parentId&quot;: 1,    &quot;perms&quot;: &quot;system:user:view&quot;,    &quot;target&quot;: &quot;&quot;,    &quot;url&quot;: &quot;/system/user&quot;,    &quot;visible&quot;: &quot;0&quot;},{    &quot;children&quot;: [    ],    &quot;createBy&quot;: &quot;admin&quot;,    &quot;createTime&quot;: 1521171180000,    &quot;icon&quot;: &quot;#&quot;,    &quot;menuId&quot;: 101,    &quot;menuName&quot;: &quot;角色管理&quot;,    &quot;menuType&quot;: &quot;C&quot;,    &quot;orderNum&quot;: &quot;2&quot;,    &quot;params&quot;: {    },    &quot;parentId&quot;: 1,    &quot;perms&quot;: &quot;system:role:view&quot;,    &quot;target&quot;: &quot;&quot;,    &quot;url&quot;: &quot;/system/role&quot;,    &quot;visible&quot;: &quot;0&quot;},{    &quot;children&quot;: [    ],    &quot;createBy&quot;: &quot;admin&quot;,    &quot;createTime&quot;: 1521171180000,    &quot;icon&quot;: &quot;#&quot;,    &quot;menuId&quot;: 102,    &quot;menuName&quot;: &quot;菜单管理&quot;,    &quot;menuType&quot;: &quot;C&quot;,    &quot;orderNum&quot;: &quot;3&quot;,    &quot;params&quot;: {    },    &quot;parentId&quot;: 1,    &quot;perms&quot;: &quot;system:menu:view&quot;,    &quot;target&quot;: &quot;&quot;,    &quot;url&quot;: &quot;/system/menu&quot;,    &quot;visible&quot;: &quot;0&quot;}</code></pre><p>]<br>通过JSONObject以及解析JSONArray获取<br>三：接入第三方API</p><p>接入第三方API，或者按约定调用第三方服务时，你会发现约定了又臭有长的JSON格式，包含特定字段，包含token，包含秘钥，一个详细数据解析接口，上百个字段是常见的，而且多种格式嵌套解析，如果单纯将收到的字符串手动转化成JSONObject，还要判空，还要层层遍历，还要验证数据的有效性，这是在是不小的工作量。</p><p>改造方法：提取最长，覆盖字段最全的作为实体列接收，含有List数据就由List接收，最外层K值由字段接收，涉及类型判断需按约定传不同数值的，定义为枚举，秘钥等特殊Key值MD5加解密传递。</p><p>// 如果url是空，则认为是解析历史数据 不需要拼装请求<br>        if (url != null &amp;&amp; !””.equals(url)) {<br>            Client client = new Client();<br>            Map&lt;String, String&gt; params = new HashMap&lt;String, String&gt;();<br>            if (“mobileReli”.equals(interfaceCode)) { //if类型判断定义为枚举<br>                String infoJson = String.format(“{&quot;phone&quot;:&quot;%s&quot;,&quot;name&quot;:&quot;%s&quot;,&quot;curDate&quot;:&quot;%s&quot;}”,<br>                        applyRecord.getPhone(), applyRecord.getName(), applyRecord.getFlashblackDate());<br>                StringBuffer sb = new StringBuffer();<br>                long time = System.currentTimeMillis();//重复度高的字段由优特实体类接收<br>                sb.append(secret + “!” + appKey + “!” + time + “!” + applyRecord.getName() + “!”<br>                        + applyRecord.getPhone() + “!” + secret + “!”);<br>                sign = hdsClient.md5(sb.toString());<br>                String param = String.format(“appKey=%s&amp;infoJson=%s&amp;sign=%s&amp;time=%s”, appKey, infoJson, sign, time);<br>                try {<br>                    jsonData = hdsClient.getResult(url, param);<br>                } catch (IOException e) {<br>                    // TODO Auto-generated catch block<br>                    e.printStackTrace();<br>                }<br>            } else if (“DSModel”.equals(interfaceCode)) {<br>                String infoJson = String.format(“{&quot;mobile&quot;:&quot;%s&quot;,&quot;name&quot;:&quot;%s&quot;,&quot;starttime&quot;:&quot;%s&quot;}”,<br>                        applyRecord.getPhone(), applyRecord.getName(), applyRecord.getFlashblackDate());<br>                StringBuffer sb = new StringBuffer();<br>                long time = System.currentTimeMillis();<br>                sb.append(secret + “!” + appKey + “!” + time + “!” + applyRecord.getName() + “!”<br>                        + applyRecord.getPhone() + “!” + applyRecord.getFlashblackDate() + “!” + secret + “!”);<br>                sign = hdsClient.md5(sb.toString());<br>                String param = String.format(“appKey=%s&amp;infoJson=%s&amp;sign=%s&amp;time=%s”, appKey, infoJson, sign, time);<br>                try {<br>                    jsonData = hdsClient.getResult(url, param);<br>                } catch (IOException e) {<br>                    // TODO Auto-generated catch block<br>                    e.printStackTrace();<br>                }<br>            } else if (“addressDetection”.equals(interfaceCode)) {<br>                String infoJson = String.format(“{&quot;phone&quot;:&quot;%s&quot;,&quot;address&quot;:&quot;%s&quot;,&quot;curDate&quot;:&quot;%s&quot;}”,<br>                        applyRecord.getPhone(), applyRecord.getAddress(), applyRecord.getFlashblackDate());<br>                StringBuffer sb = new StringBuffer();<br>                long time = System.currentTimeMillis();<br>                sb.append(secret + “!” + appKey + “!” + time + “!” + applyRecord.getPhone() + “!”<br>                        + applyRecord.getAddress() + “!” + applyRecord.getFlashblackDate() + “!” + secret + “!”);<br>                sign = hdsClient.md5(sb.toString());<br>                String param = String.format(“appKey=%s&amp;infoJson=%s&amp;sign=%s&amp;time=%s”, appKey, infoJson, sign, time);<br>                try {<br>                    jsonData = hdsClient.getResult(url, param);<br>                } catch (IOException e) {<br>                    // TODO Auto-generated catch block<br>                    e.printStackTrace();<br>                }<br>            }<br>public enum InterfaceCodeEnum {</p><pre><code>InterfaceCode1(1,&quot;mobileReli&quot;),InterfaceCode2(2,&quot;DSModel&quot;),InterfaceCode3(3,&quot;addressDetection&quot;),...;private Integer code;private String name;InterfaceCodeEnum(Integer code, String name) {    this.code = code;    this.name = name;}public static String getNameBycode(Integer code) {    if (code == null) {        return &quot;&quot;;    }    for (InterfaceCodeEnum a : InterfaceCodeEnum.values()) {        if (a.code.equals(code)) {            return a.name;        }    }    return &quot;&quot;;}</code></pre><p>}</p><p>@Builder<br>@Data<br>public class InterfaceCodeResult implements Serializable {</p><pre><code>//基础信息private Base base;//秘钥信息private AuthInfo authInfo;//外层字段封装为对象接收private AddressResult  addressResult;//重复多层信息List接收private List&lt;Flashblack&gt; flashblack;</code></pre><p>}<br>当接收到JSON字符串时</p><p>InterfaceCodeResult codeResult=JSONObject.parseObject(InterfaceCodeResult.getRequestInfo(),InterfaceCodeResult.class);<br>if(PreInterfaceStatus.equals(codeResult.base.getTyep())){<br>  return JavaConvertUtil.conversion(codeResult, CodeParams.class);<br>}<br>仅需要判断多个类型即可，对应字段会自动解析，当接收又臭又长的XML解析还需要后端验证时，需要封装Util类进行验证调用</p><p>同步更新至微信公众号，请搜索:赵KK日常技术记录，不定时更新文章内容</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;author:赵KK&lt;/p&gt;
&lt;p&gt; 在日常工作中，不管是因为接收前端返回约定格式的JSON字符串，还是因为需要约定格式请求第三方服务，或者需要将前端画像xml解析成JSON，再或者需要接入第三方短信，供应商，数据提供商的JSON数据，或是需要提供对外暴露接口的API，可见
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
