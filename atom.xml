<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>赵KK的个人博客</title>
  
  <subtitle>纠结体本体,同步记录日常笔记</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="kkget.github.io/"/>
  <updated>2020-09-30T02:48:08.233Z</updated>
  <id>kkget.github.io/</id>
  
  <author>
    <name>赵KK</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据库中间件系列</title>
    <link href="kkget.github.io/2020/09/30/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%B3%BB%E5%88%97/"/>
    <id>kkget.github.io/2020/09/30/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%B3%BB%E5%88%97/</id>
    <published>2020-09-30T02:38:32.000Z</published>
    <updated>2020-09-30T02:48:08.233Z</updated>
    
    <content type="html"><![CDATA[<p>数据库链接池过多，或者导致数据库挂了，如果主备机切换，需要更改配置<br>java应用与数据库紧耦合</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/dbcenter/1.png" alt="图1" title="">                </div>                <div class="image-caption">图1</div>            </figure><p>官网:<a href="http://www.mycat.io/" target="_blank" rel="noopener">http://www.mycat.io/</a></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/dbcenter/2.png" alt="图1" title="">                </div>                <div class="image-caption">图1</div>            </figure><p>主从复制，主备切换，双主双从</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/dbcenter/3.png" alt="图1" title="">                </div>                <div class="image-caption">图1</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/dbcenter/4.png" alt="图1" title="">                </div>                <div class="image-caption">图1</div>            </figure><p>Mycat原理:拦截<br>安装<br>Springboot整合</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.0.0&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">            &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p>application.yml配置文件：<br>#设置应用端口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">8080</span></span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    # Mycat连接</span><br><span class="line">    url: jdbc:mysql:<span class="comment">//localhost:8066/springboot?useUnicode=true&amp;characterEncoding=utf-8&amp;autoReconnect=true&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=false&amp;serverTimezone=GMT%2B8</span></span><br><span class="line">    username: root</span><br><span class="line">    password: <span class="number">123456</span></span><br><span class="line"></span><br><span class="line"># MyBatis</span><br><span class="line">mybatis:</span><br><span class="line">    type-aliases-<span class="keyword">package</span>: com.example.springbootmybatismycat.domain</span><br><span class="line">    mapper-locations: classpath:/mybatis<span class="comment">/*.xml</span></span><br><span class="line"><span class="comment">    #sql打印配置</span></span><br><span class="line"><span class="comment">    configuration:</span></span><br><span class="line"><span class="comment">        log-impl: org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br></pre></td></tr></table></figure><p>一、基本概念<br>Sharding-Sphere简介<br>Sharding-Sphere官网：<a href="http://shardingsphere.apache.org/index_zh.html" target="_blank" rel="noopener">http://shardingsphere.apache.org/index_zh.html</a></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/dbcenter/5.png" alt="图1" title="">                </div>                <div class="image-caption">图1</div>            </figure><p>一套开源的分布式数据库中间件解决方案。<br>有三个产品，Sharding-JDBC、Sharding-Proxy 和 Sharding-Sidecar。<br>ShardingSphere 定位为关系型数据库中间件，合理地在分布式环境下使用关系型数据库操作。<br>分库分表<br>数据据库数据量是不可控的，随着时间和业务发展，造成表里面数据越来越多，如果再去对数据库表curd操作时，就会有性能问题。<br>解决办法：<br>方案1：从硬件上<br>方案2：分库分表<br>为了解决由于数据量过大而造成数据库性能降低问题。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/dbcenter/6.png" alt="图1" title="">                </div>                <div class="image-caption">图1</div>            </figure><p>分库分表的方式<br>分库分表有两种方式：垂直切分和水平切分。<br>垂直切分：垂直分表和垂直分库<br>水平切分：水平分表和水平分库<br>垂直拆字段，水平拆记录。<br>垂直切分的库和表结构是不同的，而水平切分的库和表是相同的。<br>垂直分表<br>操作数据库中某张表，把这张表中一部分字段数据存到一张新表里面，再把这张表另部分字段数据存到另外一张表里面。<br>垂直拆分成的两张表，每张表的数据量和原先的表的数据量相同。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/dbcenter/7.png" alt="图1" title="">                </div>                <div class="image-caption">图1</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/dbcenter/8.png" alt="图1" title="">                </div>                <div class="image-caption">图1</div>            </figure><p>垂直分库<br>把单一数据库按照业务进行划分，专库专表。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/dbcenter/9.png" alt="图1" title="">                </div>                <div class="image-caption">图1</div>            </figure><p>水平分库</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/dbcenter/10.png" alt="图1" title="">                </div>                <div class="image-caption">图1</div>            </figure><p>水平分表</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/dbcenter/12.png" alt="图1" title="">                </div>                <div class="image-caption">图1</div>            </figure><p>分库分表的应用和问题<br>应用<br>在数据库设计时候就要考虑垂直分库和垂直分表。<br>随着数据库数据量增加，不要马上考虑做水平切分。首先考虑缓存处理，读写分离，使用索引等等方式。如果这些方式不能根本解决问题了，再考虑做水平分库和水平分表。<br>分库分表问题<br>跨节点连接查询问题(分页、排序)。<br>多数据源管理问题。<br>二、Sharding-JDBC 分库分表操作<br>ShardingSphere-JDBC 简介</p><p>Sharding-JDBC是轻量级的Java框架，是增强的JDBC驱动。</p><p>Sharding-JDBC的功能：主要做数据分片和读写分离，不是做分库分表，分库分表由我们自己做。<br>主要的目的：简化分库分表后数据的相关操作。<br>Sharding-JDBC 实现水平分表<br>搭建环境<br>技术：SpringBoot2.2.1 + MybatisPlus + Sharding-JDBC + Druid连接池<br>创建项目</p><p>修改SpringBoot的版本</p><p>pom.xml引入相关的依赖<br>    <dependency><br>        <groupId>com.alibaba</groupId><br>        <artifactId>druid-spring-boot-starter</artifactId><br>        <version>1.1.20</version><br>    </dependency></p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;    &lt;version&gt;8.0.18&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.apache.shardingsphere&lt;/groupId&gt;    &lt;artifactId&gt;sharding-jdbc-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;4.0.0-RC1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;    &lt;version&gt;3.0.5&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;    &lt;artifactId&gt;lombok&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>按照水平分表的方式创建数据库、数据表<br>创建数据库 course_db。<br>在数据库中创建两张表 course_1 和 course_2。<br>数据存放约定规则：添加的数据id为偶数放 course_1 表中，id为奇数放 course_2 表中。<br>create database course_db;</p><p>use course_db;</p><p>create table course_1 (<br>    <code>cid</code> bigint(20) primary key,<br>    <code>cname</code> varchar(50) not null,<br>    <code>user_id</code> bigint(20) not null,<br>    <code>cstatus</code> varchar(10) not null<br>);</p><p>create table course_2 (<br>    <code>cid</code> bigint(20) primary key,<br>    <code>cname</code> varchar(50) not null,<br>    <code>user_id</code> bigint(20) not null,<br>    <code>cstatus</code> varchar(10) not null<br>);</p><p>编写代码实现对分库分表数据的操作<br>在shardingjdbcdemo包下创建 entity.Course 实体类<br>@Data<br>public class Course {<br>    private Long cid;<br>    private String cname;<br>    private Long userId;<br>    private String cstatus;<br>}</p><p>创建mapper.CourseMapper 接口<br>@Repository<br>public interface CourseMapper extends BaseMapper<Course> {}</p><p>在启动类上加上@MapperScan(“com.angenin.shardingjdbcdemo.mapper”)注解<br>配置水平分表策略<br>官网数据分片配置：<a href="https://shardingsphere.apache.org/document/current/cn/user-manual/shardingsphere-jdbc/usage/sharding/spring-boot-starter/" target="_blank" rel="noopener">https://shardingsphere.apache.org/document/current/cn/user-manual/shardingsphere-jdbc/usage/sharding/spring-boot-starter/</a></p><p>在 application.properties 配置文件中配置：（下面数据库密码记得写）</p><h1 id="shardingjdbc-水平分表策略"><a href="#shardingjdbc-水平分表策略" class="headerlink" title="shardingjdbc 水平分表策略"></a>shardingjdbc 水平分表策略</h1><h1 id="配置数据源，给数据源起别名"><a href="#配置数据源，给数据源起别名" class="headerlink" title="配置数据源，给数据源起别名"></a>配置数据源，给数据源起别名</h1><p>spring.shardingsphere.datasource.names=m1</p><h1 id="一个实体类对应两张表，覆盖"><a href="#一个实体类对应两张表，覆盖" class="headerlink" title="一个实体类对应两张表，覆盖"></a>一个实体类对应两张表，覆盖</h1><p>spring.main.allow-bean-definition-overriding=true</p><h1 id="配置数据源的具体内容，包含连接池，驱动，地址，用户名，密码"><a href="#配置数据源的具体内容，包含连接池，驱动，地址，用户名，密码" class="headerlink" title="配置数据源的具体内容，包含连接池，驱动，地址，用户名，密码"></a>配置数据源的具体内容，包含连接池，驱动，地址，用户名，密码</h1><p>spring.shardingsphere.datasource.m1.type=com.alibaba.druid.pool.DruidDataSource<br>spring.shardingsphere.datasource.m1.driver-class-name=com.mysql.cj.jdbc.Driver<br>spring.shardingsphere.datasource.m1.url=jdbc:mysql://localhost:3306/course_db?serverTimezone=GMT%2B8<br>spring.shardingsphere.datasource.m1.username=root<br>spring.shardingsphere.datasource.m1.password=</p><h1 id="指定course表分布的情况，配置表在哪个数据库里，表的名称都是什么-m1-course-1-m1-course-2"><a href="#指定course表分布的情况，配置表在哪个数据库里，表的名称都是什么-m1-course-1-m1-course-2" class="headerlink" title="指定course表分布的情况，配置表在哪个数据库里，表的名称都是什么 m1.course_1,m1.course_2"></a>指定course表分布的情况，配置表在哪个数据库里，表的名称都是什么 m1.course_1,m1.course_2</h1><p>spring.shardingsphere.sharding.tables.course.actual-data-nodes=m1.course_$-&gt;{1..2}</p><h1 id="指定-course-表里面主键-cid-的生成策略-SNOWFLAKE"><a href="#指定-course-表里面主键-cid-的生成策略-SNOWFLAKE" class="headerlink" title="指定 course 表里面主键 cid 的生成策略 SNOWFLAKE"></a>指定 course 表里面主键 cid 的生成策略 SNOWFLAKE</h1><p>spring.shardingsphere.sharding.tables.course.key-generator.column=cid<br>spring.shardingsphere.sharding.tables.course.key-generator.type=SNOWFLAKE</p><h1 id="配置分表策略-约定-cid-值偶数添加到-course-1-表，如果-cid-是奇数添加到-course-2-表"><a href="#配置分表策略-约定-cid-值偶数添加到-course-1-表，如果-cid-是奇数添加到-course-2-表" class="headerlink" title="配置分表策略    约定 cid 值偶数添加到 course_1 表，如果 cid 是奇数添加到 course_2 表"></a>配置分表策略    约定 cid 值偶数添加到 course_1 表，如果 cid 是奇数添加到 course_2 表</h1><p>spring.shardingsphere.sharding.tables.course.table-strategy.inline.shardingcolumn=cid<br>spring.shardingsphere.sharding.tables.course.table-strategy.inline.algorithmexpression=course_$-&gt;{cid % 2 + 1}</p><h1 id="打开-sql-输出日志"><a href="#打开-sql-输出日志" class="headerlink" title="打开 sql 输出日志"></a>打开 sql 输出日志</h1><p>spring.shardingsphere.props.sql.show=true</p><p>编写测试代码<br>在test包中的测试类中进行测试<br>@RunWith(SpringRunner.class)<br>@SpringBootTest<br>public class ShardingjdbcdemoApplicationTests {</p><pre><code>@Autowiredprivate CourseMapper courseMapper;//添加课程@Testpublic void addCourse(){    Course course = new Course();    //cid由我们设置的策略，雪花算法进行生成（至少70年内生成的id不会重复）    course.setCname(&quot;java&quot;);    course.setUserId(100L);    course.setCstatus(&quot;Normal&quot;);    courseMapper.insert(course);}//查询课程@Testpublic void findCourse(){    QueryWrapper&lt;Course&gt; wrapper = new QueryWrapper&lt;&gt;();    wrapper.eq(&quot;cid&quot;, 509755853058867201L);    courseMapper.selectOne(wrapper);}</code></pre><p>}</p><p>addCourse方法执行结果：</p><p>findCourse方法执行结果：</p><p>Sharding-JDBC 实现水平分库<br>需求分析</p><p>创建数据库，数据表<br>create database edu_db_1;<br>create database edu_db_2;</p><p>use edu_db_1;</p><p>create table course_1 (<br>    <code>cid</code> bigint(20) primary key,<br>    <code>cname</code> varchar(50) not null,<br>    <code>user_id</code> bigint(20) not null,<br>    <code>cstatus</code> varchar(10) not null<br>);</p><p>create table course_2 (<br>    <code>cid</code> bigint(20) primary key,<br>    <code>cname</code> varchar(50) not null,<br>    <code>user_id</code> bigint(20) not null,<br>    <code>cstatus</code> varchar(10) not null<br>);</p><p>use edu_db_2;</p><p>create table course_1 (<br>    <code>cid</code> bigint(20) primary key,<br>    <code>cname</code> varchar(50) not null,<br>    <code>user_id</code> bigint(20) not null,<br>    <code>cstatus</code> varchar(10) not null<br>);</p><p>create table course_2 (<br>    <code>cid</code> bigint(20) primary key,<br>    <code>cname</code> varchar(50) not null,<br>    <code>user_id</code> bigint(20) not null,<br>    <code>cstatus</code> varchar(10) not null<br>);</p><p>配置水平分库策略<br>下面数据库的密码填自己的。</p><h1 id="shardingjdbc-水平分库分表策略"><a href="#shardingjdbc-水平分库分表策略" class="headerlink" title="shardingjdbc 水平分库分表策略"></a>shardingjdbc 水平分库分表策略</h1><h1 id="配置数据源，给数据源起别名-1"><a href="#配置数据源，给数据源起别名-1" class="headerlink" title="配置数据源，给数据源起别名"></a>配置数据源，给数据源起别名</h1><h1 id="水平分库需要配置多个数据库"><a href="#水平分库需要配置多个数据库" class="headerlink" title="水平分库需要配置多个数据库"></a>水平分库需要配置多个数据库</h1><p>spring.shardingsphere.datasource.names=m1,m2</p><h1 id="一个实体类对应两张表，覆盖-1"><a href="#一个实体类对应两张表，覆盖-1" class="headerlink" title="一个实体类对应两张表，覆盖"></a>一个实体类对应两张表，覆盖</h1><p>spring.main.allow-bean-definition-overriding=true</p><h1 id="配置第一个数据源的具体内容，包含连接池，驱动，地址，用户名，密码"><a href="#配置第一个数据源的具体内容，包含连接池，驱动，地址，用户名，密码" class="headerlink" title="配置第一个数据源的具体内容，包含连接池，驱动，地址，用户名，密码"></a>配置第一个数据源的具体内容，包含连接池，驱动，地址，用户名，密码</h1><p>spring.shardingsphere.datasource.m1.type=com.alibaba.druid.pool.DruidDataSource<br>spring.shardingsphere.datasource.m1.driver-class-name=com.mysql.cj.jdbc.Driver<br>spring.shardingsphere.datasource.m1.url=jdbc:mysql://localhost:3306/edu_db_1?serverTimezone=GMT%2B8<br>spring.shardingsphere.datasource.m1.username=root<br>spring.shardingsphere.datasource.m1.password=</p><h1 id="配置第二个数据源的具体内容，包含连接池，驱动，地址，用户名，密码"><a href="#配置第二个数据源的具体内容，包含连接池，驱动，地址，用户名，密码" class="headerlink" title="配置第二个数据源的具体内容，包含连接池，驱动，地址，用户名，密码"></a>配置第二个数据源的具体内容，包含连接池，驱动，地址，用户名，密码</h1><p>spring.shardingsphere.datasource.m2.type=com.alibaba.druid.pool.DruidDataSource<br>spring.shardingsphere.datasource.m2.driver-class-name=com.mysql.cj.jdbc.Driver<br>spring.shardingsphere.datasource.m2.url=jdbc:mysql://localhost:3306/edu_db_2?serverTimezone=GMT%2B8<br>spring.shardingsphere.datasource.m2.username=root<br>spring.shardingsphere.datasource.m2.password=</p><h1 id="指定数据库分布的情况和数据表分布的情况"><a href="#指定数据库分布的情况和数据表分布的情况" class="headerlink" title="指定数据库分布的情况和数据表分布的情况"></a>指定数据库分布的情况和数据表分布的情况</h1><h1 id="m1-m2-course-1-course-2"><a href="#m1-m2-course-1-course-2" class="headerlink" title="m1 m2   course_1 course_2"></a>m1 m2   course_1 course_2</h1><p>spring.shardingsphere.sharding.tables.course.actual-data-nodes=m$-&gt;{1..2}.course_$-&gt;{1..2}</p><h1 id="指定-course-表里面主键-cid-的生成策略-SNOWFLAKE-1"><a href="#指定-course-表里面主键-cid-的生成策略-SNOWFLAKE-1" class="headerlink" title="指定 course 表里面主键 cid 的生成策略 SNOWFLAKE"></a>指定 course 表里面主键 cid 的生成策略 SNOWFLAKE</h1><p>spring.shardingsphere.sharding.tables.course.key-generator.column=cid<br>spring.shardingsphere.sharding.tables.course.key-generator.type=SNOWFLAKE</p><h1 id="指定分库策略-约定-user-id-值偶数添加到-m1-库，如果-user-id-是奇数添加到-m2-库"><a href="#指定分库策略-约定-user-id-值偶数添加到-m1-库，如果-user-id-是奇数添加到-m2-库" class="headerlink" title="指定分库策略    约定 user_id 值偶数添加到 m1 库，如果 user_id 是奇数添加到 m2 库"></a>指定分库策略    约定 user_id 值偶数添加到 m1 库，如果 user_id 是奇数添加到 m2 库</h1><h1 id="默认写法（所有的表的user-id）"><a href="#默认写法（所有的表的user-id）" class="headerlink" title="默认写法（所有的表的user_id）"></a>默认写法（所有的表的user_id）</h1><p>#spring.shardingsphere.sharding.default-database-strategy.inline.sharding-column=user_id<br>#spring.shardingsphere.sharding.default-database-strategy.inline.algorithm-expression=m$-&gt;{user_id % 2 + 1}</p><h1 id="指定只有course表的user-id"><a href="#指定只有course表的user-id" class="headerlink" title="指定只有course表的user_id"></a>指定只有course表的user_id</h1><p>spring.shardingsphere.sharding.tables.course.database-strategy.inline.sharding-column=user_id<br>spring.shardingsphere.sharding.tables.course.database-strategy.inline.algorithm-expression=m$-&gt;{user_id % 2 + 1}</p><h1 id="指定分表策略-约定-cid-值偶数添加到-course-1-表，如果-cid-是奇数添加到-course-2-表"><a href="#指定分表策略-约定-cid-值偶数添加到-course-1-表，如果-cid-是奇数添加到-course-2-表" class="headerlink" title="指定分表策略    约定 cid 值偶数添加到 course_1 表，如果 cid 是奇数添加到 course_2 表"></a>指定分表策略    约定 cid 值偶数添加到 course_1 表，如果 cid 是奇数添加到 course_2 表</h1><p>spring.shardingsphere.sharding.tables.course.table-strategy.inline.sharding-column=cid<br>spring.shardingsphere.sharding.tables.course.table-strategy.inline.algorithm-expression=course_$-&gt;{cid % 2 + 1}</p><h1 id="打开-sql-输出日志-1"><a href="#打开-sql-输出日志-1" class="headerlink" title="打开 sql 输出日志"></a>打开 sql 输出日志</h1><p>spring.shardingsphere.props.sql.show=true</p><p>编写测试代码<br>    //添加课程<br>    @Test<br>    public void addCourseDb(){<br>        Course course = new Course();<br>        //cid由我们设置的策略，雪花算法进行生成（至少70年内生成的id不会重复）<br>        course.setCname(“javademo”);<br>        //分库根据user_id<br>        course.setUserId(100L);<br>        course.setCstatus(“Normal”);<br>        courseMapper.insert(course);</p><pre><code>    course.setCname(&quot;javademo2&quot;);    course.setUserId(111L);    courseMapper.insert(course);}//查询课程@Testpublic void findCourseDb(){    QueryWrapper&lt;Course&gt; wrapper = new QueryWrapper&lt;&gt;();    //设置user_id的值    wrapper.eq(&quot;user_id&quot;, 100L);    //设置cid的值    wrapper.eq(&quot;cid&quot;, 509771111076986881L);    Course course = courseMapper.selectOne(wrapper);    System.out.println(course);}</code></pre><p>addCourseDb方法执行结果：</p><p>findCourseDb方法执行结果：</p><p>Sharding-JDBC 实现垂直分库<br>需求分析</p><p>需要查询用户信息的时候，不需要查到课程信息。<br>创建用户数据库、数据表<br>create database user_db;</p><p>use user_db;</p><p>create table t_user(<br>    <code>user_id</code> bigint(20) primary key,<br>    <code>username</code> varchar(100) not null,<br>    <code>ustatus</code> varchar(50) not null<br>);</p><p>编写User代码<br>创建user实体类和对应的mapper<br>@Data<br>@TableName(“t_user”)    //指定对应的表名<br>public class User {<br>    private Long userId;<br>    private String username;<br>    private String ustatus;<br>}</p><p>@Repository<br>public interface UserMapper extends BaseMapper<User> {}</p><p>配置垂直分库策略<br>记得写数据库密码。</p><h1 id="shardingjdbc-垂直分库策略"><a href="#shardingjdbc-垂直分库策略" class="headerlink" title="shardingjdbc 垂直分库策略"></a>shardingjdbc 垂直分库策略</h1><h1 id="配置数据源，给数据源起别名-2"><a href="#配置数据源，给数据源起别名-2" class="headerlink" title="配置数据源，给数据源起别名"></a>配置数据源，给数据源起别名</h1><h1 id="水平分库需要配置多个数据库-1"><a href="#水平分库需要配置多个数据库-1" class="headerlink" title="水平分库需要配置多个数据库"></a>水平分库需要配置多个数据库</h1><h1 id="m0为用户数据库"><a href="#m0为用户数据库" class="headerlink" title="m0为用户数据库"></a>m0为用户数据库</h1><p>spring.shardingsphere.datasource.names=m1,m2,m0</p><h1 id="一个实体类对应两张表，覆盖-2"><a href="#一个实体类对应两张表，覆盖-2" class="headerlink" title="一个实体类对应两张表，覆盖"></a>一个实体类对应两张表，覆盖</h1><p>spring.main.allow-bean-definition-overriding=true</p><h1 id="配置第一个数据源的具体内容，包含连接池，驱动，地址，用户名，密码-1"><a href="#配置第一个数据源的具体内容，包含连接池，驱动，地址，用户名，密码-1" class="headerlink" title="配置第一个数据源的具体内容，包含连接池，驱动，地址，用户名，密码"></a>配置第一个数据源的具体内容，包含连接池，驱动，地址，用户名，密码</h1><p>spring.shardingsphere.datasource.m1.type=com.alibaba.druid.pool.DruidDataSource<br>spring.shardingsphere.datasource.m1.driver-class-name=com.mysql.cj.jdbc.Driver<br>spring.shardingsphere.datasource.m1.url=jdbc:mysql://localhost:3306/edu_db_1?serverTimezone=GMT%2B8<br>spring.shardingsphere.datasource.m1.username=root<br>spring.shardingsphere.datasource.m1.password=</p><h1 id="配置第二个数据源的具体内容，包含连接池，驱动，地址，用户名，密码-1"><a href="#配置第二个数据源的具体内容，包含连接池，驱动，地址，用户名，密码-1" class="headerlink" title="配置第二个数据源的具体内容，包含连接池，驱动，地址，用户名，密码"></a>配置第二个数据源的具体内容，包含连接池，驱动，地址，用户名，密码</h1><p>spring.shardingsphere.datasource.m2.type=com.alibaba.druid.pool.DruidDataSource<br>spring.shardingsphere.datasource.m2.driver-class-name=com.mysql.cj.jdbc.Driver<br>spring.shardingsphere.datasource.m2.url=jdbc:mysql://localhost:3306/edu_db_2?serverTimezone=GMT%2B8<br>spring.shardingsphere.datasource.m2.username=root<br>spring.shardingsphere.datasource.m2.password=</p><h1 id="配置user数据源的具体内容，包含连接池，驱动，地址，用户名，密码"><a href="#配置user数据源的具体内容，包含连接池，驱动，地址，用户名，密码" class="headerlink" title="配置user数据源的具体内容，包含连接池，驱动，地址，用户名，密码"></a>配置user数据源的具体内容，包含连接池，驱动，地址，用户名，密码</h1><p>spring.shardingsphere.datasource.m0.type=com.alibaba.druid.pool.DruidDataSource<br>spring.shardingsphere.datasource.m0.driver-class-name=com.mysql.cj.jdbc.Driver<br>spring.shardingsphere.datasource.m0.url=jdbc:mysql://localhost:3306/user_db?serverTimezone=GMT%2B8<br>spring.shardingsphere.datasource.m0.username=root<br>spring.shardingsphere.datasource.m0.password=</p><h1 id="配置user-db数据库里面t-user-专库专表"><a href="#配置user-db数据库里面t-user-专库专表" class="headerlink" title="配置user_db数据库里面t_user  专库专表"></a>配置user_db数据库里面t_user  专库专表</h1><p>spring.shardingsphere.sharding.tables.t_user.actual-data-nodes=m0.t_user</p><h1 id="配置主键的生成策略"><a href="#配置主键的生成策略" class="headerlink" title="配置主键的生成策略"></a>配置主键的生成策略</h1><p>spring.shardingsphere.sharding.tables.t_user.key-generator.column=user_id<br>spring.shardingsphere.sharding.tables.t_user.key-generator.type=SNOWFLAKE</p><h1 id="指定分表策略"><a href="#指定分表策略" class="headerlink" title="指定分表策略"></a>指定分表策略</h1><p>spring.shardingsphere.sharding.tables.t_user.table-strategy.inline.sharding-column=user_id<br>spring.shardingsphere.sharding.tables.t_user.table-strategy.inline.algorithm-expression=t_user</p><h1 id="…-其他配置同上"><a href="#…-其他配置同上" class="headerlink" title="… 其他配置同上"></a>… 其他配置同上</h1><p>编写测试代码<br>    //添加用户<br>    @Test<br>    public void addUserDb(){<br>        User user = new User();<br>        user.setUsername(“张三”);<br>        user.setUstatus(“a”);<br>        userMapper.insert(user);<br>    }</p><pre><code>@Test//查询用户public void findUserDb(){    QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;();    wrapper.eq(&quot;user_id&quot;, 509793334663839745L);    User user = userMapper.selectOne(wrapper);    System.out.println(user);}</code></pre><p>addUserDb方法执行结果：</p><p>findUserDb方法执行结果：</p><p>Sharding-JDBC 公共表<br>公共表概念<br>存储固定数据的表，表数据很少发生变化，查询时经常要进行关联。<br>在每个数据库中都创建出相同结构公共表。<br>操作公共表时，同时操作添加了公共表的数据库中的公共表，添加记录时，同时添加，删除时，同时删除。<br>在多个数据库中创建相同结构的公共表<br>use user_db;<br>#use edu_db_1;<br>#use edu_db_2;</p><p>create table t_udict(<br>    <code>dictid</code> bigint(20) primary key,<br>    <code>ustatus</code> varchar(100) not null,<br>    <code>uvalue</code> varchar(100) not null<br>);</p><p>公共表配置</p><h1 id="其他配置同上"><a href="#其他配置同上" class="headerlink" title="其他配置同上"></a>其他配置同上</h1><h1 id="…"><a href="#…" class="headerlink" title="…"></a>…</h1><h1 id="公共表配置"><a href="#公共表配置" class="headerlink" title="公共表配置"></a>公共表配置</h1><p>spring.shardingsphere.sharding.broadcast-tables=t_udict</p><h1 id="配置主键的生成策略-1"><a href="#配置主键的生成策略-1" class="headerlink" title="配置主键的生成策略"></a>配置主键的生成策略</h1><p>spring.shardingsphere.sharding.tables.t_udict.key-generator.column=dictid<br>spring.shardingsphere.sharding.tables.t_udict.key-generator.type=SNOWFLAKE</p><h1 id="…-1"><a href="#…-1" class="headerlink" title="…"></a>…</h1><p>编写公共表的实体类及mapper<br>@Data<br>@TableName(value = “t_udict”)<br>public class Udict {<br>    private Long dictid;<br>    private String ustatus;<br>    private String uvalue;<br>}</p><p>@Repository<br>public interface UdictMapper extends BaseMapper<Udict> {}</p><p>编写测试代码<br>    //添加<br>    @Test<br>    public void addDict(){<br>        Udict udict = new Udict();<br>        udict.setUstatus(“a”);<br>        udict.setUvalue(“已启用”);<br>        udictMapper.insert(udict);<br>    }</p><pre><code>//删除@Testpublic void deleteDict(){    QueryWrapper&lt;Udict&gt; wrapper = new QueryWrapper&lt;&gt;();    wrapper.eq(&quot;dictid&quot;, 509811689974136833L);    udictMapper.delete(wrapper);}</code></pre><p>addDict方法执行结果：</p><p>deleteDict方法执行结果：</p><p>Sharding-JDBC 实现读写分离<br>读写分离概念</p><p>读写原理</p><p>Sharding-JDBC 读写分离</p><p>Sharding-JDBC通过sql语句语义分析，当sql语句有insert、update、delete时，Sharding-JDBC就把这次操作在主数据库上执行；当sql语句有select时，就会把这次操作在从数据库上执行，从而实现读写分离过程。但Sharding-JDBC并不会做数据同步，数据同步是配置MySQL后由MySQL自己完成的。<br>MySQL 一主一从读写分离配置<br>我采用的是docker来实现的，单独写在这篇文章里：<a href="https://blog.csdn.net/qq_36903261/article/details/108457759" target="_blank" rel="noopener">https://blog.csdn.net/qq_36903261/article/details/108457759</a><br>使用docker后，需要在主服务器上新建原先的数据库数据表。<br>因为记录的文件名以及位点每次重启或刷新都会改变，所以以下命令放在这里，方便查看。<br>主mysql：<br>#确认位点 记录下文件名以及位点（重启或者刷新都会改变）<br>show master status;</p><p>1<br>2<br>从mysql：<br>#先停止同步<br>STOP SLAVE;</p><p>#修改从库指向到主库，使用上一步记录的文件名以及位点</p><h1 id="master-host-docker容器linux的ip地址"><a href="#master-host-docker容器linux的ip地址" class="headerlink" title="master_host docker容器linux的ip地址"></a>master_host docker容器linux的ip地址</h1><h1 id="master-port-主mysql暴露的端口"><a href="#master-port-主mysql暴露的端口" class="headerlink" title="master_port 主mysql暴露的端口"></a>master_port 主mysql暴露的端口</h1><h1 id="master-user-主mysql的用户名"><a href="#master-user-主mysql的用户名" class="headerlink" title="master_user 主mysql的用户名"></a>master_user 主mysql的用户名</h1><h1 id="master-password-主mysql的密码"><a href="#master-password-主mysql的密码" class="headerlink" title="master_password 主mysql的密码"></a>master_password 主mysql的密码</h1><p>#（最后两项修改成刚刚从主mysql查到的，主mysql每次刷新权限或者重启时，这两个值都会改变，所以每次都需要查看是否相同）<br>CHANGE MASTER TO<br>master_host = ‘10.211.55.26’,<br>master_port = 33060,<br>master_user = ‘db_sync’,<br>master_password = ‘db_sync’,<br>master_log_file = ‘mysql-bin.000001’,<br>master_log_pos = 823;</p><p>#启动同步<br>START SLAVE;</p><p>#查看Slave_IO_Runing和Slave_SQL_Runing字段值都为Yes，表示同步配置成功。<br>show slave status \G;</p><p>Sharding-JDBC 操作<br>配置读写分离策略<br>也使用docker的，复制的时候记得改一下ip地址</p><h1 id="配置数据源，给数据源起别名-3"><a href="#配置数据源，给数据源起别名-3" class="headerlink" title="配置数据源，给数据源起别名"></a>配置数据源，给数据源起别名</h1><h1 id="m0为用户数据库-1"><a href="#m0为用户数据库-1" class="headerlink" title="m0为用户数据库"></a>m0为用户数据库</h1><p>spring.shardingsphere.datasource.names=m0,s0</p><h1 id="一个实体类对应两张表，覆盖-3"><a href="#一个实体类对应两张表，覆盖-3" class="headerlink" title="一个实体类对应两张表，覆盖"></a>一个实体类对应两张表，覆盖</h1><p>spring.main.allow-bean-definition-overriding=true</p><p>#user_db 主服务器<br>spring.shardingsphere.datasource.m0.type=com.alibaba.druid.pool.DruidDataSource<br>spring.shardingsphere.datasource.m0.driver-class-name=com.mysql.cj.jdbc.Driver<br>spring.shardingsphere.datasource.m0.url=jdbc:mysql://10.211.55.26:33060/user_db?serverTimezone=GMT%2B8<br>spring.shardingsphere.datasource.m0.username=root<br>spring.shardingsphere.datasource.m0.password=123456</p><p>#user_db 从服务器<br>spring.shardingsphere.datasource.s0.type=com.alibaba.druid.pool.DruidDataSource<br>spring.shardingsphere.datasource.s0.driver-class-name=com.mysql.cj.jdbc.Driver<br>spring.shardingsphere.datasource.s0.url=jdbc:mysql://10.211.55.26:33061/user_db?serverTimezone=GMT%2B8<br>spring.shardingsphere.datasource.s0.username=root<br>spring.shardingsphere.datasource.s0.password=123456</p><h1 id="主库从库逻辑数据源定义-ds0-为-user-db"><a href="#主库从库逻辑数据源定义-ds0-为-user-db" class="headerlink" title="主库从库逻辑数据源定义 ds0 为 user_db"></a>主库从库逻辑数据源定义 ds0 为 user_db</h1><p>spring.shardingsphere.sharding.master-slave-rules.ds0.master-data-source-name=m0<br>spring.shardingsphere.sharding.master-slave-rules.ds0.slave-data-source-names=s0</p><h1 id="配置user-db数据库里面t-user-专库专表-1"><a href="#配置user-db数据库里面t-user-专库专表-1" class="headerlink" title="配置user_db数据库里面t_user  专库专表"></a>配置user_db数据库里面t_user  专库专表</h1><p>#spring.shardingsphere.sharding.tables.t_user.actual-data-nodes=m0.t_user</p><h1 id="t-user-分表策略，固定分配至-ds0-的-t-user-真实表"><a href="#t-user-分表策略，固定分配至-ds0-的-t-user-真实表" class="headerlink" title="t_user 分表策略，固定分配至 ds0 的 t_user 真实表"></a>t_user 分表策略，固定分配至 ds0 的 t_user 真实表</h1><p>spring.shardingsphere.sharding.tables.t_user.actual-data-nodes=ds0.t_user</p><h1 id="配置主键的生成策略-2"><a href="#配置主键的生成策略-2" class="headerlink" title="配置主键的生成策略"></a>配置主键的生成策略</h1><p>spring.shardingsphere.sharding.tables.t_user.key-generator.column=user_id<br>spring.shardingsphere.sharding.tables.t_user.key-generator.type=SNOWFLAKE</p><h1 id="指定分表策略-1"><a href="#指定分表策略-1" class="headerlink" title="指定分表策略"></a>指定分表策略</h1><p>spring.shardingsphere.sharding.tables.t_user.table-strategy.inline.sharding-column=user_id<br>spring.shardingsphere.sharding.tables.t_user.table-strategy.inline.algorithm-expression=t_user</p><h1 id="打开-sql-输出日志-2"><a href="#打开-sql-输出日志-2" class="headerlink" title="打开 sql 输出日志"></a>打开 sql 输出日志</h1><p>spring.shardingsphere.props.sql.show=true<br>1</p><p>测试代码使用垂直分库时编写的addUserDb和findUserDb方法。<br>addUserDb方法执行结果：</p><p>findUserDb方法执行结果：</p><p>三、Sharding-Proxy 分库分表操作<br>ShardingSphere-Proxy 简介</p><p>ShardingSphere-Proxy定位为透明的数据库代理端。<br>Sharding-Proxy独立应用，使用安装服务，进行分库分表或者读写分离配置、启动。<br>下载安装 Sharding-Proxy<br><a href="https://shardingsphere.apache.org/document/current/cn/downloads/" target="_blank" rel="noopener">https://shardingsphere.apache.org/document/current/cn/downloads/</a></p><p>下载解压后，需要把lib目录下后缀不全的jar包名补全。</p><p>配置 Sharding-Proxy（分库配置）<br>进入conf目录<br>修改 server.yaml 文件（此文件为Sharding-Proxy的配置），去除掉authentication和props的注释。</p><p>修改 config-sharding.yaml 配置文件（此文件为分库分表的配置）</p><p>文件里提示说，如果使用mysql，需要把mysql的驱动jar包放到lib目录下。（到maven下载的jar包里找即可）</p><p>在主mysql上新建一个edu_1数据库（create database edu_1;）<br>然后去掉文件中关于mysql的配置代码的注释，然后进行修改。（这里我连的是docker上的主mysql）<br>schemaName: sharding_db</p><p>dataSources:<br> ds_0:<br>   url: jdbc:mysql://10.211.55.26:33060/edu_1?serverTimezone=UTC&amp;useSSL=false<br>   username: root<br>   password: 123456<br>   connectionTimeoutMilliseconds: 30000<br>   idleTimeoutMilliseconds: 60000<br>   maxLifetimeMilliseconds: 1800000<br>   maxPoolSize: 50</p><p>shardingRule:<br> tables:<br>   t_order:<br>     actualDataNodes: ds_${0}.t_order_${0..1}<br>     tableStrategy:<br>       inline:<br>         shardingColumn: order_id<br>         algorithmExpression: t_order_${order_id % 2}<br>     keyGenerator:<br>       type: SNOWFLAKE<br>       column: order_id<br> bindingTables:</p><ul><li>t_order<br>defaultDatabaseStrategy:<br>inline:<br>shardingColumn: user_id<br>algorithmExpression: ds_${0}<br>defaultTableStrategy:<br>none:</li></ul><p>启动 Sharding-Proxy 服务<br>从终端进入到bin目录，然后./start.sh启动服务。（空格然后加上端口号，可以指定端口，默认3307）</p><p>如果打开logs目录里的stdout.log文件，显示下面这种，说明启动成功。</p><p>通过终端进行连接：<br>mysql -uroot -proot -P3307<br>如果出现下面这种错误，可以尝试连接命令加上-h127.0.0.1。</p><p>mysql -uroot -proot -h127.0.0.1 -P3307</p><p>新建一张表，并插入一条数据。<br>use sharding_db;</p><p>create table if not exists ds_0.t_order(<code>order_id</code> bigint primary key,<code>user_id</code> int not null,<code>status</code> varchar(50));</p><p>insert into t_order(<code>order_id</code>,<code>user_id</code>,<code>status</code>)values(11,1,’test’);</p><p>按照order_id进行分配，因为id是奇数所以被分到了t_order_1表里。</p><p>配置 Sharding-Proxy（读写分离）<br>Sharding-Proxy与Sharding-JDBC一样，并不会进行主从复制，主从复制依然是有MySQL自己完成。<br>mysql主从复制配置<br>把上面mysql主从复制的配置复制下来，方便查看：<a href="https://blog.csdn.net/qq_36903261/article/details/108457759" target="_blank" rel="noopener">https://blog.csdn.net/qq_36903261/article/details/108457759</a><br>使用docker后，需要在主服务器上新建原先的数据库数据表。<br>因为记录的文件名以及位点每次重启或刷新都会改变，所以以下命令放在这里，方便查看。<br>主mysql：<br>#确认位点 记录下文件名以及位点（重启或者刷新都会改变）<br>show master status;</p><p>从mysql：<br>#先停止同步<br>STOP SLAVE;</p><p>#修改从库指向到主库，使用上一步记录的文件名以及位点</p><h1 id="master-host-docker容器linux的ip地址-1"><a href="#master-host-docker容器linux的ip地址-1" class="headerlink" title="master_host docker容器linux的ip地址"></a>master_host docker容器linux的ip地址</h1><h1 id="master-port-主mysql暴露的端口-1"><a href="#master-port-主mysql暴露的端口-1" class="headerlink" title="master_port 主mysql暴露的端口"></a>master_port 主mysql暴露的端口</h1><h1 id="master-user-主mysql的用户名-1"><a href="#master-user-主mysql的用户名-1" class="headerlink" title="master_user 主mysql的用户名"></a>master_user 主mysql的用户名</h1><h1 id="master-password-主mysql的密码-1"><a href="#master-password-主mysql的密码-1" class="headerlink" title="master_password 主mysql的密码"></a>master_password 主mysql的密码</h1><p>#（最后两项修改成刚刚从主mysql查到的，主mysql每次刷新权限或者重启时，这两个值都会改变，所以每次都需要查看是否相同）<br>CHANGE MASTER TO<br>master_host = ‘10.211.55.26’,<br>master_port = 33060,<br>master_user = ‘db_sync’,<br>master_password = ‘db_sync’,<br>master_log_file = ‘mysql-bin.000001’,<br>master_log_pos = 823;</p><p>#启动同步<br>START SLAVE;</p><p>#查看Slave_IO_Runing和Slave_SQL_Runing字段值都为Yes，表示同步配置成功。<br>show slave status \G;</p><p>老师这里只演示读写分离，并没有mysql的主从复制，我写的是主从复制，读写分离。<br>#主mysql<br>create database master_slave_order;</p><p>1<br>2<br>Sharding-Proxy 配置<br>修改 config-master_slave.yaml 文件（此文件为读写分离的配置）<br>schemaName: master_slave_db</p><p>dataSources:<br> master_ds:<br>   url: jdbc:mysql://10.211.55.26:33060/master_slave_order?serverTimezone=UTC&amp;useSSL=false&amp;allowPublicKeyRetrieval=true<br>   username: root<br>   password: 123456<br>   connectionTimeoutMilliseconds: 30000<br>   idleTimeoutMilliseconds: 60000<br>   maxLifetimeMilliseconds: 1800000<br>   maxPoolSize: 50<br> slave_ds_0:<br>   url: jdbc:mysql://10.211.55.26:33061/master_slave_order?serverTimezone=UTC&amp;useSSL=false&amp;allowPublicKeyRetrieval=true<br>   username: root<br>   password: 123456<br>   connectionTimeoutMilliseconds: 30000<br>   idleTimeoutMilliseconds: 60000<br>   maxLifetimeMilliseconds: 1800000<br>   maxPoolSize: 50</p><p>masterSlaveRule:<br> name: ms_ds<br> masterDataSourceName: master_ds<br> slaveDataSourceNames:</p><ul><li>slave_ds_0<h1 id="slave-ds-1"><a href="#slave-ds-1" class="headerlink" title="- slave_ds_1"></a>- slave_ds_1</h1></li></ul><p>测试<br>启动Sharding-Proxy 服务 ./start.sh</p><p>出现这个错误：</p><p>在url上加上&amp;allowPublicKeyRetrieval=true即可。<br>连接sharding-proxy</p><p>创建数据表<br>use master_slave_db;</p><p>create table if not exists master_slave_order.t_order(<code>order_id</code> bigint primary key,<code>user_id</code> int not null,<code>status</code> varchar(50));</p><p>insert into t_order(<code>order_id</code>,<code>user_id</code>,<code>status</code>)values(11,1,’test’);</p><p>只修改从mysql中的数据</p><p>查询数据<br>select * from t_order;</p><p>说明，写入的是主mysql，然后主从复制，从mysql也有了数据，读取的是从mysql。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;数据库链接池过多，或者导致数据库挂了，如果主备机切换，需要更改配置&lt;br&gt;java应用与数据库紧耦合&lt;/p&gt;
&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
         
      
    
    </summary>
    
    
    
      <category term="中间件" scheme="kkget.github.io/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>JVM调优相关</title>
    <link href="kkget.github.io/2020/09/24/JVM%E8%B0%83%E4%BC%98%E7%9B%B8%E5%85%B3/"/>
    <id>kkget.github.io/2020/09/24/JVM%E8%B0%83%E4%BC%98%E7%9B%B8%E5%85%B3/</id>
    <published>2020-09-24T02:35:48.000Z</published>
    <updated>2020-09-30T02:59:29.113Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线上系统CPU，内存与磁盘IO暴增，你会如何调优？"><a href="#线上系统CPU，内存与磁盘IO暴增，你会如何调优？" class="headerlink" title="线上系统CPU，内存与磁盘IO暴增，你会如何调优？"></a>线上系统CPU，内存与磁盘IO暴增，你会如何调优？</h1><p>①首先top命令确定到具体线程，将内存与io异常的线程记录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[root@zhaokk logs]# top</span><br><span class="line">top - <span class="number">16</span>:<span class="number">48</span>:<span class="number">59</span> up <span class="number">2</span> days, <span class="number">23</span>:<span class="number">23</span>,  <span class="number">1</span> user,  load average: <span class="number">0.00</span>, <span class="number">0.01</span>, <span class="number">0.20</span></span><br><span class="line">Tasks: <span class="number">1784</span> total,   <span class="number">2</span> running, <span class="number">1354</span> sleeping,   <span class="number">0</span> stopped, <span class="number">428</span> zombie</span><br><span class="line">%Cpu(s):  <span class="number">0.0</span> us,  <span class="number">0.0</span> sy,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> wa,  <span class="number">0.0</span> hi,  <span class="number">0.0</span> si,  <span class="number">0.0</span> st</span><br><span class="line">KiB Mem :  <span class="number">1882736</span> total,    <span class="number">70640</span> free,  <span class="number">1526212</span> used,   <span class="number">285884</span> buff/cache</span><br><span class="line">KiB Swap:        <span class="number">0</span> total,        <span class="number">0</span> free,        <span class="number">0</span> used.    <span class="number">29260</span> avail Mem </span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND                                                                                                   </span><br><span class="line"><span class="number">17755</span> root      <span class="number">20</span>   <span class="number">0</span>  <span class="number">165676</span>   <span class="number">4060</span>   <span class="number">1600</span> R  <span class="number">3.2</span>  <span class="number">0.2</span>   <span class="number">0</span>:<span class="number">00.79</span> top                                                                                                       </span><br><span class="line"><span class="number">15120</span> root      <span class="number">10</span> -<span class="number">10</span>  <span class="number">134524</span>   <span class="number">6240</span>   <span class="number">1140</span> S  <span class="number">1.0</span>  <span class="number">0.3</span>   <span class="number">1</span>:<span class="number">04.54</span> AliYunDun                                                                                                 </span><br><span class="line"> <span class="number">1325</span> root      <span class="number">10</span> -<span class="number">10</span>  <span class="number">438960</span>    <span class="number">676</span>     <span class="number">80</span> S  <span class="number">0.3</span>  <span class="number">0.0</span>  <span class="number">12</span>:<span class="number">14.54</span> AliSecGuard                                                                                               </span><br><span class="line"> <span class="number">7688</span> root      <span class="number">20</span>   <span class="number">0</span> <span class="number">2522072</span>  <span class="number">86580</span>   <span class="number">2172</span> S  <span class="number">0.3</span>  <span class="number">4.6</span>   <span class="number">0</span>:<span class="number">33.20</span> java                                                                                                      </span><br><span class="line">    <span class="number">1</span> root      <span class="number">20</span>   <span class="number">0</span>  <span class="number">120276</span>  <span class="number">60392</span>    <span class="number">640</span> S  <span class="number">0.0</span>  <span class="number">3.2</span>   <span class="number">4</span>:<span class="number">37.34</span> systemd                                                                                                   </span><br><span class="line">    <span class="number">2</span> root      <span class="number">20</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.01</span> kthreadd                                                                                                  </span><br><span class="line">    <span class="number">3</span> root      <span class="number">20</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">31.43</span> ksoftirqd/<span class="number">0</span>                                                                                               </span><br><span class="line">    <span class="number">5</span> root       <span class="number">0</span> -<span class="number">20</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> kworker/<span class="number">0</span>:<span class="number">0</span>H                                                                                              </span><br><span class="line">    <span class="number">7</span> root      rt   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> migration/<span class="number">0</span>                                                                                               </span><br><span class="line">    <span class="number">8</span> root      <span class="number">20</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> rcu_bh                                                                                                    </span><br><span class="line">    <span class="number">9</span> root      <span class="number">20</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> R  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">6</span>:<span class="number">31.17</span> rcu_sched                                                                                                 </span><br><span class="line">   <span class="number">10</span> root       <span class="number">0</span> -<span class="number">20</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> lru-add-drain                                                                                             </span><br><span class="line">   <span class="number">13</span> root      <span class="number">20</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> kdevtmpfs                                                                                                 </span><br><span class="line">   <span class="number">14</span> root       <span class="number">0</span> -<span class="number">20</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> netns                                                                                                     </span><br><span class="line">   <span class="number">15</span> root      <span class="number">20</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.69</span> khungtaskd                                                                                                </span><br><span class="line">   <span class="number">16</span> root       <span class="number">0</span> -<span class="number">20</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.03</span> writeback                                                                                                 </span><br><span class="line">   <span class="number">17</span> root       <span class="number">0</span> -<span class="number">20</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> kintegrityd                                                                                               </span><br><span class="line">   <span class="number">18</span> root       <span class="number">0</span> -<span class="number">20</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> bioset                                                                                                    </span><br><span class="line">   <span class="number">19</span> root       <span class="number">0</span> -<span class="number">20</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> bioset                                                                                                    </span><br><span class="line">   <span class="number">20</span> root       <span class="number">0</span> -<span class="number">20</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> bioset</span><br></pre></td></tr></table></figure><p>②查看磁盘IO </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sar -d -p <span class="number">1</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="number">09</span>:<span class="number">51</span>:<span class="number">48</span> AM       DEV       tps     rkB/s     wkB/s   areq-sz    aqu-sz     await     svctm     %util</span><br><span class="line"><span class="number">09</span>:<span class="number">51</span>:<span class="number">49</span> AM       vda      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span></span><br><span class="line"><span class="number">09</span>:<span class="number">51</span>:<span class="number">50</span> AM       vda      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span></span><br><span class="line">Average:          vda      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span></span><br></pre></td></tr></table></figure><p>其中， “-d”参数代表查看磁盘性能，“-p”参数代表将 dev 设备按照 sda，sdb……名称显示，“1”代表每隔1s采取一次数值，“2”代表总共采取2次数值。<br>await：平均每次设备 I/O 操作的等待时间（以毫秒为单位）。<br>svctm：平均每次设备 I/O 操作的服务时间（以毫秒为单位）。<br>%util：一秒中有百分之几的时间用于 I/O 操作<br>磁盘IO标准:<br>正常情况下 svctm 应该是小于 await 值的，而 svctm 的大小和磁盘性能有关，CPU 、内存的负荷也会对 svctm 值造成影响，过多的请求也会间接的导致 svctm 值的增加。<br>await 值的大小一般取决与 svctm 的值和 I/O 队列长度以 及I/O 请求模式，如果 svctm 的值与 await 很接近，表示几乎没有 I/O 等待，磁盘性能很好，如果 await 的值远高于 svctm 的值，则表示 I/O 队列等待太长，系统上运行的应用程序将变慢，此时可以通过更换更快的硬盘来解决问题。<br>%util 项的值也是衡量磁盘 I/O 的一个重要指标，如果 %util 接近 100% ，表示磁盘产生的 I/O 请求太多，I/O 系统已经满负荷的在工作，该磁盘可能存在瓶颈。长期下去，势必影响系统的性能，可以通过优化程序或者通过更换更高、更快的磁盘来解决此问题<br>③.确定好具体线程后定位具体代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef|grep <span class="number">2588</span>|grep -v grep</span><br></pre></td></tr></table></figure><p>④定位</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -mp <span class="number">2588</span> -o THREAD,tid,time</span><br></pre></td></tr></table></figure><p>⑤换算16进制后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack <span class="number">2588</span> |grep a1d -A60</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/jvm/1.png" alt="图1" title="">                </div>                <div class="image-caption">图1</div>            </figure><p>接下来就处理是逻辑问题，还是代码，还是数据库问题了</p><h1 id="你们JVM线上使用的什么垃圾回收器？CMS还是G1？"><a href="#你们JVM线上使用的什么垃圾回收器？CMS还是G1？" class="headerlink" title="你们JVM线上使用的什么垃圾回收器？CMS还是G1？"></a>你们JVM线上使用的什么垃圾回收器？CMS还是G1？</h1><p>我们线上由于使用的java8，默认垃圾回收器G1，如果不知道，可以打印下GC，-XX:PrintGCDetails,<br>windows查看收集器</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/jvm/2.png" alt="图1" title="">                </div>                <div class="image-caption">图1</div>            </figure><p>Linux 查看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+PrintCommandLineFlags -version</span><br><span class="line">-XX:InitialHeapSize=<span class="number">260062400</span> -XX:MaxHeapSize=<span class="number">4160998400</span> -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseParallelGC </span><br><span class="line">java version <span class="string">"1.8.0_261"</span></span><br><span class="line">Java(TM) <span class="function">SE Runtime <span class="title">Environment</span> <span class="params">(build <span class="number">1.8</span><span class="number">.0</span>_261-b12)</span></span></span><br><span class="line"><span class="function">Java <span class="title">HotSpot</span><span class="params">(TM)</span> 64-Bit Server <span class="title">VM</span> <span class="params">(build <span class="number">25.261</span>-b12, mixed mode)</span></span></span><br></pre></td></tr></table></figure><p>-XX:+UseParallelGC</p><h1 id="垃圾收集器种类"><a href="#垃圾收集器种类" class="headerlink" title="垃圾收集器种类"></a>垃圾收集器种类</h1><p>垃圾回收器：并行  串行   并发标记(CMS)  G1    ZGC</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java15 ZGC转正</span><br><span class="line">ZGC 功能转正</span><br><span class="line">ZGC是一个可伸缩、低延迟的垃圾回收器。</span><br><span class="line">ZGC 已由JEP <span class="number">333</span>集成到JDK <span class="number">11</span> 中，其目标是通过减少 GC 停顿时间来提高性能。借助 JEP <span class="number">377</span>，JDK <span class="number">15</span> 将 ZGC 垃圾收集器从预览特性变更为正式特性而已，没错，转正了。</span><br><span class="line">这个 JEP 不会更改默认的 GC，默认仍然是 G1。</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/jvm/3.png" alt="图" title="">                </div>                <div class="image-caption">图</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/jvm/4.png" alt="图" title="">                </div>                <div class="image-caption">图</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/jvm/5.png" alt="图" title="">                </div>                <div class="image-caption">图</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/jvm/6.png" alt="图" title="">                </div>                <div class="image-caption">图</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/jvm/7.png" alt="图" title="">                </div>                <div class="image-caption">图</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/jvm/8.png" alt="图" title="">                </div>                <div class="image-caption">图</div>            </figure><h1 id="CMS的并发更新失败是怎么回事？如何优化？"><a href="#CMS的并发更新失败是怎么回事？如何优化？" class="headerlink" title="CMS的并发更新失败是怎么回事？如何优化？"></a>CMS的并发更新失败是怎么回事？如何优化？</h1><p>CMS垃圾回收失败类型主要是两种：并发失效和晋升失败<br>并发失效<br>在新生代(YoungGen)发生垃圾回收时，达到晋升年龄的对象会被移动到老年代(OldGen)中。<br>如果老年代没有足够的空间容纳这个晋升对象，CMS为了腾出老年代空间，就会从本来的MinorGC退化成FullGC。<br>MinorGC只回收新生代，而FullGC不仅回收新生代，而且还会回收老年代，永久区(PermGen)或元区(MetaSpace)空间回收也可能随FullGC顺便执行。<br>本来只是简单的新生代回收工作扩大到老年代甚至更大。除此之外，老年代空间通常比新生代的Eden和Survivor区大得多，检查和清理无效对象的时间要多得多。<br>还有，FullGC回收的同时，所有进程必须StopTheWorld，并用单线程(SerialGC)开始垃圾回收。导致本来可以并发的MinorGC变得缓慢无比。<br>晋升失败<br>晋升失败同样是老年代导致的问题。<br>CMS开启新生代垃圾收集的时候，判断老年代似乎有足够空间容纳所有晋升对象。<br>然而晋升的时候才发现老年代的空间竟然都是碎片化的，根本容纳不了一个完整的晋升对象。<br>剩下出路只有内存整理。所有应用运行的线程停止，CMS开始对老年代进行整理和压缩。<br>空间压缩要通过移动里面的对象，令这些对象排列好，所以晋升失败比不需要移动对象的并发失效更加浪费时间。<br>完成清理的堆空间变得规整和空余，继续运行应用。<br>调优<br>并发失效调优：<br>令老生代垃圾回收提早，增大回收频率<br>增大老年代空间<br>增大新生代空间，提高对象滞留时间，更多新对象被回收而不是晋升。<br>增加更多后台回收线程<br>晋升失败调优：<br>有难度，因为CMS本身不能规整Compat内存，只能退化到SerialGC来做<br>尝试用G1，G1的内存模型更加先进</p><h1 id="JVM是任何时刻都可以STW吗？为什么？"><a href="#JVM是任何时刻都可以STW吗？为什么？" class="headerlink" title="JVM是任何时刻都可以STW吗？为什么？"></a>JVM是任何时刻都可以STW吗？为什么？</h1><p>STW即停顿类型<br>垃圾回收并不会阻塞我们程序的线程，他是与当前程序并发执行的。所以问题就出在这里，当GC线程标记好了一个对象的时候，此时我们程序的线程又将该对象重新加入了“关系网”中，当执行二次标记的时候，该对象也没有重写finalize()方法，因此回收的时候就会回收这个不该回收的对象。<br>  虚拟机的解决方法就是在一些特定指令位置设置一些“安全点”，当程序运行到这些“安全点”的时候就会暂停所有当前运行的线程（Stop The World 所以叫STW），暂停后再找到“GC Roots”进行关系的组建，进而执行标记和清除<br>这些特定的指令（安全点）位置主要在：<br>1、循环的末尾<br>2、方法临返回前 / 调用方法的call指令后<br>3、可能抛异常的位置<br>那个停顿类型就是STW，至于有GC和Full GC之分，还有Full GC (System)。个人认为主要是Full GC时STW的时间相对GC来说时间很长，因为Full GC针对整个堆以及永久代的，因此整个GC的范围大大增加；还有就是他的回收算法就是我们之前说过的“标记–清除–整理”，这里也会损耗一定的时间。所以我们在优化JVM的时候，减少Full GC的次数也是经常用到的办法。<br>5、线上系统GC问题如何快速定位与分析？阿里巴巴的Arthas用过吗？<br>Arthas单独去学就好<br>6、单机几十万并发的系统JVM如何优化？<br>既然说了单机了，服务单机，就把中间件去集群化<br>redis+二级缓存+mq+数据库优化<br>7、高并发系统为何建议选择G1垃圾收集器？<br>上面G1特点已经讲过了<br>8、能说说Mysql索引底层B+树结构与算法吗？<br>B+树中的B代表平衡（balance），而不是二叉（binary）<br>B-Tree：平衡二叉树<br>特点：<br>        1.具有数据节点<br>        2.指向下层指针<br>        3.指向数据指针<br>缺页查询,产生IO<br>B+Tree：<br>特点:<br>       1.具有数据节点<br>       2.指向下层指针<br>命中数据3层查找后查询数据指针<br>加载更快，产生更少IO<br>效率：BTree更高，但从IO角度，Mysql选择B+Tree</p><p>B+tree算法<br>插入算法<br>删除算法</p><p><a href="https://www.codedump.info/post/20200615-btree-2/" target="_blank" rel="noopener">https://www.codedump.info/post/20200615-btree-2/</a></p><h1 id="聚集索引与覆盖索引与索引下推到底是什么？"><a href="#聚集索引与覆盖索引与索引下推到底是什么？" class="headerlink" title="聚集索引与覆盖索引与索引下推到底是什么？"></a>聚集索引与覆盖索引与索引下推到底是什么？</h1><p>聚集索引和组合索引<br>索引<br>表的数据量比较大时，查询操作会很耗时。建立索引是加快查询速度的有效手段。<br>数据库索引就类似于书签，可以快速定位到要查询的内容。数据库索引类型<br>有顺序文件索引，B+树索引，散列索引，位图索引。其中B+树索引应用广泛。<br>在B+树上的查找，删除，插入的代价为O ( l o g N ) O(log N)O(logN)。建立索引有好处，当然也有<br>缺点。索引会占额外存储空间。每次数据更新时，也要用额外的时间来维护索引。</p><h1 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h1><p>一张表里面只能有一个聚集索引，一般设置主键为索引。<br>数据库中行数据的物理顺序和索引顺序相同。这样的索引称为聚集索引。<br>一张表只有一个物理顺序，也就只能有一个聚集索引。</p><h1 id="组合索引-覆盖索引"><a href="#组合索引-覆盖索引" class="headerlink" title="组合索引(覆盖索引)"></a>组合索引(覆盖索引)</h1><p>定义：包含两个或多个属性列的索引称为复合索引。</p><h1 id="索引下推-Index-Condition-Pushdown"><a href="#索引下推-Index-Condition-Pushdown" class="headerlink" title="索引下推 Index Condition Pushdown"></a>索引下推 Index Condition Pushdown</h1><p>官网描述</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">The goal of ICP is to reduce the number of full-record </span><br><span class="line">reads and thereby reduce IO operations. For InnoDB clustered indexes,</span><br><span class="line">the complete record is already read into the InnoDB buffer.</span><br><span class="line">Using ICP in <span class="keyword">this</span> <span class="keyword">case</span> does not reduce IO.</span><br><span class="line">ICP的目标是减少完整记录读取的次数，从而减少IO操作。对于InnoDB聚集索引，</span><br><span class="line">完整的记录已经被读入InnoDB缓冲区。在这种情况下使用ICP不会减少IO。</span><br></pre></td></tr></table></figure><p>10、能说说Mysql并发支撑底层Buffer Pool机制吗？<br>一个缓冲池，来来回回还是缓存+池化思想那一套<br>11、一线互联网公司的数据库架构是如何设计的?<br>我愿意咋设计就咋设计(*￣︶￣)<br>先从业务逻辑上避免复杂关联库，冗余字段等<br>记录表等多次查询的字段建索引<br>多用标识性字段不用 is null等操作<br>12.阿里微服务分布式事务Seata源码深度剖析</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/jvm/9.png" alt="图" title="">                </div>                <div class="image-caption">图</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/jvm/10.png" alt="图" title="">                </div>                <div class="image-caption">图</div>            </figure><p>13:动态链接与常量池<br>大部分字节码质量在执行的时候，都需要常量池的访问<br>指向运行时常量池的方法引用<br>方法的绑定机制<br>静态链接:编译期可确定</p><p>动态链接:编译期无法确定</p><p>早期绑定:同</p><p>晚期绑定:同理</p><p>方法调用指令区分虚方法与非虚方法</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/jvm/11.png" alt="图" title="">                </div>                <div class="image-caption">图</div>            </figure><p>14：</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;线上系统CPU，内存与磁盘IO暴增，你会如何调优？&quot;&gt;&lt;a href=&quot;#线上系统CPU，内存与磁盘IO暴增，你会如何调优？&quot; class=&quot;headerlink&quot; title=&quot;线上系统CPU，内存与磁盘IO暴增，你会如何调优？&quot;&gt;&lt;/a&gt;线上系统CPU，内存与
      
    
    </summary>
    
    
    
      <category term="JVM" scheme="kkget.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>【声明】阿里云服务器导致图片不显示</title>
    <link href="kkget.github.io/2020/08/17/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AF%BC%E8%87%B4%E5%9B%BE%E7%89%87%E4%B8%8D%E6%98%BE%E7%A4%BA/"/>
    <id>kkget.github.io/2020/08/17/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AF%BC%E8%87%B4%E5%9B%BE%E7%89%87%E4%B8%8D%E6%98%BE%E7%A4%BA/</id>
    <published>2020-08-17T02:13:48.000Z</published>
    <updated>2020-09-28T09:02:08.241Z</updated>
    
    <content type="html"><![CDATA[<p>图片服务器原因不定期修复…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;图片服务器原因不定期修复…&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="置顶" scheme="kkget.github.io/categories/%E7%BD%AE%E9%A1%B6/"/>
    
    
      <category term="声明" scheme="kkget.github.io/tags/%E5%A3%B0%E6%98%8E/"/>
    
  </entry>
  
  <entry>
    <title>有没有有顺序的Map实现类，如果有，他们是怎么保证有序的。</title>
    <link href="kkget.github.io/2020/08/05/%E6%9C%89%E6%B2%A1%E6%9C%89%E6%9C%89%E9%A1%BA%E5%BA%8F%E7%9A%84Map%E5%AE%9E%E7%8E%B0%E7%B1%BB%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%9C%89%EF%BC%8C%E4%BB%96%E4%BB%AC%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E6%9C%89%E5%BA%8F%E7%9A%84%E3%80%82/"/>
    <id>kkget.github.io/2020/08/05/%E6%9C%89%E6%B2%A1%E6%9C%89%E6%9C%89%E9%A1%BA%E5%BA%8F%E7%9A%84Map%E5%AE%9E%E7%8E%B0%E7%B1%BB%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%9C%89%EF%BC%8C%E4%BB%96%E4%BB%AC%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E6%9C%89%E5%BA%8F%E7%9A%84%E3%80%82/</id>
    <published>2020-08-05T03:26:52.000Z</published>
    <updated>2020-08-05T08:35:46.183Z</updated>
    
    <content type="html"><![CDATA[<p>1，sortedMap，NavigableMap，TreeMap，ConcurrentSkipListMap<br>主要看下ConcurrentSkipListMap</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentSkipListMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">ConcurrentNavigableMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>1.类图</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/skipListMap.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>底层数据结构是skipList(跳表)<br><a href="https://segmentfault.com/a/1190000016168566?utm_source=tag-newest" target="_blank" rel="noopener">https://segmentfault.com/a/1190000016168566?utm_source=tag-newest</a><br>这篇文章对跳表解析的比较清晰<br>2.构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentSkipListMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.comparator = <span class="keyword">null</span>;</span><br><span class="line">        initialize();</span><br><span class="line">    &#125;</span><br><span class="line">ConcurrentSkipListMap会基于比较器——Comparator ，来进行键Key的比较，如果构造时未指定Comparator ，那么就会按照Key的自然顺序进行比较，所谓Key的自然顺序是指key实现Comparable接口。</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentSkipListMap</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> K&gt; comparator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">        initialize();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentSkipListMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.comparator = <span class="keyword">null</span>;</span><br><span class="line">        initialize();</span><br><span class="line">        putAll(m);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentSkipListMap</span><span class="params">(SortedMap&lt;K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.comparator = m.comparator();</span><br><span class="line">        initialize();</span><br><span class="line">        buildFromSorted(m);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>put方法 K,V都不能为null</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">return</span> doPut(key, value, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">doPut</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; z;             <span class="comment">// added node</span></span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        Comparator&lt;? <span class="keyword">super</span> K&gt; cmp = comparator;</span><br><span class="line">        outer: <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;K,V&gt; b = findPredecessor(key, cmp), n = b.next;;) &#123;</span><br><span class="line">                <span class="keyword">if</span> (n != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Object v; <span class="keyword">int</span> c;</span><br><span class="line">                    Node&lt;K,V&gt; f = n.next;</span><br><span class="line">                    <span class="keyword">if</span> (n != b.next)               <span class="comment">// inconsistent read</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">if</span> ((v = n.value) == <span class="keyword">null</span>) &#123;   <span class="comment">// n is deleted</span></span><br><span class="line">                        n.helpDelete(b, f);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (b.value == <span class="keyword">null</span> || v == n) <span class="comment">// b is deleted</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">if</span> ((c = cpr(cmp, key, n.key)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        b = n;</span><br><span class="line">                        n = f;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (onlyIfAbsent || n.casValue(v, value)) &#123;</span><br><span class="line">                            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) V vv = (V)v;</span><br><span class="line">                            <span class="keyword">return</span> vv;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>; <span class="comment">// restart if lost race to replace value</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// else c &lt; 0; fall through</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                z = <span class="keyword">new</span> Node&lt;K,V&gt;(key, value, n);</span><br><span class="line">                <span class="keyword">if</span> (!b.casNext(n, z))</span><br><span class="line">                    <span class="keyword">break</span>;         <span class="comment">// restart if lost race to append to b</span></span><br><span class="line">                <span class="keyword">break</span> outer;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> rnd = ThreadLocalRandom.nextSecondarySeed();</span><br><span class="line">        <span class="keyword">if</span> ((rnd &amp; <span class="number">0x80000001</span>) == <span class="number">0</span>) &#123; <span class="comment">// test highest and lowest bits</span></span><br><span class="line">            <span class="keyword">int</span> level = <span class="number">1</span>, max;</span><br><span class="line">            <span class="keyword">while</span> (((rnd &gt;&gt;&gt;= <span class="number">1</span>) &amp; <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">                ++level;</span><br><span class="line">            Index&lt;K,V&gt; idx = <span class="keyword">null</span>;</span><br><span class="line">            HeadIndex&lt;K,V&gt; h = head;</span><br><span class="line">            <span class="keyword">if</span> (level &lt;= (max = h.level)) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= level; ++i)</span><br><span class="line">                    idx = <span class="keyword">new</span> Index&lt;K,V&gt;(z, idx, <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// try to grow by one level</span></span><br><span class="line">                level = max + <span class="number">1</span>; <span class="comment">// hold in array and later pick the one to use</span></span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)Index&lt;K,V&gt;[] idxs =</span><br><span class="line">                    (Index&lt;K,V&gt;[])<span class="keyword">new</span> Index&lt;?,?&gt;[level+<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= level; ++i)</span><br><span class="line">                    idxs[i] = idx = <span class="keyword">new</span> Index&lt;K,V&gt;(z, idx, <span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                    h = head;</span><br><span class="line">                    <span class="keyword">int</span> oldLevel = h.level;</span><br><span class="line">                    <span class="keyword">if</span> (level &lt;= oldLevel) <span class="comment">// lost race to add level</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    HeadIndex&lt;K,V&gt; newh = h;</span><br><span class="line">                    Node&lt;K,V&gt; oldbase = h.node;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = oldLevel+<span class="number">1</span>; j &lt;= level; ++j)</span><br><span class="line">                        newh = <span class="keyword">new</span> HeadIndex&lt;K,V&gt;(oldbase, newh, idxs[j], j);</span><br><span class="line">                    <span class="keyword">if</span> (casHead(h, newh)) &#123;</span><br><span class="line">                        h = newh;</span><br><span class="line">                        idx = idxs[level = oldLevel];</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// find insertion points and splice in</span></span><br><span class="line">            splice: <span class="keyword">for</span> (<span class="keyword">int</span> insertionLevel = level;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = h.level;</span><br><span class="line">                <span class="keyword">for</span> (Index&lt;K,V&gt; q = h, r = q.right, t = idx;;) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (q == <span class="keyword">null</span> || t == <span class="keyword">null</span>)</span><br><span class="line">                        <span class="keyword">break</span> splice;</span><br><span class="line">                    <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; n = r.node;</span><br><span class="line">                        <span class="comment">// compare before deletion check avoids needing recheck</span></span><br><span class="line">                        <span class="keyword">int</span> c = cpr(cmp, key, n.key);</span><br><span class="line">                        <span class="keyword">if</span> (n.value == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (!q.unlink(r))</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            r = q.right;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (c &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            q = r;</span><br><span class="line">                            r = r.right;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (j == insertionLevel) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!q.link(r, t))</span><br><span class="line">                            <span class="keyword">break</span>; <span class="comment">// restart</span></span><br><span class="line">                        <span class="keyword">if</span> (t.node.value == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            findNode(key);</span><br><span class="line">                            <span class="keyword">break</span> splice;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (--insertionLevel == <span class="number">0</span>)</span><br><span class="line">                            <span class="keyword">break</span> splice;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (--j &gt;= insertionLevel &amp;&amp; j &lt; level)</span><br><span class="line">                        t = t.down;</span><br><span class="line">                    q = q.down;</span><br><span class="line">                    r = q.right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>get方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> doGet(key);</span><br><span class="line">    &#125;</span><br><span class="line">Comparator方法比较后保证key来排序的，</span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">doGet</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        Comparator&lt;? <span class="keyword">super</span> K&gt; cmp = comparator;</span><br><span class="line">        outer: <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;K,V&gt; b = findPredecessor(key, cmp), n = b.next;;) &#123;</span><br><span class="line">                Object v; <span class="keyword">int</span> c;</span><br><span class="line">                <span class="keyword">if</span> (n == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">break</span> outer;</span><br><span class="line">                Node&lt;K,V&gt; f = n.next;</span><br><span class="line">                <span class="keyword">if</span> (n != b.next)                <span class="comment">// inconsistent read</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> ((v = n.value) == <span class="keyword">null</span>) &#123;    <span class="comment">// n is deleted</span></span><br><span class="line">                    n.helpDelete(b, f);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (b.value == <span class="keyword">null</span> || v == n)  <span class="comment">// b is deleted</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> ((c = cpr(cmp, key, n.key)) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) V vv = (V)v;</span><br><span class="line">                    <span class="keyword">return</span> vv;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (c &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span> outer;</span><br><span class="line">                b = n;</span><br><span class="line">                n = f;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1，sortedMap，NavigableMap，TreeMap，ConcurrentSkipListMap&lt;br&gt;主要看下ConcurrentSkipListMap&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cla
      
    
    </summary>
    
    
    
      <category term="Map" scheme="kkget.github.io/tags/Map/"/>
    
  </entry>
  
  <entry>
    <title>重视Netty源码解析</title>
    <link href="kkget.github.io/2020/08/03/%E9%87%8D%E8%A7%86Netty%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>kkget.github.io/2020/08/03/%E9%87%8D%E8%A7%86Netty%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</id>
    <published>2020-08-03T07:01:15.000Z</published>
    <updated>2020-08-03T07:50:10.737Z</updated>
    
    <content type="html"><![CDATA[<p>第一次学习Netty可追溯到2019年1月，现在重新阅读多篇资料和源码后自己以个人能够理解的方式总结下Netty，参考多篇资料<br>1.Netty是啥<br>官网定义<br>Netty是 一个异步事件驱动的网络应用程序框架，用于快速开发可维护的高性能协议服务器和客户端。<br>学习Netty之前，通篇讲述了Channel，selector，selectionKey，以便于理解Netty的Reactor模型，并且从AIO，BIO,NIO讲解<br>从服务端代码入手</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WSServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        EventLoopGroup mainGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup subGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap server = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            server.group(mainGroup, subGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                    .<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">WSServerInitialzer</span>())</span>;</span><br><span class="line"></span><br><span class="line">            ChannelFuture future = server.bind(<span class="number">8088</span>).sync();</span><br><span class="line">            <span class="keyword">if</span> (future.isSuccess()) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Netty启动成功.............."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainGroup.shutdownGracefully();</span><br><span class="line">            subGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1：这里官方定义的mainGroup和subGroup命名为boss和worker，从这里第一时间就想到了Nginx的工作原理master-workers机制，像不像？相似度90%。<br>首先，对于每个worker进程来说，独立的进程，不需要加锁，<br>所以省掉了锁带来的开销，同时在编程以及问题查找时，也会方<br>便很多。<br>其次，采用独立的进程，可以让互相之间不会影响，一个进程<br>退出后，其它进程还在工作，服务不会中断，master进程则很快启<br>动新的worker进程。当然，worker进程的异常退出，肯定是程序有<br>bug了，异常退出，会导致当前worker上的所有请求失败，不过不<br>会影响到所有请求，所以降低了风险<br>并且Nginx也采用了多路Io复用机制</p><p>#Reactor线程模型<br>Reactor 对应的叫法: 1. 反应器模式 2. 分发者模式(Dispatcher) 3. 通知者模式(notifier)</p><p>Netty模型 Reactor<br>1.Reactor对象通过select监控客户端请求事件，收到后通过dispatch分发<br>2.建立连接请求，由acceptor通过accept处理，创建一个handler对象处理完成连接后的事件。<br>3.如果不是连接请求，则由Reactor对象分发调用连接对应的handler响应<br>4.handler只负责响应事件，不做具体业务处理，通过read方法读取数据后分发给work线程池里的线程处理<br>5.work线程池分配独立线程完成真正的业务，并将结果返回<br>优点：充分利用多核CPU能力<br>缺点：多个线程会数据共享和访问比较复杂，多线程场景出现性能瓶颈</p><p>主从reactor多线程模式<br>1.主线程只管连接<br>2.子线程管处理请求，一个子线程监听多个client，io读取，业务处理往下分配<br>3.当有新事件发生，subReactor调用对应的handler处理</p><p>2：NioEventGroup类图</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/NioEventGroup.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>最上层是什么？不就是线程池的执行接口么，启动时，真正执行的方法是其父类的父类MultithreadEventExecutorGroup的方法调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">MultithreadEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor, Object... args)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>(nThreads == <span class="number">0</span> ? DEFAULT_EVENT_LOOP_THREADS : nThreads, executor, args);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>调到这时，传入的nThreads为0，DEFAULT_EVENT_LOOP_THREADS进行赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_EVENT_LOOP_THREADS;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> &#123;</span><br><span class="line">       DEFAULT_EVENT_LOOP_THREADS = Math.max(<span class="number">1</span>, SystemPropertyUtil.getInt(</span><br><span class="line">               <span class="string">"io.netty.eventLoopThreads"</span>, NettyRuntime.availableProcessors() * <span class="number">2</span>));</span><br><span class="line">       <span class="comment">//CPU核心数的数量乘2</span></span><br><span class="line">       <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">           logger.debug(<span class="string">"-Dio.netty.eventLoopThreads: &#123;&#125;"</span>, DEFAULT_EVENT_LOOP_THREADS);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>那么到MultithreadEventExecutorGroup方法时就变成了8  executor为null</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/debug1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/debug2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">MultithreadEventExecutorGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           EventExecutorChooserFactory chooserFactory, Object... args)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (nThreads &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(<span class="string">"nThreads: %d (expected: &gt; 0)"</span>, nThreads));</span><br><span class="line">       &#125;</span><br><span class="line">executor初始化</span><br><span class="line">       <span class="keyword">if</span> (executor == <span class="keyword">null</span>) &#123;</span><br><span class="line">           executor = <span class="keyword">new</span> ThreadPerTaskExecutor(newDefaultThreadFactory());</span><br><span class="line">       &#125;</span><br><span class="line">      children 在最上层定义<span class="comment">// private final EventExecutor[] children;</span></span><br><span class="line">       children = <span class="keyword">new</span> EventExecutor[nThreads];</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nThreads; i ++) &#123;</span><br><span class="line">           <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//进入循环就是8次么</span></span><br><span class="line">           <span class="comment">//第一次success为false</span></span><br><span class="line">           .</span><br><span class="line">           .</span><br><span class="line">           .</span><br><span class="line">           i=<span class="number">7</span>时  success=<span class="keyword">true</span></span><br><span class="line">               children[i] = newChild(executor, args);</span><br><span class="line">               success = <span class="keyword">true</span>;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">               <span class="comment">// <span class="doctag">TODO:</span> Think about if this is a good exception type</span></span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"failed to create a child event loop"</span>, e);</span><br><span class="line">           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">                   <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j ++) &#123;</span><br><span class="line">                       children[j].shutdownGracefully();</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j ++) &#123;</span><br><span class="line">                       EventExecutor e = children[j];</span><br><span class="line">                       <span class="keyword">try</span> &#123;</span><br><span class="line">                           <span class="keyword">while</span> (!e.isTerminated()) &#123;</span><br><span class="line">                               e.awaitTermination(Integer.MAX_VALUE, TimeUnit.SECONDS);</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125; <span class="keyword">catch</span> (InterruptedException interrupted) &#123;</span><br><span class="line">                           <span class="comment">// Let the caller handle the interruption.</span></span><br><span class="line">                           Thread.currentThread().interrupt();</span><br><span class="line">                           <span class="keyword">break</span>;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       chooser = chooserFactory.newChooser(children);</span><br><span class="line">       <span class="comment">//任务监听</span></span><br><span class="line">       <span class="keyword">final</span> FutureListener&lt;Object&gt; terminationListener = <span class="keyword">new</span> FutureListener&lt;Object&gt;() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(Future&lt;Object&gt; future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">               <span class="keyword">if</span> (terminatedChildren.incrementAndGet() == children.length) &#123;</span><br><span class="line">                   terminationFuture.setSuccess(<span class="keyword">null</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (EventExecutor e: children) &#123;</span><br><span class="line">           e.terminationFuture().addListener(terminationListener);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//addAll()方法用于将所有指定的元素添加到指定的集合中</span></span><br><span class="line">       Set&lt;EventExecutor&gt; childrenSet = <span class="keyword">new</span> LinkedHashSet&lt;EventExecutor&gt;(children.length);</span><br><span class="line">       Collections.addAll(childrenSet, children);</span><br><span class="line">       readonlyChildren = Collections.unmodifiableSet(childrenSet);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ChannelFuture future = server.bind(<span class="number">8088</span>).sync();</span><br><span class="line">异步绑定端口号</span><br><span class="line">mainGroup.shutdownGracefully();</span><br><span class="line">优雅关闭</span><br></pre></td></tr></table></figure><p>实际应用个人流程总结</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/nettyserver.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这里的流程基本就是企业实际应用的流程<br>注解@ChannelHandler.Sharable，标识此Handler可应用于多个NettyClientHandlerInitializer<br>下面代码来自芋道源码github</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClientHandlerInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">Channel</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 心跳超时时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer READ_TIMEOUT_SECONDS = <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MessageDispatcher messageDispatcher;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> NettyClientHandler nettyClientHandler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> </span>&#123;</span><br><span class="line">        ch.pipeline()</span><br><span class="line">                <span class="comment">// 空闲检测</span></span><br><span class="line">                .addLast(<span class="keyword">new</span> IdleStateHandler(READ_TIMEOUT_SECONDS, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">                .addLast(<span class="keyword">new</span> ReadTimeoutHandler(<span class="number">3</span> * READ_TIMEOUT_SECONDS))</span><br><span class="line">                <span class="comment">// 编码器</span></span><br><span class="line">                .addLast(<span class="keyword">new</span> InvocationEncoder())</span><br><span class="line">                <span class="comment">// 解码器</span></span><br><span class="line">                .addLast(<span class="keyword">new</span> InvocationDecoder())</span><br><span class="line">                <span class="comment">// 消息分发器</span></span><br><span class="line">                .addLast(messageDispatcher)</span><br><span class="line">                <span class="comment">// 客户端处理器</span></span><br><span class="line">                .addLast(nettyClientHandler)</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;第一次学习Netty可追溯到2019年1月，现在重新阅读多篇资料和源码后自己以个人能够理解的方式总结下Netty，参考多篇资料&lt;br&gt;1.Netty是啥&lt;br&gt;官网定义&lt;br&gt;Netty是 一个异步事件驱动的网络应用程序框架，用于快速开发可维护的高性能协议服务器和客户端。&lt;
      
    
    </summary>
    
    
    
      <category term="Netty" scheme="kkget.github.io/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>CompletableFuture</title>
    <link href="kkget.github.io/2020/07/29/CompletableFuture/"/>
    <id>kkget.github.io/2020/07/29/CompletableFuture/</id>
    <published>2020-07-29T07:04:59.000Z</published>
    <updated>2020-07-29T08:14:38.394Z</updated>
    
    <content type="html"><![CDATA[<p>想学习CompletableFuture，因此查询资料发现<br>CompletableFuture是JDK8中的新特性，主要用于对JDK5中加入的Future的补充。<br>CompletableFuture实现了CompletionStage和Future接口。<br>需要先了解Future接口<br>什么是Future？<br>简单来说future就是一个Future<T>对象，当执行return await。。。的时候，实际上返回的是一个延迟计算的Future对象，这个Future对象是Dart内置的，有自己的队列策略，它将要操作的事件放入EventQueue中，在队列中的事件按照先进先出的原则去逐一处理事件，当事件处理完成后，将结果返回给Future对象。</p><p>在这个过程中涉及到了异步和等待：</p><p>异步：就是不用阻塞当前线程，来等待该线程任务处理完成再去执行其他任务。<br>等待：await，声明运算为延迟执行<br>async和await<br>首先看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getData() async&#123;</span><br><span class="line">   <span class="keyword">return</span> await http.get(Uri.encodeFull(url), headers: &#123;<span class="string">"Accept"</span>: <span class="string">"application/json"</span>&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//然后调用函数来获取结果</span></span><br><span class="line">String data = getData();</span><br></pre></td></tr></table></figure><p>这段代码在运行的时候会报错。<br>因为data是String类型，而函数getData()是一个异步操作函数，其返回值是一个await延迟执行的结果。<br>在Dart中，有await标记的运算，结果都是一个Future对象，Future不是String类型，所以就报错了。<br>如何获取异步函数的结果呢？Dart规定有async标记的函数，只能由await来调用，那么我们可以在函数前加一个await关键字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String data = <span class="function">await <span class="title">getData</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>但是这违背了await必须要在async标记的函数中使用，所以赋值代码可以改成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String data;</span><br><span class="line">setData() async &#123;</span><br><span class="line">  data = <span class="function">await <span class="title">getData</span><span class="params">()</span></span>;    <span class="comment">//getData()延迟执行后赋值给data</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>async和await的使用其实就只有两点：</p><p>await关键字必须在async函数内部使用<br>调用async函数必须使用await关键字</p><p>Dart(释义：镖)异步<br>Dart是单线程模型，是一种Event-Looper以及Event-Queue的模型，所有的事件都是通过EventLooper的依次执行。</p><p>Event-Looper与Netty的NioEventLoopGroup异曲同工，都是线程模型</p><p>作者：zhaoolee<br>链接：<a href="https://www.jianshu.com/p/aefd0e50b802" target="_blank" rel="noopener">https://www.jianshu.com/p/aefd0e50b802</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br>单线程模型<br>所谓单线程，就是一旦一个函数开始执行，就必须将这个函数执行完，才能去执行其他函数</p><p>作者：MakerChin<br>链接：<a href="https://www.jianshu.com/p/890df7ea8f87" target="_blank" rel="noopener">https://www.jianshu.com/p/890df7ea8f87</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br>Future接口的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//取消任务。参数:是否立即中断任务执行，或者等等任务结束</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//任务是否已经取消，若已取消，返回true</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//任务是否已经完成。包括任务正常完成、抛出异常或被取消，都返回true</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*等待任务执行结束，获得V类型的结果。InterruptedException: 线程被中断异常， ExecutionException: 任务执行异常，如果任务被取消，还会抛出CancellationException*/</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*参数timeout指定超时时间，uint指定时间的单位，在枚举类TimeUnit中有相关的定义。如果计算超时，将抛出TimeoutException*/</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用不带参数的get方法的调用被阻塞，直到计算完成。如果在计算完成之前，调用带参get()方法超时时，会抛出TimeoutException异常。若运行该计算的线程被中断，两种get()方法都会抛出InterruptedException。如果计算已经完成，那么get方法立即返回。<br>若计算还在进行，isDone方法返回false；如果完成了，则返回true。<br>调用cancel()时，若计算还没有开始，它被取消且不再开始。若计算处于运行之中，那么如果mayInterrupt参数为true，它就被中断。<br>相比future.get()，其实更推荐使用get (long timeout, TimeUnit unit) 方法，因为设置了超时时间可以防止程序无限制的等待future的返回结果。<br>FutureTask源码解析<br>构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (callable == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">this</span>.callable = callable;</span><br><span class="line">        <span class="comment">//状态为NEW</span></span><br><span class="line">        <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.callable = Executors.callable(runnable, result);</span><br><span class="line">        <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>实际上Callable = Runnable + result，继续看上面的第二个构造方法，看看Executors.callable(runnable, result)的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Callable&lt;T&gt; <span class="title">callable</span><span class="params">(Runnable task, T result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="comment">//new了一个RunnableAdapter,返回Callable,说明RunnableAdapter实现了Callable</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RunnableAdapter&lt;T&gt;(task, result);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>状态值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Possible state transitions:</span></span><br><span class="line"><span class="comment"> * NEW -&gt; COMPLETING -&gt; NORMAL</span></span><br><span class="line"><span class="comment"> * NEW -&gt; COMPLETING -&gt; EXCEPTIONAL</span></span><br><span class="line"><span class="comment"> * NEW -&gt; CANCELLED</span></span><br><span class="line"><span class="comment"> * NEW -&gt; INTERRUPTING -&gt; INTERRUPTED</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"><span class="comment">//初始化状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NEW          = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//正在执行</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COMPLETING   = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//正常完成</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NORMAL       = <span class="number">2</span>;</span><br><span class="line"><span class="comment">//出现异常</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCEPTIONAL  = <span class="number">3</span>;</span><br><span class="line"><span class="comment">//被取消</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED    = <span class="number">4</span>;</span><br><span class="line"><span class="comment">//正被中断</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTING = <span class="number">5</span>;</span><br><span class="line"><span class="comment">//已被中断</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTED  = <span class="number">6</span>;</span><br></pre></td></tr></table></figure><p>FutureTask的run方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*compareAndSwapObject(this, runnerOffset,]null, Thread.currentThread()))</span></span><br><span class="line"><span class="comment">         其中第一个参数为需要改变的对象，第二个为偏移量，第三个参数为期待的值，第四个为更新后的值。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">            !UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, runnerOffset,</span><br><span class="line">                                         <span class="keyword">null</span>, Thread.currentThread()))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Callable&lt;V&gt; c = callable;</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">                V result;</span><br><span class="line">                <span class="keyword">boolean</span> ran;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//call()方法是由FutureTask调用的,说明call()不是异步执行的</span></span><br><span class="line">                    result = c.call();</span><br><span class="line">                    ran = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                    result = <span class="keyword">null</span>;</span><br><span class="line">                    ran = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="comment">//设置异常</span></span><br><span class="line">                    setException(ex);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (ran)</span><br><span class="line">                    set(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// runner must be non-null until state is settled to</span></span><br><span class="line">            <span class="comment">// prevent concurrent calls to run()</span></span><br><span class="line">            runner = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// state must be re-read after nulling runner to prevent</span></span><br><span class="line">            <span class="comment">// leaked interrupts</span></span><br><span class="line">            <span class="keyword">int</span> s = state;</span><br><span class="line">            <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">                handlePossibleCancellationInterrupt(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>set方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(V v)</span> </span>&#123;</span><br><span class="line">           <span class="comment">// NEW -&gt; COMPLETING</span></span><br><span class="line">        <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line">            <span class="comment">//返回结果,也包括异常</span></span><br><span class="line">            outcome = v;</span><br><span class="line">            <span class="comment">//COMPLETING -&gt; NORMAL</span></span><br><span class="line">            UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, NORMAL); <span class="comment">// final state</span></span><br><span class="line">            <span class="comment">//唤醒等待的线程</span></span><br><span class="line">            finishCompletion();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>get方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="comment">//是否是未完成状态,是则等待</span></span><br><span class="line">        <span class="keyword">if</span> (s &lt;= COMPLETING)</span><br><span class="line">            <span class="comment">//等待过程</span></span><br><span class="line">            s = awaitDone(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">        <span class="keyword">return</span> report(s);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> CancellationException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (unit == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="keyword">if</span> (s &lt;= COMPLETING &amp;&amp;</span><br><span class="line">            (s = awaitDone(<span class="keyword">true</span>, unit.toNanos(timeout))) &lt;= COMPLETING)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">        <span class="keyword">return</span> report(s);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。<br>本文链接：<a href="https://blog.csdn.net/itcats_cn/article/details/81322122" target="_blank" rel="noopener">https://blog.csdn.net/itcats_cn/article/details/81322122</a></p><p>CompletableFuture类的官方API文档解释：</p><p>CompletableFuture是一个在完成时可以触发相关方法和操作的Future，并且它可以视作为CompletableStage。<br>除了直接操作状态和结果的这些方法和相关方法外（CompletableFuture API提供的方法），CompletableFuture还实现了以下的CompletionStage的相关策略：<br>① 非异步方法的完成，可以由当前CompletableFuture的线程提供，也可以由其他调用完方法的线程提供。<br>② 所有没有显示使用Executor的异步方法，会使用ForkJoinPool.commonPool()（那些并行度小于2的任务会创建一个新线程来运行）。为了简化监视、调试和跟踪异步方法，所有异步任务都被标记为CompletableFuture.AsynchronouseCompletionTask。<br>③ 所有CompletionStage方法都是独立于其他公共方法实现的，因此一个方法的行为不受子类中其他方法的覆盖影响。<br>CompletableFuture还实现了Future的以下策略<br>① 不像FutureTask，因CompletableFuture无法直接控制计算任务的完成，所以CompletableFuture的取消会被视为异常完成。调用cancel()方法会和调用completeExceptionally（）方法一样，具有同样的效果。isCompletedEceptionally()方法可以判断CompletableFuture是否是异常完成。<br>② 在调用get()和get(long, TimeUnit)方法时以异常的形式完成，则会抛出ExecutionException,大多数情况下都会使用join()和getNow(T)，它们会抛出CompletionException。<br>小结：</p><p>Concurrent包中的Future在获取结果时会发生阻塞，而CompletableFuture则不会，它可以通过触发异步方法来获取结果。<br>在CompletableFuture中，如果没有显示指定的Executor的参数，则会调用默认的ForkJoinPool.commonPool()。<br>调用CompletableFuture的cancel()方法和调用completeExceptionally()方法的效果一样。<br>在JDK5中，使用Future来获取结果时都非常的不方便，只能通过get()方法阻塞线程或者通过轮询isDone()的方式来获取任务结果，这种阻塞或轮询的方式会无畏的消耗CPU资源，而且还不能及时的获取任务结果，因此JDK8中提供了CompletableFuture来实现异步的获取任务结果。</p><p>使用下CompletableFuture的API<br>CompletableFuture类提供了非常多的方法供我们使用，包括了runAsync()、supplyAsync()、thenAccept()等方法。<br>runAsync()，异步运行:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runAsyncExample</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class="line">        CompletableFuture cf = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">        &#125;, executorService);</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cf.isDone()) &#123;</span><br><span class="line">                System.out.println(<span class="string">"CompletedFuture...isDown"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">main</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">CompletedFuture…isDown</span><br></pre></td></tr></table></figure><p>这里调用的runAsync()方法没有使用ForkJoinPool的线程，而是使用了Executors.newSingleThreadExecutor()中的线程。runAsync()其实效果跟单开一个线程一样。<br>supplyAsync()</p><p>supply有供应的意思，supplyAsync就可以理解为异步供应，查看supplyAsync()方法入参可以知道，其有两个入参：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Supplier supplier,</span><br><span class="line">Executor executor</span><br></pre></td></tr></table></figure><p>这里先简单介绍下Supplier接口，Supplier接口是JDK8引入的新特性，它也是用于创建对象的，只不过调用Supplier的get()方法时，才会去通过构造方法去创建对象，并且每次创建出的对象都不一样。Supplier常用语法为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Supplier&lt;MySupplier&gt; sup= MySupplier::<span class="keyword">new</span>;</span><br></pre></td></tr></table></figure><p>1<br>再展示代码例子之前，再讲一个thenAccept()方法，可以发现thenAccept()方法的入参如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Comsumer&lt;? <span class="keyword">super</span> T&gt;</span><br><span class="line">Comsumer接口同样是java8新引入的特性，它有两个重要接口方法：</span><br><span class="line"></span><br><span class="line">accept()</span><br><span class="line">andThen()</span><br><span class="line">thenAccept()可以理解为接收CompletableFuture的结果然后再进行处理。</span><br></pre></td></tr></table></figure><p>下面看下supplyAsync()和thenAccept()的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">thenApply</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        CompletableFuture cf = CompletableFuture.supplyAsync(() -&gt; &#123; <span class="comment">//实现了Supplier的get()方法</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"supplyAsync "</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"hello "</span>;</span><br><span class="line">        &#125;,executorService).thenAccept(s -&gt; &#123; <span class="comment">//实现了Comsumper的accept()方法</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                thenApply_test(s + <span class="string">"world"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cf.isDone()) &#123;</span><br><span class="line">                System.out.println(<span class="string">"CompletedFuture...isDown"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main</span><br><span class="line">supplyAsync pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">thenApply_test hello world</span><br><span class="line">thenApply_test pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br></pre></td></tr></table></figure><p>从代码逻辑可以看出，thenApply_test等到了pool-1-thread-1线程完成任务后，才进行的调用，并且拿到了supplye()方法返回的结果，而main则异步执行了，这就避免了Future获取结果时需要阻塞或轮询的弊端。<br>exceptionally<br>当任务在执行过程中报错了咋办？exceptionally()方法很好的解决了这个问题，当报错时会去调用exceptionally()方法，它的入参为：Function&lt;Throwable, ? extends T&gt; fn，fn为执行任务报错时的回调方法，下面看看代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionally</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class="line">        CompletableFuture cf = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"测试exceptionally..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"s1"</span>;</span><br><span class="line">        &#125;, executorService).exceptionally(e -&gt; &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"helloworld "</span> + e.getMessage();</span><br><span class="line">        &#125;);</span><br><span class="line">        cf.thenAcceptAsync(s -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"thenAcceptAsync: "</span> + s);</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">"main: "</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main: main</span><br><span class="line">java.lang.RuntimeException: 测试exceptionally…</span><br><span class="line">CompletableFuture is Down…helloworld java.lang.RuntimeException: 测试exceptionally…</span><br><span class="line">thenAcceptAsync: helloworld java.lang.RuntimeException: 测试exceptionally…</span><br></pre></td></tr></table></figure><p>从代码以及运行结果来看，当任务执行过程中报错时会执行exceptionally()中的代码，thenAcceptAsync()会获取抛出的异常并输出到控制台，不管CompletableFuture()执行过程中报错、正常完成、还是取消，都会被标示为已完成，所以最后CompletableFuture.isDown()为true。</p><p>在Java8中，新增的ForkJoinPool.commonPool()方法，这个方法可以获得一个公共的ForkJoin线程池，这个公共线程池中的所有线程都是Daemon线程，意味着如果主线程退出，这些线程无论是否执行完毕，都会退出系统。</p><p>2.3 源码分析<br>CompletableFuture类实现了Future接口和CompletionStage接口，Future大家都经常遇到，但是这个CompletionStage接口就有点陌生了，这里的CompletionStage实际上是一个任务执行的一个“阶段”，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompletableFuture</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Future</span>&lt;<span class="title">T</span>&gt;, <span class="title">CompletionStage</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">volatile</span> Object result;       <span class="comment">// CompletableFuture的结果值或者是一个异常的报装对象AltResult</span></span><br><span class="line">    <span class="keyword">volatile</span> Completion stack;    <span class="comment">// 依赖操作栈的栈顶</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// CompletableFuture的方法</span></span><br><span class="line">    ... </span><br><span class="line"><span class="comment">// Unsafe mechanics</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> RESULT;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> STACK;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> NEXT;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> sun.misc.Unsafe u;</span><br><span class="line">            UNSAFE = u = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            Class&lt;?&gt; k = CompletableFuture<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">            RESULT = u.objectFieldOffset(k.getDeclaredField(<span class="string">"result"</span>)); <span class="comment">//计算result属性的位偏移量</span></span><br><span class="line">            STACK = u.objectFieldOffset(k.getDeclaredField(<span class="string">"stack"</span>)); <span class="comment">//计算stack属性的位偏移量</span></span><br><span class="line">            NEXT = u.objectFieldOffset </span><br><span class="line">                (Completion.class.getDeclaredField("next"));  //计算next属性的位偏移量</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception x) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在CompletableFuture中有一个静态代码块，在CompletableFuture类初始化之前就进行调用，代码块里的内容就是通过Unsafe类去获取CompletableFuture的result、stack和next属性的“偏移量”，这个偏移量主要用于Unsafe的CAS操作时进行位移量的比较。<br>runAsync(Runnable, Executor) &amp; runAsync(Runnable)<br>runAsync()做的事情就是异步的执行任务，返回的是CompletableFuture对象，不过CompletableFuture对象不包含结果。runAsync()方法有两个重载方法，这两个重载方法的区别是Executor可以指定为自己想要使用的线程池，而runAsync(Runnable)则使用的是ForkJoinPool.commonPool()。</p><p>下面先来看看runAsync(Runnable)的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title">runAsync</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> asyncRunStage(asyncPool, runnable);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这里的asyncPool是一个静态的成员变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> useCommonPool =</span><br><span class="line">        (ForkJoinPool.getCommonPoolParallelism() &gt; <span class="number">1</span>); <span class="comment">// 并行级别</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor asyncPool = useCommonPool ?  </span><br><span class="line">ForkJoinPool.commonPool() : <span class="keyword">new</span> ThreadPerTaskExecutor();</span><br></pre></td></tr></table></figure><p>回到asyncRunStage()源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title">asyncRunStage</span><span class="params">(Executor e, Runnable f)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (f == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">       CompletableFuture&lt;Void&gt; d = <span class="keyword">new</span> CompletableFuture&lt;Void&gt;();</span><br><span class="line">       e.execute(<span class="keyword">new</span> AsyncRun(d, f));</span><br><span class="line">       <span class="keyword">return</span> d;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>看到asyncRunStage()源码，可以知道任务是由Executor来执行的，那么可想而知Async类一定是实现了Callable接口或者继承了Runnable类，查看Async类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncRun</span> <span class="keyword">extends</span> <span class="title">ForkJoinTask</span>&lt;<span class="title">Void</span>&gt;</span></span><br><span class="line"><span class="class">            <span class="keyword">implements</span> <span class="title">Runnable</span>, <span class="title">AsynchronousCompletionTask</span> </span>&#123;</span><br><span class="line">        CompletableFuture&lt;Void&gt; dep; Runnable fn;</span><br><span class="line">        AsyncRun(CompletableFuture&lt;Void&gt; dep, Runnable fn) &#123;</span><br><span class="line">            <span class="keyword">this</span>.dep = dep; <span class="keyword">this</span>.fn = fn;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Void <span class="title">getRawResult</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">null</span>; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setRawResult</span><span class="params">(Void v)</span> </span>&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">exec</span><span class="params">()</span> </span>&#123; run(); <span class="keyword">return</span> <span class="keyword">true</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            CompletableFuture&lt;Void&gt; d; Runnable f;</span><br><span class="line">            <span class="keyword">if</span> ((d = dep) != <span class="keyword">null</span> &amp;&amp; (f = fn) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                dep = <span class="keyword">null</span>; fn = <span class="keyword">null</span>;<span class="comment">//释放掉内存</span></span><br><span class="line">                <span class="keyword">if</span> (d.result == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        f.run();</span><br><span class="line">                        d.completeNull();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                        d.completeThrowable(ex);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                d.postComplete(); <span class="comment">// 任务结束后，会执行所有依赖此任务的其他任务，这些任务以一个无锁并发栈的形式存在</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在AsyncRun类中，实现了Runnable接口的run()方法，在run()方法内部，会调用传进来的Runnable对象的run()方法，这里就需要用户自己去实现了，上文中的实例代码就是通过Lambda表达式来实现了Runnable接口。调用了f.run()之后，然后就是completeNull()方法了，改方法底层通过调用UNSAFE类的compareAndSwapObject()方法，来以CAS的方式将CompletableFuture的结果赋为null。postComplete()就是任务结束后，会执行所有依赖此任务的其他任务，这些任务以一个无锁并发栈的形式存在。<br>postComplete()的源码还是有点复杂的，先不急着分析。先看看Completion这个抽象类的数据结构组成：</p><p>Completion<br>下面先看看Completion的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Completion</span> <span class="keyword">extends</span> <span class="title">ForkJoinTask</span>&lt;<span class="title">Void</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Runnable</span>, <span class="title">AsynchronousCompletionTask</span> </span>&#123;</span><br><span class="line">        <span class="keyword">volatile</span> Completion next;      </span><br><span class="line">        <span class="keyword">abstract</span> CompletableFuture&lt;?&gt; tryFire(<span class="keyword">int</span> mode);</span><br><span class="line">        <span class="function"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">isLive</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span>                </span>&#123; tryFire(ASYNC); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">exec</span><span class="params">()</span>            </span>&#123; tryFire(ASYNC); <span class="keyword">return</span> <span class="keyword">true</span>; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Void <span class="title">getRawResult</span><span class="params">()</span>       </span>&#123; <span class="keyword">return</span> <span class="keyword">null</span>; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setRawResult</span><span class="params">(Void v)</span> </span>&#123;&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Completion是一个抽象类，分别实现了Runnable、AsynchronousCompletionTask接口，继承了ForkJoinPoolTask类，而ForJoinPoolTask抽象类又实现了Future接口，因此Completion实际上就是一个Future。可以看到Completion的抽象方法和成员方法的实现逻辑都短短一行或者没有，可以猜到这些方法的实现都是在其子类中。其实现类包括了UniCompletion、BiCompletion、UniAccept、BiAccept等，如下图：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/complete1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>而Completion类中还有一个非常重要的成员属性</p><p>volatile Completion next;<br>1<br>有印象的读者应该能记得，CompletableFuture中有一个属性——stack，就是Completion类的。</p><p>volatile Completion stack;<br>1<br>由这个属性可以看出，CompletableFuture其实就是一个链表的一个数据结构。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UniCompletion</span>&lt;<span class="title">T</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Completion</span> </span>&#123;</span><br><span class="line">        Executor executor;                 <span class="comment">// executor to use (null if none)</span></span><br><span class="line">        CompletableFuture&lt;V&gt; dep;          <span class="comment">// 代表的依赖的CompletableFuture</span></span><br><span class="line">        CompletableFuture&lt;T&gt; src;          <span class="comment">// 代表的是源CompletableFuture</span></span><br><span class="line"></span><br><span class="line">        UniCompletion(Executor executor, CompletableFuture&lt;V&gt; dep,</span><br><span class="line">                      CompletableFuture&lt;T&gt; src) &#123;</span><br><span class="line">            <span class="keyword">this</span>.executor = executor; <span class="keyword">this</span>.dep = dep; <span class="keyword">this</span>.src = src;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 确保当前Completion可以被调用；并且使用ForkJoinPool标记为来确保只有一个线程可以调用，</span></span><br><span class="line"><span class="comment">         * 如果是异步的，则在任务启动之后通过tryFire来进行调用。tryFire方法时在UniAccept类中。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">claim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Executor e = executor;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetForkJoinTaskTag((<span class="keyword">short</span>)<span class="number">0</span>, (<span class="keyword">short</span>)<span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                executor = <span class="keyword">null</span>; <span class="comment">// disable</span></span><br><span class="line">                e.execute(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isLive</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> dep != <span class="keyword">null</span>; &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>claim方法要在执行action前调用，若claim方法返回false，则不能调用action，原则上要保证action只执行一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">UniAccept</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">UniCompletion</span>&lt;<span class="title">T</span>,<span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line">        Consumer&lt;? <span class="keyword">super</span> T&gt; fn;</span><br><span class="line">        UniAccept(Executor executor, CompletableFuture&lt;Void&gt; dep,</span><br><span class="line">                  CompletableFuture&lt;T&gt; src, Consumer&lt;? <span class="keyword">super</span> T&gt; fn) &#123;</span><br><span class="line">            <span class="keyword">super</span>(executor, dep, src); <span class="keyword">this</span>.fn = fn;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 尝试去调用当前任务。uniAccept()方法为核心逻辑。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> CompletableFuture&lt;Void&gt; <span class="title">tryFire</span><span class="params">(<span class="keyword">int</span> mode)</span> </span>&#123;</span><br><span class="line">            CompletableFuture&lt;Void&gt; d; CompletableFuture&lt;T&gt; a;</span><br><span class="line">            <span class="keyword">if</span> ((d = dep) == <span class="keyword">null</span> ||</span><br><span class="line">                !d.uniAccept(a = src, fn, mode &gt; <span class="number">0</span> ? <span class="keyword">null</span> : <span class="keyword">this</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            dep = <span class="keyword">null</span>; src = <span class="keyword">null</span>; fn = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> d.postFire(a, mode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> &lt;S&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">uniAccept</span><span class="params">(CompletableFuture&lt;S&gt; a,</span></span></span><br><span class="line"><span class="function"><span class="params">                                Consumer&lt;? <span class="keyword">super</span> S&gt; f, UniAccept&lt;S&gt; c)</span> </span>&#123;</span><br><span class="line">        Object r; Throwable x;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="keyword">null</span> || (r = a.result) == <span class="keyword">null</span> || f == <span class="keyword">null</span>) <span class="comment">//判断源任务是否已经完成了，a表示的就是源任务，a.result就代表的是原任务的结果。</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        tryComplete: <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r <span class="keyword">instanceof</span> AltResult) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((x = ((AltResult)r).ex) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    completeThrowable(x, r);</span><br><span class="line">                    <span class="keyword">break</span> tryComplete;</span><br><span class="line">                &#125;</span><br><span class="line">                r = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; !c.claim())</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) S s = (S) r;</span><br><span class="line">                f.accept(s);  <span class="comment">//去调用Comsumer</span></span><br><span class="line">                completeNull();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                completeThrowable(ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>对于Completion的执行，还有几个关键的属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SYNC   =  <span class="number">0</span>;<span class="comment">//同步</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ASYNC  =  <span class="number">1</span>;<span class="comment">//异步</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NESTED = -<span class="number">1</span>;<span class="comment">//嵌套</span></span><br></pre></td></tr></table></figure><p>Completion在CompletableFuture中是如何工作的呢？现在先不着急了解其原理，下面再去看下一个重要的接口——CompletionStage。</p><p>CompletionStage<br>下面介绍下CompletionStage接口。看字面意思可以理解为“完成动作的一个阶段”，查看官方注释文档：CompletionStage是一个可能执行异步计算的“阶段”，这个阶段会在另一个CompletionStage完成时调用去执行动作或者计算，一个CompletionStage会以正常完成或者中断的形式“完成”，并且它的“完成”会触发其他依赖的CompletionStage。CompletionStage 接口的方法一般都返回新的CompletionStage，因此构成了链式的调用。<br>【下文中Stage代表CompletionStage】</p><p>那么在Java中什么是CompletionStage呢？<br>官方定义中，一个Function，Comsumer或者Runnable都会被描述为一个CompletionStage，相关方法比如有apply，accept，run等，这些方法的区别在于它们有些是需要传入参，有些则会产生“结果”。</p><p>Funtion方法会产生结果<br>Comsumer会消耗结果<br>Runable既不产生结果也不消耗结果<br>下面看看一个Stage的调用例子：</p><p>stage.thenApply(x -&gt; square(x)).thenAccept(x -&gt; System.out.println(x)).thenRun(() -&gt; System.out.println())<br>1<br>这里x -&gt; square(x)就是一个Function类型的Stage，它返回了x。x -&gt; System.out.println(x)就是一个Comsumer类型的Stage，用于接收上一个Stage的结果x。() -&gt;System.out.println()就是一个Runnable类型的Stage，既不消耗结果也不产生结果。</p><p>一个、两个或者任意一个CompletionStage的完成都会触发依赖的CompletionStage的执行，CompletionStage的依赖动作可以由带有then的前缀方法来实现。如果一个Stage被两个Stage的完成给触发，则这个Stage可以通过相应的Combine方法来结合它们的结果，相应的Combine方法包括：thenCombine、thenCombineAsync。但如果一个Stage是被两个Stage中的其中一个触发，则无法去combine它们的结果，因为这个Stage无法确保这个结果是那个与之依赖的Stage返回的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCombine</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       String result = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">       &#125;).thenCombine(CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="string">" world"</span>;</span><br><span class="line">       &#125;), (s1, s2) -&gt; s1 + <span class="string">" "</span> + s2).join();</span><br><span class="line"></span><br><span class="line">       System.out.println(result);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>虽然Stage之间的依赖关系可以控制触发计算，但是并不能保证任何的顺序。</p><p>另外，可以用一下三种的任何一种方式来安排一个新Stage的计算：default execution、default asynchronous execution（方法后缀都带有async）或者custom（自定义一个executor）。默认和异步模式的执行属性由CompletionStage实现而不是此接口指定。</p><p>小结：CompletionStage确保了CompletableFuture能够进行链式调用。</p><p>下面开始介绍CompletableFuture的几个核心方法：</p><p>postComplete</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">postComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CompletableFuture&lt;?&gt; f = <span class="keyword">this</span>; Completion h;    <span class="comment">//this表示当前的CompletableFuture</span></span><br><span class="line">        <span class="keyword">while</span> ((h = f.stack) != <span class="keyword">null</span> ||                                  <span class="comment">//判断stack栈是否为空</span></span><br><span class="line">               (f != <span class="keyword">this</span> &amp;&amp; (h = (f = <span class="keyword">this</span>).stack) != <span class="keyword">null</span>)) &#123;    </span><br><span class="line">            CompletableFuture&lt;?&gt; d; Completion t;      </span><br><span class="line">            <span class="keyword">if</span> (f.casStack(h, t = h.next)) &#123;                          <span class="comment">//通过CAS出栈，</span></span><br><span class="line">                <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (f != <span class="keyword">this</span>) &#123;</span><br><span class="line">                        pushStack(h);             <span class="comment">//如果f不是this，将刚出栈的h入this的栈顶</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    h.next = <span class="keyword">null</span>;    <span class="comment">// detach   帮助GC</span></span><br><span class="line">                &#125;</span><br><span class="line">                f = (d = h.tryFire(NESTED)) == <span class="keyword">null</span> ? <span class="keyword">this</span> : d;        <span class="comment">//调用tryFire</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>postComplete()方法可以理解为当任务完成之后，调用的一个“后完成”方法，主要用于触发其他依赖任务。</p><p>uniAccept</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> &lt;S&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">uniAccept</span><span class="params">(CompletableFuture&lt;S&gt; a,</span></span></span><br><span class="line"><span class="function"><span class="params">                                Consumer&lt;? <span class="keyword">super</span> S&gt; f, UniAccept&lt;S&gt; c)</span> </span>&#123;</span><br><span class="line">        Object r; Throwable x;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="keyword">null</span> || (r = a.result) == <span class="keyword">null</span> || f == <span class="keyword">null</span>)    <span class="comment">//判断当前CompletableFuture是否已完成，如果没完成则返回false；如果完成了则执行下面的逻辑。</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        tryComplete: <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r <span class="keyword">instanceof</span> AltResult) &#123;   <span class="comment">//判断任务结果是否是AltResult类型</span></span><br><span class="line">                <span class="keyword">if</span> ((x = ((AltResult)r).ex) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    completeThrowable(x, r);</span><br><span class="line">                    <span class="keyword">break</span> tryComplete;</span><br><span class="line">                &#125;</span><br><span class="line">                r = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; !c.claim()) <span class="comment">//判断当前任务是否可以执行</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) S s = (S) r;   <span class="comment">//获取任务结果</span></span><br><span class="line">                f.accept(s);    <span class="comment">//执行Comsumer</span></span><br><span class="line">                completeNull();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                completeThrowable(ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里有一个很巧妙的地方，就是uniAccept的入参中，CompletableFuture a表示的是源任务，UniAccept c中报装有依赖的任务，这点需要清除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pushStack</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">pushStack</span><span class="params">(Completion c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (!tryPushStack(c));      <span class="comment">//使用CAS自旋方式压入栈，避免了加锁竞争</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryPushStack</span><span class="params">(Completion c)</span> </span>&#123;</span><br><span class="line">        Completion h = stack;         </span><br><span class="line">        lazySetNext(c, h);   <span class="comment">//将当前stack设置为c的next</span></span><br><span class="line">        <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, STACK, h, c); <span class="comment">//尝试把当前栈（h）更新为新值（c）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lazySetNext</span><span class="params">(Completion c, Completion next)</span> </span>&#123;</span><br><span class="line">        UNSAFE.putOrderedObject(c, NEXT, next);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>光分析源码也没法深入理解其代码原理，下面结合一段示例代码来对代码原理进行分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">thenApply</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">       CompletableFuture cf = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//休眠200秒</span></span><br><span class="line">               Thread.sleep(<span class="number">200000</span>);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">           System.out.println(<span class="string">"supplyAsync "</span> + Thread.currentThread().getName());</span><br><span class="line">           <span class="keyword">return</span> <span class="string">"hello "</span>;</span><br><span class="line">       &#125;,executorService).thenAccept(s -&gt; &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               thenApply_test(s + <span class="string">"world"</span>);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       System.out.println(Thread.currentThread().getName());</span><br><span class="line">       <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (cf.isDone()) &#123;</span><br><span class="line">               System.out.println(<span class="string">"CompletedFuture...isDown"</span>);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 运行结果：</span></span><br><span class="line"><span class="comment">    main</span></span><br><span class="line"><span class="comment">    supplyAsync pool-1-thread-1</span></span><br><span class="line"><span class="comment">    thenApply_test hello world</span></span><br><span class="line"><span class="comment">    thenApply_test pool-1-thread-1</span></span><br><span class="line"><span class="comment">    CompletedFuture...isDown</span></span><br><span class="line"><span class="comment">    */</span></span><br></pre></td></tr></table></figure><p>这段示例代码所做的事情就是supplyAsync(Supplier supplier)休眠200秒之后，返回一个字符串，thenAccept(Consumer&lt;? super T&gt; action)等到任务完成之后接收这个字符串，并且调用thenApply_test()方法，随后输出 hello world。<br>代码中让线程休眠200秒是为了方便观察CompletableFuture的传递过程。</p><p>下面就描述下程序的整个运作流程。<br>① 主线程调用CompletableFuture的supplyAsync()方法，传入Supplier和Executor。在supplyAsync()中又继续调用CompletableFuture的asyncSupplyStage(Executor, Supplier)方法。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/complete2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>来到asyncSupplyStage()方法中，调用指定的线程池，并执行execute(new AsyncSupply(d,f))，这里d就是我们的“源任务”，接下来thenApply()要依赖着这个源任务进行后续逻辑操作，f就是Supplier的函数式编程。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/complete3.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>AsyncSupply实现了Runnable的run()方法，核心逻辑就在run()方法里。在run()方法里，先判断d.result == null，判断该任务是否已经完成，防止并发情况下其他线程完成此任务了。f.get()就是调用的Supplier的函数式编程，这里会休眠200秒，所以executor线程池开启的线程会在这里阻塞200秒。</p><p>② 虽然executor线程池线程阻塞了，但是main线程任然会继续执行接下来的代码。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/complete4.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>main线程会在asyncSupplyStage()方法中返回d，就是我们的“依赖任务”，而这个任务此时还处在阻塞中。接下来main线程会继续执行CompletableFuture的thenAccept(Comsumer&lt;? super T&gt; action)方法，然后调用CompletableFuture的uniAcceptStage()方法。<br>在这里插入图片描述<br>在uniAcceptStage()方法中，会将“依赖任务”、“源任务”、线程池以及Comsumer报装程一个UniAccept对象，然后调用push()压入stack的栈顶中。随后调用UniAccept的tryFire()方法。<br>在这里插入图片描述<br>其中的CompletableFuture的uniAccept()方法会判断任务是否完成，判断依据是a.result 是否为空，这里的a就是之前传入的“源任务”，等到“源任务”阻塞200秒过后，就会完成任务，并将字符串存入到 result中。<br>在这里插入图片描述<br>判断到“源任务”完成之后，就会调用接下来的逻辑。s拿到的值就是“源”任务返回的字符串，并且传入到了Comsumer.accept()方法中。然而“源任务”还在阻塞中，main线程会跳出uniAccept()，继续执行接下来的逻辑。接下来就是输出当前线程的名字，然后调用while(true)，结束条件为CompletableFuture.isDone()，当任务完成时则结束while(true)循环。</p><p>③ 回到“源任务”，虽然main线程已经结束了整个生命周期，但是executor线程池的线程任然阻塞着的，休眠了200秒之后，继续执行任务。<br>在这里插入图片描述<br>然后来到了postComplete()方法。这个方法在前面已经介绍到了，它是CompletableFuture的核心方法之一，做了许多事情。最重要的一件事情就是触发其他依赖任务，接下来调用的方法依次为：UniAccept.tryFire(mode) ——&gt; CompletableFuture.uniAccept(…) ——&gt; Comsumer.accept(s) ——&gt; 输出“hello world”，并输出当前调用线程的线程名。因这个调用链已经在②中介绍过了，所以就不再详细介绍其运作逻辑。<br>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">      runAsync();</span><br><span class="line">      supplyAsync();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//无返回值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runAsync</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        CompletableFuture&lt;Void&gt; future = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"run end ..."</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        future.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有返回值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">supplyAsync</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        CompletableFuture&lt;Long&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"run end ..."</span>);</span><br><span class="line">            <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> time = future.get();</span><br><span class="line">        System.out.println(<span class="string">"time = "</span>+time);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">run end ...</span><br><span class="line">run end ...</span><br><span class="line">time = <span class="number">1596010020281</span></span><br></pre></td></tr></table></figure><p>小结： 通过这个小示例，终于理解到了“源任务”和“依赖任务”之间的调用关系，以及CompletableFuture的基本运作原理。然而CompletableFuture还有其他的方法需要去深入分析，由于篇幅所限就不再赘述，感兴趣的读者可以以debug的模式去一点一点分析CompletableFuture其他方法的底层原理。这里不得不说Java并发包作者Doug Lea大神真的太厉害了，阅读他的源码之后，可以发现他写的代码不能以技术来形容，而应该使用“艺术”来形容。</p><p>总结<br>CompletableFuture底层由于借助了魔法类Unsafe的相关CAS方法，除了get或join结果之外，其他方法都实现了无锁操作。<br>CompletableFuture实现了CompletionStage接口，因而具备了链式调用的能力，CompletionStage提供了either、apply、run以及then等相关方法，使得CompletableFuture可以使用各种应用场景。<br>CompletableFuture中有“源任务”和“依赖任务”，“源任务”的完成能够触发“依赖任务”的执行，这里的完成可以是返回正常结果或者是异常。<br>CompletableFuture默认使用ForkJoinPool，也可以使用指定线程池来执行任务。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;想学习CompletableFuture，因此查询资料发现&lt;br&gt;CompletableFuture是JDK8中的新特性，主要用于对JDK5中加入的Future的补充。&lt;br&gt;CompletableFuture实现了CompletionStage和Future接口。&lt;br&gt;
      
    
    </summary>
    
    
    
      <category term="CompletableFuture" scheme="kkget.github.io/tags/CompletableFuture/"/>
    
  </entry>
  
  <entry>
    <title>优雅永不过时</title>
    <link href="kkget.github.io/2020/07/22/%E4%BC%98%E9%9B%85%E6%B0%B8%E4%B8%8D%E8%BF%87%E6%97%B6/"/>
    <id>kkget.github.io/2020/07/22/%E4%BC%98%E9%9B%85%E6%B0%B8%E4%B8%8D%E8%BF%87%E6%97%B6/</id>
    <published>2020-07-22T09:12:30.000Z</published>
    <updated>2020-07-28T09:49:52.036Z</updated>
    
    <content type="html"><![CDATA[<p>无论是日常编码，还是业务涉及，能够优雅的表达思想，提高代码简洁度，阅读性都是一种能力，总结一下优雅的做法</p><p>###优雅的关闭流###<br>java7 try with resource，针对实现了AutoCloseable接口的类，都可优雅的关闭流，从而舍弃finally关闭</p><p>try catch finally</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader in = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">....</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (in != <span class="keyword">null</span>) &#123;</span><br><span class="line">in.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e2) &#123;</span><br><span class="line">e2.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>try  winth resource</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="keyword">final</span> BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader((<span class="keyword">new</span> URL(url + <span class="string">"?"</span> + param)).openConnection().getInputStream()));PrintWriter out =<span class="keyword">new</span> PrintWriter(response.getWriter()))&#123;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;<span class="keyword">catch</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.Netty 优雅的关闭流程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shutdownGracefully()</span><br></pre></td></tr></table></figure><p>3.Lambda表达式<br>list求交集</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Long&gt; collect = list1.stream().filter(list2::contains).collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p>4.设计模式代替if else,策略模式，模板模式</p><p>5.代码整洁度，例如多注入service，按着高矮胖瘦排列，视觉舒适，controller求求你别写业务代码了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  List <span class="title">getRandomList</span><span class="params">(List&lt;?&gt; paramList,<span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(count==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Random random=<span class="keyword">new</span> Random();</span><br><span class="line">        List&lt;Integer&gt; tempList=<span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//临时存放产生的list索引，去除重复的索引</span></span><br><span class="line">        List newList=<span class="keyword">new</span> ArrayList();<span class="comment">//生成新的list集合</span></span><br><span class="line">        <span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(count&lt;=<span class="number">1</span>)&#123;<span class="comment">//如果数据小于1，取一条数据</span></span><br><span class="line">            temp = random.nextInt(paramList.size());</span><br><span class="line">            newList.add(paramList.get(temp));</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Math.ceil(count);i++)&#123;</span><br><span class="line">                temp=random.nextInt(paramList.size());<span class="comment">//初始化一个随机数，将产生的随机数作为被抽list的索引</span></span><br><span class="line">                <span class="keyword">if</span>(!tempList.contains(temp))&#123;<span class="comment">//判断随机抽取的随机数</span></span><br><span class="line">                    tempList.add(temp);</span><br><span class="line">                    newList.add(paramList.get(temp));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    i--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newList;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>6.优雅判空<br>个人喜欢Assert判空，至于java8的Optional并没体会到优雅之处，日常StringUtils，Collections，isNoBlank等，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testOptional</span><span class="params">(Test test)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.ofNullable(test).flatMap(Test::getTest3)</span><br><span class="line">                .flatMap(Test3::getTest2)</span><br><span class="line">                .map(Test2::getInfo)</span><br><span class="line">                .orElse(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">看起来挺优雅，但日常没体会到</span><br></pre></td></tr></table></figure><p>还有日常常用的instanceof</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                            validated = <span class="keyword">true</span>;</span><br><span class="line">                            TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                            TreeNode&lt;K,V&gt; r, p;</span><br><span class="line">                            <span class="keyword">if</span> ((r = t.root) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                                (p = r.findTreeNode(hash, key, <span class="keyword">null</span>)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                V pv = p.val;</span><br><span class="line">                                <span class="keyword">if</span> (cv == <span class="keyword">null</span> || cv == pv ||</span><br><span class="line">                                    (pv != <span class="keyword">null</span> &amp;&amp; cv.equals(pv))) &#123;</span><br><span class="line">                                    oldVal = pv;</span><br><span class="line">                                    <span class="keyword">if</span> (value != <span class="keyword">null</span>)</span><br><span class="line">                                        p.val = value;</span><br><span class="line">                                    <span class="keyword">else</span> <span class="keyword">if</span> (t.removeTreeNode(p))</span><br><span class="line">                                        setTabAt(tab, i, untreeify(t.first));</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;无论是日常编码，还是业务涉及，能够优雅的表达思想，提高代码简洁度，阅读性都是一种能力，总结一下优雅的做法&lt;/p&gt;
&lt;p&gt;###优雅的关闭流###&lt;br&gt;java7 try with resource，针对实现了AutoCloseable接口的类，都可优雅的关闭流，从而舍弃f
      
    
    </summary>
    
    
    
      <category term="代码优化" scheme="kkget.github.io/tags/%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>面试题---小马哥次灵均阁</title>
    <link href="kkget.github.io/2020/07/21/java%E5%B8%B8%E8%A7%8110%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%B0%8F%E9%A9%AC%E5%93%A5/"/>
    <id>kkget.github.io/2020/07/21/java%E5%B8%B8%E8%A7%8110%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%B0%8F%E9%A9%AC%E5%93%A5/</id>
    <published>2020-07-21T06:40:31.000Z</published>
    <updated>2020-07-23T01:16:06.904Z</updated>
    
    <content type="html"><![CDATA[<p>1.java允许多继承吗？</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/Q2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>必须针对Autocloseable<br>FileInputStream   最终继承Autocloseable<br>找到字节码文件  javap -p  -v  .class<br>invokrvitrual   java 7编译器做的字节码提升</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/Q3.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>intern   reference   unique<br>B</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/Q3-1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>//变量，对象，引用<br>//变量：局部变量，成员变量(实例，static)，lable标签（变量名称，变量类型，引用指向）<br>//对象：java  Heap new 实例<br>//引用：强软弱虚</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/Q4.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>D<br>Finally 除了JVM退出  都会执行<br>如果Boolean flag=null;</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/Q5.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>muti -catch 无法使用子类关联<br>RuntimeException  非checked 异常  不需要throws</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/Q7.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>CopyOnwriteArrayList</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/Q8.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/Q8-1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/Q8-2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/Q9.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>否</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/Q8-4.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/Q8-5.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/Q10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>D<br>HashMap并发读是线程安全的</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/Q10-1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/Q10-2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>//合理关闭线程池<br>//Daemon线程</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.java允许多继承吗？&lt;/p&gt;
&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div
      
    
    </summary>
    
    
    
      <category term="面经" scheme="kkget.github.io/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>编程算法题</title>
    <link href="kkget.github.io/2020/07/08/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    <id>kkget.github.io/2020/07/08/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95%E9%A2%98/</id>
    <published>2020-07-08T01:36:18.000Z</published>
    <updated>2020-09-16T06:56:28.088Z</updated>
    
    <content type="html"><![CDATA[<p>#一：力扣第14题 编写一个函数来查找字符串数组中的最长公共前缀</p><p>官方解法：<br>##方法一：<strong>横向扫描</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/leetcode/1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/leetcode/2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>如果在尚未遍历完所有的字符串时，最长公共前缀已经是空串，则最长公共前缀一定是空串，因此不需要继续遍历剩下的字符串，直接返回空串即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String prefix = strs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> count = strs.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; count; i++) &#123;</span><br><span class="line">            prefix = longestCommonPrefix(prefix, strs[i]);</span><br><span class="line">            <span class="keyword">if</span> (prefix.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prefix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = Math.min(str1.length(), str2.length());</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; length &amp;&amp; str1.charAt(index) == str2.charAt(index)) &#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str1.substring(<span class="number">0</span>, index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析<br>时间复杂度：O(mn)O(mn)，其中 mm 是字符串数组中的字符串的平均长度，nn 是字符串的数量。最坏情况下，字符串数组中的每个字符串的每个字符都会被比较一次。<br>空间复杂度：O(1)O(1)。使用的额外空间复杂度为常数。<br>作者：LeetCode-Solution<br>链接：<a href="https://leetcode-cn.com/problems/longest-common-prefix/solution/zui-chang-gong-gong-qian-zhui-by-leetcode-solution/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-common-prefix/solution/zui-chang-gong-gong-qian-zhui-by-leetcode-solution/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><hr><p>#leetcode  用户灵魂画手<br><strong><em>思路</em></strong><br>标签：链表<br>当字符串数组长度为 0 时则公共前缀为空，直接返回<br>令最长公共前缀 ans 的值为第一个字符串，进行初始化<br>遍历后面的字符串，依次将其与 ans 进行比较，两两找出公共前缀，最终结果即为最长公共前缀<br>如果查找过程中出现了 ans 为空的情况，则公共前缀不存在直接返回<br>时间复杂度：O(s)O(s)，s 为所有字符串的长度之和<br><strong><em>代码</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(strs.length == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        String ans = strs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>;i&lt;strs.length;i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(;j&lt;ans.length() &amp;&amp; j &lt; strs[i].length();j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(ans.charAt(j) != strs[i].charAt(j))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = ans.substring(<span class="number">0</span>, j);</span><br><span class="line">            <span class="keyword">if</span>(ans.equals(<span class="string">""</span>))</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作者：guanpengchn<br>链接：<a href="https://leetcode-cn.com/problems/longest-common-prefix/solution/hua-jie-suan-fa-14-zui-chang-gong-gong-qian-zhui-b/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-common-prefix/solution/hua-jie-suan-fa-14-zui-chang-gong-gong-qian-zhui-b/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>#最易理解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        String s=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> judge=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(strs.length==<span class="number">0</span>)&#123;<span class="comment">//数组为空直接返回""</span></span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;strs[<span class="number">0</span>].length();i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> a=strs[<span class="number">0</span>].charAt(i);<span class="comment">//直接选择第一个数组元素，依次取这个字符串的字符</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;strs.length;j++)&#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(i&gt;=strs[j].length())&#123;<span class="comment">//因为每个字符串长度不同，防止溢出</span></span><br><span class="line">                    judge=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(a!=strs[j].charAt(i))&#123;</span><br><span class="line">                    judge=<span class="number">0</span>;<span class="comment">//只要存在不同，直接退出</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j==strs.length-<span class="number">1</span>)&#123;</span><br><span class="line">                        s=s+a;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(judge==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">版权声明：本文为博主原创文章，遵循 CC <span class="number">4.0</span> BY-SA 版权协议，转载请附上原文出处链接和本声明。</span><br><span class="line">本文链接：https:<span class="comment">//blog.csdn.net/shancx/article/details/82746264</span></span><br></pre></td></tr></table></figure><p>#二：未排序正整数数组中累加和为给定值的最长子数组长度<br>给定一个数组arr，该数组无序，每个数正数，给定一个K，求arr的所有子数组中所有元素相加和为k的最长子数组的长度。</p><p>例如：arr=[1,2,1,1,1],k=3</p><p>结果是3，[1,1,1]的长度。</p><p>思路：</p><p>首先用两个位置来标记子数组左右两头，记为left与right，开始的时候都在数组的最左边即left=right=0，过程如下：</p><p>1，开始变量left=0，right=0，代表子数组arr[left,right];</p><p>2，变量sum始终表示子数组arr[left,right]的和，开始的时候sum= arr[0],即是arr[0,0]的和；</p><p>3，变量len一直记录累加和为k的所有子数组中最大子数组的长度，开始的时候len=0;</p><p>4，根据sum与k的比较结果决定是left移动还right移动。若干sum==K，说明arr[left,right]累加和为k,如果长度大于len，更新len</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Array;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by wuxiaosi on 2017/9/24.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">getMaxLength</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span>[] arr=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        System.out.println(getMaxLengthK(arr,k));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMaxLengthK</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr==<span class="keyword">null</span>||arr.length==<span class="number">0</span>||k&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum=arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(right&lt;arr.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum==k)&#123;</span><br><span class="line">                len = Math.max(len,right-left+<span class="number">1</span>);</span><br><span class="line">                sum=sum-arr[left++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(sum&lt;k)&#123;</span><br><span class="line">                right++;<span class="comment">//向右移动</span></span><br><span class="line">                <span class="keyword">if</span>(right==arr.length)&#123;<span class="comment">//right到数组边界长度，就break</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                sum=sum+arr[right];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sum=sum-arr[left++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">————————————————</span><br><span class="line">版权声明：本文为CSDN博主「wuxiaosi808」的原创文章，遵循CC <span class="number">4.0</span> BY-SA版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https:<span class="comment">//blog.csdn.net/wuxiaosi808/article/details/78079574</span></span><br></pre></td></tr></table></figure><p>#三 有两个整数数组A1，A2，设计函数求其两个数组的最大值和第二大的值<br>思路一：</p><p>1.获取最值需要进行比较，每一次比较都会有一个较大的值，因为该值的不确定性，通过一个变量进行临时存储。</p><p>2.让数组中的每一个元素都和这个变量中的值进行比较，如果大于变量中的值，就用该变量记录较大值。</p><p>3.当所有的元素都比较完成，那么该变量中的存储就是数组中的最大值了。</p><p>步骤：</p><p>1.定义变量，初始化为数组中的任意一个元素。</p><p>2.通过循环语句对数组进行遍历。</p><p>3.在变量过程中定义判断条件，如果遍历到的元素比变量中的元素大，就赋值给该变量。</p><p>注意：</p><p>通过定义一个功能来完成，以便提高代码的复用性。该功能结果为数组中的最大元素，未知内容为数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr1 = &#123;<span class="number">9</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">7</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> max1 = getMax(arr1);</span><br><span class="line">System.out.println(<span class="string">"max1="</span>+max1);</span><br><span class="line"><span class="keyword">double</span>[] arr2 = &#123;<span class="number">9.0</span>,<span class="number">5.0</span>,<span class="number">6.0</span>,<span class="number">3.0</span>,<span class="number">1.0</span>,<span class="number">2.0</span>,<span class="number">8.0</span>,<span class="number">7.0</span>&#125;;</span><br><span class="line"><span class="keyword">double</span> max2 = getMax(arr2);</span><br><span class="line">System.out.println(<span class="string">"max2="</span>+max2);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取int类型数组最大值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMax</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(arr[i]&gt;max)</span><br><span class="line">max = arr[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取double类型数组最大值，功能相似，以重载的形式存在</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">getMax</span><span class="params">(<span class="keyword">double</span>[] arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">double</span> max = arr[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(arr[i]&gt;max)</span><br><span class="line">max = arr[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路二：</p><p>1.定义变量，初始化为数组角标0。</p><p>2.通过循环语句对数组进行遍历。</p><p>3.在变量过程中定义判断条件，如果遍历到的元素比角标所在的元素中的数值大，就将较大值的角标赋值给变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr1 = &#123;<span class="number">9</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">7</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> max1 = getMax(arr1);</span><br><span class="line">System.out.println(<span class="string">"max1="</span>+max1);</span><br><span class="line"><span class="keyword">double</span>[] arr2 = &#123;<span class="number">9.0</span>,<span class="number">5.0</span>,<span class="number">6.0</span>,<span class="number">3.0</span>,<span class="number">1.0</span>,<span class="number">2.0</span>,<span class="number">8.0</span>,<span class="number">7.0</span>&#125;;</span><br><span class="line"><span class="keyword">double</span> max2 = getMax(arr2);</span><br><span class="line">System.out.println(<span class="string">"max2="</span>+max2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取int类型数组最大值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMax</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(arr[i]&gt;arr[max])</span><br><span class="line">max = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arr[max];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取double类型数组最大值，功能相似，以重载的形式存在</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">getMax</span><span class="params">(<span class="keyword">double</span>[] arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">double</span> max = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(arr[i]&gt;arr[max])</span><br><span class="line">max = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arr[max];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>————————————————<br>版权声明：本文为CSDN博主「Destiny_lt」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/ytu_lt/article/details/70160598" target="_blank" rel="noopener">https://blog.csdn.net/ytu_lt/article/details/70160598</a></p><p>#四 翻转单词顺序列（I am a student.-&gt;student. a am I）<br>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student. “，则输出”student. a am I”<br>方法一：双指针<br>算法解析：<br>倒序遍历字符串 ss ，记录单词左右索引边界 ii , jj ；<br>每确定一个单词的边界，则将其添加至单词列表 resres ；<br>最终，将单词列表拼接为字符串，并返回即可。<br>复杂度分析：<br>时间复杂度 O(N)O(N) ： 其中 NN 为字符串 ss 的长度，线性遍历字符串。<br>空间复杂度 O(N)O(N) ： 新建的 list(Python) 或 StringBuilder(Java) 中的字符串总长度 \leq N≤N ，占用 O(N)O(N) 大小的额外空间。<br><strong><em>代码</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        s = s.trim(); <span class="comment">// 删除首尾空格</span></span><br><span class="line">        <span class="keyword">int</span> j = s.length() - <span class="number">1</span>, i = j;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; s.charAt(i) != <span class="string">' '</span>) i--; <span class="comment">// 搜索首个空格</span></span><br><span class="line">            res.append(s.substring(i + <span class="number">1</span>, j + <span class="number">1</span>) + <span class="string">" "</span>); <span class="comment">// 添加单词</span></span><br><span class="line">            <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; s.charAt(i) == <span class="string">' '</span>) i--; <span class="comment">// 跳过单词间空格</span></span><br><span class="line">            j = i; <span class="comment">// j 指向下个单词的尾字符</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString().trim(); <span class="comment">// 转化为字符串并返回</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：分割 + 倒序<br>利用 “字符串分割”、“列表倒序” 的内置函数 （面试时不建议使用） ，可简便地实现本题的字符串翻转要求<br>复杂度分析：<br>时间复杂度 O(N)O(N) ： 总体为线性时间复杂度，各函数时间复杂度和参考资料链接如下。<br>split() 方法： 为 O(N)O(N) ；<br>trim() 和 strip() 方法： 最差情况下（当字符串全为空格时），为 O(N)O(N) ；<br>join() 方法： 为 O(N)O(N) ；<br>reverse() 方法： 为 O(N)O(N) ；<br>空间复杂度 O(N)O(N) ： 单词列表 strsstrs 占用线性大小的额外空间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        String[] strs = s.trim().split(<span class="string">" "</span>); <span class="comment">// 删除首尾空格，分割字符串</span></span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = strs.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">// 倒序遍历单词列表</span></span><br><span class="line">            <span class="keyword">if</span>(strs[i].equals(<span class="string">""</span>)) <span class="keyword">continue</span>; <span class="comment">// 遇到空单词则跳过</span></span><br><span class="line">            res.append(strs[i] + <span class="string">" "</span>); <span class="comment">// 将单词拼接至 StringBuilder</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString().trim(); <span class="comment">// 转化为字符串，删除尾部空格，并返回</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：jyd</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/solution/mian-shi-ti-58-i-fan-zhuan-dan-ci-shun-xu-shuang-z/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><p>方法二</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">ReverseSentence</span><span class="params">(String str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//先单个单词反转,再整体反转。I am a student.》》I ma a .tneduts 》》student. a am I</span></span><br><span class="line">        <span class="keyword">if</span>(str.length()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[]chs=str.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对单个字符数组元素进行反转</span></span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;<span class="comment">//定义两个指针进行遍历</span></span><br><span class="line">        <span class="keyword">while</span>(j&lt;=str.length())&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//以空格作为区分，对每个单词进行反转</span></span><br><span class="line">            <span class="keyword">if</span>(j==str.length()||chs[j]==<span class="string">' '</span>)&#123;<span class="comment">//j==str.length()不要忘记</span></span><br><span class="line">                reverse(chs,i,j-<span class="number">1</span>);</span><br><span class="line">                i=j+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果chs[j]!=' '那么继续遍历直到找到空格</span></span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//整体字符串反转</span></span><br><span class="line">        reverse(chs,<span class="number">0</span>,str.length()-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(chs);<span class="comment">//学习</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">char</span>[]ch,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            <span class="comment">//反转交换,代码是一样的</span></span><br><span class="line">            <span class="keyword">char</span> temp=ch[i];</span><br><span class="line">            ch[i]=ch[j];</span><br><span class="line">            ch[j]=temp;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">版权声明：本文为博主原创文章，遵循 CC <span class="number">4.0</span> BY-SA 版权协议，转载请附上原文出处链接和本声明。</span><br><span class="line">本文链接：https:<span class="comment">//blog.csdn.net/hefenglian/article/details/79932709</span></span><br></pre></td></tr></table></figure><p>#最牛逼的解法：JavaScript<br>解法：先用trim()把字符串两端空格去掉，split(‘ ‘)把字符串切割成以空格为界限的单词块，filter()过滤掉数组中的纯空格，reverse()进行数组反转，join(‘ ‘)把数组变成中间只带一个空格的字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">var</span> reverseWords = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> str = s.trim().split(<span class="string">' '</span>).filter(<span class="function"><span class="params">item</span> =&gt;</span> item!=<span class="string">''</span>).reverse().join(<span class="string">' '</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(str)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">作者：CHH_</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/solution/yi-xing-dai-ma-jie-jue-suo-you-by-chen-1wz/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><p>暴力求解法(百度百科)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">暴力求解法, 又名直接带入法（Directly Calculating）它是已知最古老的算法之一，与&quot;直观目测法&quot;，&quot;心灵感应法&quot;并称世界三大不可思议数学计算法则， 其可追溯至3200年前，古老的埃及人便开始使用象形文字进行复杂的数学演算。它首次的文本出现是欧几里德的《几何原本》（第V卷，命题i和ii）中，而在中国则可以追溯至宋朝末年出现的沈括《梦溪笔谈》</span><br></pre></td></tr></table></figure><p>暴力求解法的由来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在汉高祖时期有一个有趣的小故事是这样的:</span><br><span class="line">“高祖年间,大将军韩信征讨突厥得胜,七月七日凯旋而归，其时举国腾。信进宫，高祖曰:’淮阴侯乃真人也，战无不功克，朕三年尝闻智勇，招为爱卿，果其然，甚好甚慰。’信曰:’大王聪明仁惠，敬贤礼士，江表英豪贤归附，臣听闻蜀地龙光射牛斗之墟，人杰多地灵，又适王举兵招马，无怪骏才星驰。’高祖对曰:’今汝方成大业，且问卿求?’信:’乃望众亲赐匹布，以二渐累。’回:’善，明日使文库之卿，方得人数。’隔日使返，帝问:”需布甚许?”曰:”臣不才，方得淮阴侯亲友八十五者，食客则七百七十六人之众，臣斗胆以树枝编排数之方得须七三万千三百二十馀一匹”帝惊道:”甚许!乃至库之空不能所期，淮阴岂谋他意?”遂隔日将信斩之，不知了了。”</span><br></pre></td></tr></table></figure><p>暴力求解法的演算<br>1.例题:在地面上的同一1地点分别以速率V1、V2先后竖直像上抛出两个可视为质点的小球。第二个小球抛出后经过T时间与第一个小球相遇。改变两小球抛出的时间间隔，若V1&lt;V2，不计空气阻力，则T的最大值为<strong><strong><strong>__</strong></strong></strong><br>解:依照暴力求解法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">设第一小球抛出后t0时间与第二小球相遇 (此时第二小球已运动T,T&lt;t0)</span><br><span class="line">因为 h1 &#x3D; h2</span><br><span class="line">v1t0 - 1&#x2F;2g(t0)^2 &#x3D; v2T -1&#x2F;2gT^2</span><br><span class="line">所以 T &#x3D; (v2+√(v2^2-2g(v1t0 - 1&#x2F;2g(t0)^2))) &#x2F; g</span><br><span class="line">又 T &lt; v2&#x2F;g</span><br><span class="line">根据复杂计算</span><br><span class="line">可得 T &#x3D; (v2-√v2^2-v1^2) &#x2F; g</span><br><span class="line">所以 Tmax &#x3D; (v2-√v2^2-v1^2) &#x2F; g</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#一：力扣第14题 编写一个函数来查找字符串数组中的最长公共前缀&lt;/p&gt;
&lt;p&gt;官方解法：&lt;br&gt;##方法一：&lt;strong&gt;横向扫描&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class
      
    
    </summary>
    
    
    
      <category term="算法" scheme="kkget.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>蚂蚁一面整理</title>
    <link href="kkget.github.io/2020/07/02/%E8%9A%82%E8%9A%81%E4%B8%80%E9%9D%A2%E6%95%B4%E7%90%86/"/>
    <id>kkget.github.io/2020/07/02/%E8%9A%82%E8%9A%81%E4%B8%80%E9%9D%A2%E6%95%B4%E7%90%86/</id>
    <published>2020-07-02T07:48:21.000Z</published>
    <updated>2020-09-01T08:45:31.817Z</updated>
    
    <content type="html"><![CDATA[<p>1.java的同步容器，并发容器？<br>同步：即每次只有一个线程访问容器状态。<br>并发：即每次可有多个线程访问容器状态。<br>同步容器：Vector，HashTable<br>并发容器：ConCurrentHashMap，CopeyOnwrite<br>–当并发读远多于修改的场景下需要使用List和Set时，可以考虑使用CopyOnWriteArrayList和CopyOnWriteArraySet；<br>–当需要并发使用&lt;Key, Value&gt;键值对存取数据时，可以使用ConcurrentHashMap；<br>–当要保证并发&lt;Key, Value&gt;键值对有序时可以使用ConcurrentSkipListMap。<br>2.ArrayList和LinkedList的插入和访问的复杂度<br>即数组与链表的访问插入复杂度<br>1&gt;.数组在访问时可通过下标直接查询，复杂度O(1),链表复杂度O(n)<br>2&gt;.数组插入时数组下标需要移动O(n)，链表直接操作指针O(1)<br>反射原理—&gt;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;反射可动态加载外部配置对象，通过class.forName加载类信息，而forName方法就是通过反射类调用的类信息，</span><br><span class="line">jvm加载获取到里面的classLoader，通过native方法获取类信息，最终调用invoke0()方法，反射是线程安全的，</span><br><span class="line">因为loadClass方法是synchronized修饰的，找到需要的方法，都会copy一份出来，而不是使用原来的实例，从而保证数据隔离；</span><br></pre></td></tr></table></figure><p>注解原理—&gt;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;注解等同于加了标记,注解本质是一个继承了Annotation的特殊接口，其具体实现类是Java 运行时生成的动态代理类。而我们通过反射获取注解时，返回的是Java 运行时生成的动态代理对象$Proxy1。通过代理对象调用自定义注解（接口）的方法，会最终调用AnnotationInvocationHandler 的invoke 方法。该方法会从memberValues 这个Map 中索引出对应的值。而memberValues 的来源是Java 常量池</span><br><span class="line">注解参数成员必须是public的，没有成员方法也行，但是就没得意义了</span><br></pre></td></tr></table></figure><p>4.新生代分为几个区？使用什么算法进行垃圾回收？为什么使用这个算法？<br>新生代分为Eden区，幸存from区，幸存to区，大小比例8:1:1<br>新生代使用复制算法，高效，省去了标记整理的过程，新生代需要清理的对象数量巨大，复制算法浪费空间，但效率高，<br>–&gt;引申<br>MinorGC的过程(复制-&gt;清空-&gt;互换)<br>1:Eden,SurvivorFrom复制到SurvivorTo，年龄+1</p><p>首先，当Eden区满的时候会触发第一次GC,把还活着的对象拷贝到SurvivorFrom区，当Eden区再次出发GC的时候会扫描Eden区和form区，对这个区域进行垃圾回收，经过这次回收还活着的，复制到To区，对象年龄+1</p><p>2:清空Eden区、SurvivorFrom</p><p>然后清空Eden区和SurvivorFrom区的对象，谁空谁是to。</p><p>3:SurvivorTo和SurvivorFrom互换</p><p>互换之后SurvivorTo成为下一次GC的From区，当对象年龄达到15，最终如果存活，存入老年代。<br>—&gt;jvm分区</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/jvm.png" alt="jvm分区" title="">                </div>                <div class="image-caption">jvm分区</div>            </figure><p>堆栈方法区<br>堆管存储，类实例和数组对象存储<br>栈管运行，存储基础数据类型和引用，栈帧<br>1.8之前是方法区，1.8之后改为元空间，存储静态变量 + 常量 + 类信息(构造方法/接口定义) + 运行时常量池存在方法区中<br>—&gt;垃圾回收算法<br>复制算法，标记清除，标记压缩，引用计数算法，可达性分析算法<br>复制算法</p><p>把空间分成两块，每次只对其中一块进行 GC。当这块内存使用完时，就将还存活的对象复制到另一块上面。</p><p>引用计数法：循环引用不可回收，不推荐</p><p>GCRoot：可达性分析算法</p><p>从根集对象向下搜索，如果一个对象没有任何链相连时，则说明对象不可用。</p><p>哪些可以作为GC root的对象<br>1.虚拟机栈中的引用对象<br>2.方法区中的类静态属性引用的对象<br>3.方法区中常量引用的对象<br>4.本地方法栈中引用的对象<br>如何确定垃圾？<br>已经不再被内存使用到的空间<br>JVM虚拟机 YGC和FGC发生的具体场景<br>1、YGC和FGC是什么<br>YGC ：对新生代堆进行gc。频率比较高，因为大部分对象的存活寿命较短，在新生代里被回收。性能耗费较小。         （复制算法 —&gt; 一般适用对象存活率低的场景）</p><p>FGC ：全堆范围的gc。默认堆空间使用到达80%(可调整)的时候会触发fgc。                                                    （标记整理或者标记清除算法 —&gt; 一般适用于对象存活率高的场景）</p><p>2、什么时候执行YGC和FGC</p><p>1、eden空间不足,执行 young gc</p><p>2、old空间不足，perm空间不足，调用方法System.gc() ，ygc时的悲观策略,<br> dump live的内存信息时(jmap –dump:live)，都会执行full gc<br>3.JVM老年代和新生代的比例<br>在 Java 中，堆被划分成两个不同的区域：新生代 ( Young )、老年代 ( Old )。新生代 ( Young ) 又被划分为三个区域：Eden、From Survivor、To Survivor。<br>这样划分的目的是为了使 JVM 能够更好的管理堆内存中的对象，包括内存的分配以及回收。<br>新生代 ( Young ) 与老年代 ( Old ) 的比例的值为 1:2 ( 该值可以通过参数 –XX:NewRatio 来指定 )，即：新生代 ( Young ) = 1/3 的堆空间大小。老年代 ( Old ) = 2/3 的堆空间大小。其中，新生代 ( Young ) 被细分为 Eden 和 两个 Survivor 区域，这两个 Survivor 区域分别被命名为 from 和 to，以示区分。<br>默认的，Eden : from : to = 8 : 1 : 1 ( 可以通过参数 –XX:SurvivorRatio 来设定 )<br>&lt;<br>#频繁 fullgc 的排查<br>#频繁 fullgc 的排查<br>full gc产生场景如上叙述一下<br>其次猜测一下大概产生原因<br>尤其是大对象，80%以上的情况就是他。  那么大对象从哪里来的：<br>【1】数据库（包括 Mysql和 Mongodb等 NOSql数据库），结果集太大；<br>【2】第三方接口传输的大对象；<br>【3】消息队列，消息太大；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">排查步骤----&gt;</span><br><span class="line">(1):打印GCdetail</span><br><span class="line">-XX:+PrintGCDtails</span><br><span class="line">(2):生成dump文件  注意:dump操作的时候是会发生stop the word事件的，也就是说此时所有的用户线程都会暂停运行</span><br><span class="line">开启XX:+HeapDumpBeforeFullGC</span><br><span class="line">使用jvisualvm查看</span><br></pre></td></tr></table></figure><blockquote></blockquote><p>&lt;关于top k 问题已经在实际解决Linux  阿里云服务器问题应用&gt;<br>—&gt;JMM<br>java  memory model<br>—&gt;垃圾收集器<br>并行 串行 并发标记 CMS G1 ZGC<br>G1不产生内存碎片 可精准控制停顿<br>–&gt;CMS垃圾回收过程<br>1.总体介绍：<br>CMS(Concurrent Mark-Sweep)是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动JVM参数加上-XX:+UseConcMarkSweepGC ，这个参数表示对于老年代的回收采用CMS。CMS采用的基础算法是：标记—清除。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/cms.png" alt="CMS" title="">                </div>                <div class="image-caption">CMS</div>            </figure><p>2.CMS过程：<br>初始标记(STW initial mark)<br>并发标记(Concurrent marking)<br>并发预清理(Concurrent precleaning)<br>重新标记(STW remark)<br>并发清理(Concurrent sweeping)<br>并发重置(Concurrent reset)<br>5.如何处理接口的重复请求？不得不说他不好好问，目的是问如何保证接口的幂等性?<br>分布式系统中，服务部署在不同的服务器上，但是数据要保证打到一个redis上<br>对于每个请求必须有一个唯一的标识。举个例子：订单支付请求，肯定得包含订单 id，一个订单 id 最多支付一次。<br>每次处理完请求之后，必须有一个记录标识这个请求处理过了。常见的方案是在数据库中记录个状态，比如支付之前记录一条这个订单的支付流水。<br>每次接收请求需要进行判断，判断之前是否处理过。比如说，如果有一个订单已经支付了，就已经有了一条支付流水，那么如果重复发送这个请求，则此时先插入支付流水，orderId 已经存在了，唯一键约束生效，报错插入不进去的。然后系统就不用再扣款了。<br>在网络延迟传输中，会造成消息队列重试，在重试过程中，消息会存在重复</p><p>解决方案：</p><p>  1.如果是数据库的插入操作，给消息做一个主键，避免出现脏数据。<br>  2.使用第三方做消费记录，例如Redis，全局id为K，消息为V，写入到Redis，消费之前先去查Redis是否存在<br>–&gt;引申分布式系统中如何生成高效的分布式唯一ID   雪花算法<br>可用分布式锁,redis 递增,机器的唯一码 拿出几位存为机器id,这样一来每次查询操作相对更快</p><p>G1回收器有个非常好的特性就是会不断的帮助JVM调整策略， 会根据实际的GC情况调整年轻代和老年代的比例大小，默认情况下，年轻代最多可以占用60%的堆内存。这其实就是GC的灵活性。</p><p>G1的另一个显著特点他能够让用户设置应用的暂停时间，通过参数：-XX:MaxGCPauseMillis来指定，为什么G1能做到这一点呢？也许你已经注意到了，G1回收的第4步，它是“选择一些内存块”，而不是整代内存来回收，这是G1跟其它GC非常不同的一点，其它GC每次回收都会回收整个Generation的内存(Eden, Old), 而回收内存所需的时间就取决于内存的大小，以及实际垃圾的多少，所以垃圾回收时间是不可控的；而G1每次并不会回收整代内存，到底回收多少内存就看用户配置的暂停时间，配置的时间短就少回收点，配置的时间长就多回收点，伸缩自如<br>九：Http与Https的区别？<br>博客:<a href="https://blog.csdn.net/guolin_blog/article/details/104546558" target="_blank" rel="noopener">https://blog.csdn.net/guolin_blog/article/details/104546558</a><br>总结：首先回答对称加密以及非对称加密的区别。<br>对称加密比较简单，就是客户端和服务器共用同一个密钥，该密钥可以用于加密一段内容，同时也可以用于解密这段内容。对称加密的优点是加解密效率高，但是在安全性方面可能存在一些问题，因为密钥存放在客户端有被窃取的风险。对称加密的代表算法有：AES、DES等。</p><p>而非对称加密则要复杂一点，它将密钥分成了两种：公钥和私钥。公钥通常存放在客户端，私钥通常存放在服务器。使用公钥加密的数据只有用私钥才能解密，反过来使用私钥加密的数据也只有用公钥才能解密。非对称加密的优点是安全性更高，因为客户端发送给服务器的加密信息只有用服务器的私钥才能解密，因此不用担心被别人破解，但缺点是加解密的效率相比于对称加密要差很多。非对称加密的代表算法有：RSA、ElGamal等。<br>关键词：CA机构<br>个人理解：https使用的是对称加密与非对称加密相结合的方式。首先双端通信使用非对称加密，客户端加密传输时先请求第三方CA机构，CA加密处理完返回给服务器端，证书中加入了网站的域名，</p><hr><p><strong>redis掀桌连问</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/redis.png" alt="redis" title="">                </div>                <div class="image-caption">redis</div>            </figure><p>1.redis的hash怎么实现的？(实现原理)rehash过程<br>redis初始创建hash表,有序集合，链表时, 存储结构采用一种ziplist的存储结构, 这种结构内存排列更紧密, 能提高访存性能.<br>hash_max_ziplist_entries和hash_max_ziplist_value值作为阀值，hash_max_ziplist_entries表示一旦ziplist中元素数量超过该值，则需要转换为dict结构；hash_max_ziplist_value表示一旦ziplist中数据长度大于该值，则需要转换为dict结构。<br>哈希等价于Java语言的HashMap或者是Python语言的字典（Dict）<br>redis hash 的内部结构.第一维是数组,第二维是链表.组成一个 hashtable.<br>在 Java 中 HashMap 扩容是个很耗时的操作,需要去申请新的数组,为了追求高性能,Redis 采用了渐进式 rehash 策略.这也是 hash 中最重要的部分.<br>在扩容的时候 rehash 策略会保留新旧两个 hashtable 结构,查询时也会同时查询两个 hashtable.Redis会将旧 hashtable 中的内容一点一点的迁移到新的 hashtable 中,当迁移完成时,就会用新的  hashtable 取代之前的.当 hashtable 移除了最后一个元素之后,这个数据结构将会被删除.<br><a href="https://juejin.im/post/5cfe6383e51d45599e019d8f" target="_blank" rel="noopener">https://juejin.im/post/5cfe6383e51d45599e019d8f</a><br><strong><em>与java的hashmap的rehash区别</em></strong><br>个人理解：hashmap的rehash是一次性拷贝的，不同的是，Redis的字典只能是字符串，另外他们rehash的方式不一样，因为Java的HashMap的字典很大时，rehash是个耗时的操作，需要一次全部rehash。Redis为了追求高性能，不能堵塞服务，所以采用了渐进式rehash策略。<br>rehash的详细步骤<br><a href="https://www.cnblogs.com/meituantech/p/9376472.html" target="_blank" rel="noopener">https://www.cnblogs.com/meituantech/p/9376472.html</a><br><strong><em>与ConcurrentHashMap扩容的策略比较？</em></strong><br>ConcurrentHashMap采用的扩容策略为： “多线程协同式rehash“。<br>1.扩容所花费的时间对比： 一个单线程渐进扩容，一个多线程协同扩容。在平均的情况下，是ConcurrentHashMap 快。这也意味着，扩容时所需要 花费的空间能够更快的进行释放。<br>2.读操作，两者性能相差不多。<br>3.写操作，Redis的字典返回更快些，因为它不像ConcurrentHashMap那样去帮着扩容(当要写的桶位已经搬到了newTable时)，等扩容完才能进行操作。<br>4.删除操作，与写一样。<br> <a href="http://xytschool.com/resource/236.html" target="_blank" rel="noopener">http://xytschool.com/resource/236.html</a><br><strong><em>redis如何保证高可用</em></strong><br>保证redis高可用机制需要redis主从复制、redis持久化机制、哨兵机制、keepalived等的支持。<br>主从复制的作用：数据备份、读写分离、分布式集群、实现高可用、宕机容错机制等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">首先主从复制需要分为两个角色：master(主) 和 slave(从) ，注意：redis里面只支持一个主，不像Mysql、Nginx主从复制可以多主多从。</span><br><span class="line"></span><br><span class="line">(1)redis的复制功能是支持多个数据库之间的数据同步。一类是主数据库（master）一类是从数据库（slave），主数据库可以进行读写操作，当发生写操作的时候自动将数据同步到从数据库，而从数据库一般是只读的，并接收主数据库同步过来的数据，一个主数据库可以有多个从数据库，而一个从数据库只能有一个主数据库。</span><br><span class="line"></span><br><span class="line">(2)通过redis的复制功能可以很好的实现数据库的读写分离，提高服务器的负载能力。主数据库主要进行写操作，而从数据库负责读操作。</span><br><span class="line"></span><br><span class="line">https:&#x2F;&#x2F;blog.csdn.net&#x2F;itcats_cn&#x2F;article&#x2F;details&#x2F;82428716</span><br></pre></td></tr></table></figure><p><strong><em>说说redis的持久化机制，为啥不能用redis做专门的持久化数据库存储？</em></strong><br>个人理解：强一致性的数据是不适合放在缓存中的。另外MySQL对事务的支持也是redis本身不能达到的，需要单独实现<br>一般不是说redis or  MySQL,而是redis+MySQL<br><a href="https://blog.csdn.net/u011784767/article/details/76824822" target="_blank" rel="noopener">https://blog.csdn.net/u011784767/article/details/76824822</a><br>为什么Redis进行RDB持久化数据时，新起一个进程而不是在原进程中起一个线程来持久化数据<br>(1)Redis RDB持久化机制会阻塞主进程，这样主进程就无法响应客户端请求。<br>(2)我们知道Redis对客户端响应请求的工作模型是单进程和单线程的，如果在主进程内启动一个线程，这样会造成对数据的竞争条件，为了避免使用锁降低性能。基于以上两点这就是为什么Redis通过启动一个进程来执行RDB了<br>—单线程的redis为什么这么快</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(1)纯内存操作</span><br><span class="line">(2)单线程操作，避免了频繁的上下文切换</span><br><span class="line">(3)采用了非阻塞I&#x2F;O多路复用机制</span><br></pre></td></tr></table></figure><p>—Redis的数据类型以及使用场景</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">(1)String</span><br><span class="line">这个其实没啥好说的，最常规的set&#x2F;get操作，value可以是String也可以是数字。</span><br><span class="line">一般做一些复杂的计数功能的缓存。</span><br><span class="line"></span><br><span class="line">(2)hash</span><br><span class="line">这里value存放的是结构化的对象，比较方便的就是操作其中的某个字段。博主在做单点登录的时候，</span><br><span class="line">就是用这种数据结构存储用户信息，以cookieId作为key，设置30分钟为缓存过期时间，能很好的模拟出类似session的效果。</span><br><span class="line"></span><br><span class="line">(3)list</span><br><span class="line">使用List的数据结构，可以做简单的消息队列的功能。另外还有一个就是，可以利用lrange命令，</span><br><span class="line">做基于redis的分页功能，性能极佳，用户体验好。</span><br><span class="line"></span><br><span class="line">(4)set</span><br><span class="line">因为set堆放的是一堆不重复值的集合。所以可以做全局去重的功能。为什么不用JVM自带的Set进行去重？</span><br><span class="line">因为我们的系统一般都是集群部署，使用JVM自带的Set，比较麻烦，难道为了一个做一个全局去重，再启一个公共服务，太麻烦了。</span><br><span class="line"></span><br><span class="line">另外，就是利用交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。</span><br><span class="line"></span><br><span class="line">(5)sorted set</span><br><span class="line">sorted set多了一个权重参数score,集合中的元素能够按score进行排列。可以做排行榜应用，取TOP N操作。sorted set可以用来做延时任务。最后一个应用就是可以做范围查找</span><br></pre></td></tr></table></figure><p>—redis的过期策略以及内存淘汰机制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis采用的是定期删除+惰性删除+内存淘汰策略。</span><br><span class="line">[2020年6月29日17:25:36在平时的项目中测试，不定期会产生无用token的key数据，平时可以进行模糊删除]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">缓存穿透，即黑客故意去请求缓存中不存在的数据，导致所有的请求都怼到数据库上，从而数据库连接异常。</span><br><span class="line"></span><br><span class="line">解决方案:</span><br><span class="line">(一)利用互斥锁，缓存失效的时候，先去获得锁，得到锁了，再去请求数据库。没得到锁，则休眠一段时间重试</span><br><span class="line">(二)采用异步更新策略，无论key是否取到值，都直接返回。value值中维护一个缓存失效时间，缓存如果过期，</span><br><span class="line">异步起一个线程去读数据库，更新缓存。需要做缓存预热(项目启动前，先加载缓存)操作。</span><br><span class="line">(三)提供一个能迅速判断请求是否有效的拦截机制，比如，利用布隆过滤器，内部维护一系列合法有效的key。</span><br><span class="line">迅速判断出，请求所携带的Key是否合法有效。如果不合法，则直接返回。</span><br><span class="line"></span><br><span class="line">缓存雪崩，即缓存同一时间大面积的失效，这个时候又来了一波请求，结果请求都怼到数据库上，从而导致数据库连接异常。</span><br><span class="line"></span><br><span class="line">解决方案:</span><br><span class="line">(一)给缓存的失效时间，加上一个随机值，避免集体失效。</span><br><span class="line">(二)使用互斥锁，但是该方案吞吐量明显下降了。</span><br><span class="line">(三)双缓存。我们有两个缓存，缓存A和缓存B。缓存A的失效时间为20分钟，缓存B不设失效时间。</span><br><span class="line">自己做缓存预热操作。然后细分以下几个小点</span><br><span class="line">1 从缓存A读数据库，有则直接返回</span><br><span class="line">2 A没有数据，直接从B读数据，直接返回，并且异步启动一个更新线程。</span><br><span class="line">3 更新线程同时更新缓存A和缓存B。</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">8、如何解决redis的并发竞争key问题</span><br><span class="line"> </span><br><span class="line">分析:这个问题大致就是，同时有多个子系统去set一个key。这个时候要注意什么呢？大家思考过么。</span><br><span class="line">需要说明一下，博主提前百度了一下，发现答案基本都是推荐用redis事务机制。博主不推荐使用redis的事务机制。</span><br><span class="line">因为我们的生产环境，基本都是redis集群环境，做了数据分片操作。你一个事务中有涉及到多个key操作的时候，</span><br><span class="line">这多个key不一定都存储在同一个redis-server上。因此，redis的事务机制，十分鸡肋。</span><br><span class="line"></span><br><span class="line">回答:如下所示</span><br><span class="line">(1)如果对这个key操作，不要求顺序</span><br><span class="line">这种情况下，准备一个分布式锁，大家去抢锁，抢到锁就做set操作即可，比较简单。</span><br><span class="line">(2)如果对这个key操作，要求顺序</span><br><span class="line">假设有一个key1,系统A需要将key1设置为valueA,系统B需要将key1设置为valueB,系统C需要将key1设置为valueC.</span><br><span class="line">期望按照key1的value值按照 valueA--&gt;valueB--&gt;valueC的顺序变化。这种时候我们在数据写入数据库的时候，</span><br><span class="line">需要保存一个时间戳。假设时间戳如下</span><br><span class="line">系统A key 1 &#123;valueA  3:00&#125;</span><br><span class="line">系统B key 1 &#123;valueB  3:05&#125;</span><br><span class="line">系统C key 1 &#123;valueC  3:10&#125;</span><br><span class="line">那么，假设这会系统B先抢到锁，将key1设置为&#123;valueB 3:05&#125;。接下来系统A抢到锁，发现自己的valueA的时间戳早于缓存中的时间戳，那就不做set操作了。以此类推。</span><br></pre></td></tr></table></figure><p>9.0 redis分页<br>HSCAN testHash “0”  count 10<br>注：测试field数量在22条时（没有测试Redis中Hash使分页生效时的field数量的下限），分页未生效。</p><hr><p>#mysql 执行一个 sql 的过程<br>执行完毕之后有一个缓存的过程</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/mysql.png" alt="mysql" title="">                </div>                <div class="image-caption">mysql</div>            </figure><p><a href="https://www.cnblogs.com/luoying/p/12073812.html" target="_blank" rel="noopener">https://www.cnblogs.com/luoying/p/12073812.html</a><br>MySQL分页limit速度太慢的优化方法<br>1.子查询优化法<br>先找出第一条数据，然后大于等于这条数据的id就是要获取的数据<br>缺点：数据必须是连续的，可以说不能有where条件，where条件会筛选数据，导致数据失去连续性<br>2.limit限制优化法<br>   把limit偏移量限制低于某个数<br>3.where条件先过滤后分页<br>wait notify  为什么要搭配使用？<br>单独调用会报异常<br>只有在调用线程拥有某个对象的独占锁时，才能够调用该对象的wait(),notify()和notifyAll()方法。因为程序验证通常是在对象的同步方法或同步代码块中调用它们的。如果尝试在未获取对象锁时调用这三个方法，<br>“java.lang.IllegalMonitorStateException:current thread not owner”。<br>底层把对象作为一个监视器   </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.java的同步容器，并发容器？&lt;br&gt;同步：即每次只有一个线程访问容器状态。&lt;br&gt;并发：即每次可有多个线程访问容器状态。&lt;br&gt;同步容器：Vector，HashTable&lt;br&gt;并发容器：ConCurrentHashMap，CopeyOnwrite&lt;br&gt;–当并发读远
      
    
    </summary>
    
    
    
      <category term="面经" scheme="kkget.github.io/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>List遍历删除</title>
    <link href="kkget.github.io/2020/07/02/List%E9%81%8D%E5%8E%86%E5%88%A0%E9%99%A4/"/>
    <id>kkget.github.io/2020/07/02/List%E9%81%8D%E5%8E%86%E5%88%A0%E9%99%A4/</id>
    <published>2020-07-02T02:56:32.000Z</published>
    <updated>2020-07-13T02:49:02.398Z</updated>
    
    <content type="html"><![CDATA[<p>方法一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       list.add(<span class="string">"a"</span>);</span><br><span class="line">       list.add(<span class="string">"ab"</span>);</span><br><span class="line">       list.add(<span class="string">"abc"</span>);</span><br><span class="line">       list.add(<span class="string">"ad"</span>);</span><br><span class="line">       Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line">       <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">           String next = iterator.next();</span><br><span class="line">           <span class="keyword">if</span>(<span class="string">"a"</span>.equals(next)||<span class="string">"c"</span>.equals(next))&#123;</span><br><span class="line">               iterator.remove();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(JSONObject.toJSONString(list));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&quot;ab&quot;,&quot;abc&quot;,&quot;ad&quot;]</span><br></pre></td></tr></table></figure><p>方法二</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">"a"</span>);</span><br><span class="line">        list.add(<span class="string">"ab"</span>);</span><br><span class="line">        list.add(<span class="string">"abc"</span>);</span><br><span class="line">        list.add(<span class="string">"ad"</span>);</span><br><span class="line">      list.removeIf(s-&gt;<span class="string">"a"</span>.equals(s)||<span class="string">"c"</span>.equals(s));</span><br><span class="line">        System.out.println(JSONObject.toJSONString(list));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>异常操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"abcd"</span>);</span><br><span class="line">list.removeIf(s -&gt; <span class="string">"a"</span>.equals(s) || <span class="string">"c"</span>.equals(s));</span><br><span class="line">System.out.println(JSONObject.toJSONString(list));</span><br><span class="line">Exception in thread <span class="string">"main"</span> java.lang.UnsupportedOperationException</span><br><span class="line">        原因</span><br><span class="line"><span class="meta">@SafeVarargs</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"varargs"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T &gt; List &lt; T &gt; asList(T...a)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serial</span> include</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">RandomAccess</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AbstractList做任何操作都是异常</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span> <span class="params">( <span class="keyword">int</span> index, E element)</span></span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This implementation always throws an</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> UnsupportedOperationException&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> UnsupportedOperationException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException     &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span> <span class="params">( <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String [] str=&#123;<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"abcd"</span>&#125;;</span><br><span class="line">      List&lt;String&gt; strs = Arrays.asList(str);</span><br><span class="line">      List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      list.addAll(strs);</span><br><span class="line">      list.removeIf(s-&gt;<span class="string">"a"</span>.equals(s)||<span class="string">"c"</span>.equals(s));</span><br><span class="line">      System.out.println(JSONObject.toJSONString(list));</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;方法一：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;
      
    
    </summary>
    
    
    
      <category term="List" scheme="kkget.github.io/tags/List/"/>
    
  </entry>
  
  <entry>
    <title>字节跳动面经个人搜索答案</title>
    <link href="kkget.github.io/2020/06/15/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E9%9D%A2%E7%BB%8F%E4%B8%AA%E4%BA%BA%E6%90%9C%E7%B4%A2%E7%AD%94%E6%A1%88/"/>
    <id>kkget.github.io/2020/06/15/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E9%9D%A2%E7%BB%8F%E4%B8%AA%E4%BA%BA%E6%90%9C%E7%B4%A2%E7%AD%94%E6%A1%88/</id>
    <published>2020-06-15T02:48:11.000Z</published>
    <updated>2020-09-25T09:20:55.451Z</updated>
    
    <content type="html"><![CDATA[<p>问题来源<a href="https://www.bilibili.com/read/cv4654469" target="_blank" rel="noopener">https://www.bilibili.com/read/cv4654469</a><br>1.线程参数的含义？<br>估计是想问线程池参数的含义吧</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/m1.png" alt="图1" title="">                </div>                <div class="image-caption">图1</div>            </figure><p>int corePoolSize：常驻线程数<br>int maximumPoolSize：线程池同时执行的最大线程数，&gt;=1<br>long keepAliveTime:空闲线程的存活时间<br>TimeUnit unit：keepAliveTime的单位<br>BlockingQueueworkQueue：被提交等待被执行的任务<br>ThreadFactory threadFactory：工作线程的线程工厂<br>RejectedExecutionHandler handler：线程池拒绝策略<br>–可能引申线程个数的设置分为CPU密集型和IO密集型<br>CPU密集型多为cpu运算频繁的：设置CPU核数+1<br>IO密集型：设置cpu核数*10</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Support class for thread pool size</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Nadeem Mohammad</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ThreadPoolUtil</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Each tasks blocks 90% of the time, and works only 10% of its</span></span><br><span class="line"><span class="comment"> *lifetime. That is, I/O intensive pool</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> io intesive Thread pool size</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ioIntesivePoolSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> blockingCoefficient = <span class="number">0.9</span>;</span><br><span class="line"><span class="keyword">return</span> poolSize(blockingCoefficient);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Number of threads = Number of Available Cores / (1 - Blocking</span></span><br><span class="line"><span class="comment"> * Coefficient) where the blocking coefficient is between 0 and 1.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * A computation-intensive task has a blocking coefficient of 0, whereas an</span></span><br><span class="line"><span class="comment"> * IO-intensive task has a value close to 1,</span></span><br><span class="line"><span class="comment"> * so we don't have to worry about the value reaching 1.</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@param</span> blockingCoefficient the coefficient</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@return</span> Thread pool size</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">poolSize</span><span class="params">(<span class="keyword">double</span> blockingCoefficient)</span> </span>&#123;</span><br><span class="line">           <span class="comment">//cpu核数</span></span><br><span class="line"><span class="keyword">int</span> numberOfCores = Runtime.getRuntime().availableProcessors();</span><br><span class="line">  </span><br><span class="line"><span class="keyword">int</span> poolSize = (<span class="keyword">int</span>) (numberOfCores / (<span class="number">1</span> - blockingCoefficient));</span><br><span class="line"><span class="keyword">return</span> poolSize;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.InnoDb的索引实现<br>B+tree<br>3.为什么是用B+tree<br>B+树中的B代表平衡（balance），而不是二叉（binary）<br>二叉查找树<br>二叉树具有以下性质：左子树的键值小于根的键值，右子树的键值大于根的键值。<br>平衡二叉树<br>如果在AVL树中进行插入或删除节点，可能导致AVL树失去平衡，这种失去平衡的二叉树可以概括为四种姿态：LL（左左）、RR（右右）、LR（左右）、RL（右左）。它们的示意图如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/640.jpg" alt="图1" title="">                </div>                <div class="image-caption">图1</div>            </figure><p>B+Tree<br>B+Tree相对于B-Tree有几点不同：<br>非叶子节点只存储键值信息。<br>所有叶子节点之间都有一个链指针。<br>数据记录都存放在叶子节点中。<br>查询速度快，但是占用空间<br>5.Redis的使用，分布式锁的实现</p><ol><li>数据库乐观锁；</li><li>基于Redis的分布式锁；</li><li>基于ZooKeeper的分布式锁</li><li>算了直接用redisson的红锁做吧，引入API接口一调就完了，分布式锁还有守护线程问题，A锁阻塞没有完成任务时，B锁进入导致最后释放了B锁问题，直接调API吧[2020年9月18日15:07:03]</li></ol><p>一  基于数据库<br>a.数据库建一张表，字段方法名并且作为唯一性，当一个方法执行时插入，则相当于获得锁，其他线程将无法访问，方法执行完则释放锁。</p><p>但是上面这种存在问题：</p><p>1、数据库单点，出现故障则将导致系统不可用。</p><p>2、没有失效时间，一旦操作方法异常，导致一直没有解锁，也将导致其他不可用用。</p><p>b.使用select * from user u where username = ‘’ for update 来对记录加上排他锁。操作完成后使用commit命令释放锁。<br>二基于缓存 redis</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOCK_SUCCESS = <span class="string">"OK"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SET_IF_NOT_EXIST = <span class="string">"NX"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SET_WITH_EXPIRE_TIME = <span class="string">"PX"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试获取分布式锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jedis Redis客户端</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockKey 锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestId 请求标识</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expireTime 超期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否获取成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">tryGetDistributedLock</span><span class="params">(Jedis jedis, String lockKey, String requestId, <span class="keyword">int</span> expireTime)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String result = jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (LOCK_SUCCESS.equals(result)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三基于zk<br>大致思路：每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。 判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。 当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。</p><p>ZK中创建和删除节点只能通过Leader服务器来执行，然后将数据同不到所有的Follower机器上，所以性能上不如基于缓存实现。<br>综合比较:1.3性能低，推荐redis<br>如果对数据有强一致性要求，不能放缓存<br>TCP 三次握手和四次挥手<br>为了防止服务器端开启一些无用的连接增加服务器开销以及防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。<br>三次握手也是最少次数的保证</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/m2.png" alt="图2" title="">                </div>                <div class="image-caption">图2</div>            </figure><p>①客户端发送报文===&gt;<br>②服务端收到报文，结束监听，返回一段报文<br>③客户端确认收到TCP报文，并返回最后一段TCP报文<br>即SYN建立连接报文与ACK确认接收报文是在同一次”握手”当中传输的，所以”三次握手”不多也不少，正好让双方明确彼此信息互通<br>所谓的四次挥手即TCP连接的释放(解除)。连接的释放必须是一方主动释放，另一方被动释放<br>都是由客户端发起<br>TCP4次挥手即TCP链接的释放</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/m3.png" alt="图3" title="">                </div>                <div class="image-caption">图3</div>            </figure><p>①客户端想要释放链接，向服务端发送一段TCP报文<br>②服务器端接受，表示确认，进入半关闭状态，并返回一段<br>前”两次挥手”既让服务器端知道了客户端想要释放连接，也让客户端知道了服务器端了解了自己想要释放连接的请求。于是，可以确认关闭客户端到服务器端方向上的连接了<br>③服务器端确认报文，释放链接，再次向客户端发送<br>④客户端收到报文，确认准备释放，向服务端发送一段报文<br>TCP释放连接时之所以需要“四次挥手”,是因为FIN释放连接报文与ACK确认接收报文是分别由第二次和第三次”握手”传输的。为何建立连接时一起传输，释放连接时却要分开传输<br>volatile<br>1.解决的是多核CPU带来的缓存与CPU之间数据的可见性<br>JMM:java内存模型<br>1.线程解锁前，必须把共享变量刷新回主内存<br>2.线程加锁前，必须读取主内存的最新值到自己的工作内存<br>3.加锁与解锁必须是同一把锁</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/m4.png" alt="图4" title="">                </div>                <div class="image-caption">图4</div>            </figure><p>volatile实现内存指令重排，保证可见性和禁止指令重排，<br>可保证一段内存中一个变量的原子性，原生类型都是原子性的。所以java中  volatile long，volatile double都是线程安全的<br>9.乐观锁，悲观锁<br>悲观锁(Pessimistic Lock), 每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。<br>乐观锁(Optimistic Lock), 每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。<br>两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果经常产生冲突，上层应用会不断的进行retry，这样反倒是降低了性能，所以这种情况下用悲观锁就比较合适<br>10.HashMap结构，是否线程安全，ConcurrentHashMap如何保证线程安全。<br>HashMap在java1.7之前底层数据结构是数组+链表，1.8之后是数组+链表+红黑树，<br>在1.7以前的put方法采用的是头插法，当hash碰撞次数到达8，且桶内元素到达64个的时候形成链表，但是在极端情况下会造成链表过长，效率变低，并且在rehash的时候，头插法会造成回环链首尾相连，形成死锁，在java1.8以后采用红黑树，除了添加效率都高，是线程不安全的，不安全示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashMapThread thread0 = <span class="keyword">new</span> HashMapThread();</span><br><span class="line">        HashMapThread thread1 = <span class="keyword">new</span> HashMapThread();</span><br><span class="line">        HashMapThread thread2 = <span class="keyword">new</span> HashMapThread();</span><br><span class="line">        HashMapThread thread3 = <span class="keyword">new</span> HashMapThread();</span><br><span class="line">        HashMapThread thread4 = <span class="keyword">new</span> HashMapThread();</span><br><span class="line">        thread0.start();</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line">        thread4.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashMapThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger ai = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (ai.get() &lt; <span class="number">1000000</span>) &#123;</span><br><span class="line">            map.put(ai.get(), ai.get());</span><br><span class="line">            ai.incrementAndGet();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.通常代替HashMap的安全由HashTable代替，但是多线程下他的put.get方法都是synchronized，效率太低，<br>2.Collections.synchronizedMap(),底层仍是synchronized<br>3.java9实现</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/m5.png" alt="图5" title="">                </div>                <div class="image-caption">图5</div>            </figure><p>ConcurrentHashMap 与 ConcurrentSkipListMap<br>ConcurrentHashMap 加锁<br>ConcurrentSkipListMap  不需要加锁，浪费空间，<br>4.ConcurrentHashMap<br>ConcurrentHashMap如何保证线程安全，在1.7以前由划分segment分段锁机制，共计16个并发级别，隔离级别太大，有很多空间就浪费了，太小就段内的元素过多<br>1.8以后是cas算法C语言写得，无锁算法，put添加的时候，链表+红黑树<br>put方法（无锁添加）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/m6.png" alt="图6" title="">                </div>                <div class="image-caption">图6</div>            </figure><p>11.之前用过哪些设计模式<br>延伸设计模式的单一职责原则，开闭原则等<br>目前项目再用的是责任链设计模型，像动态代理，装饰者，工厂模式，在Spring的源码中都有体现，责任链模式旨在降低处理请求流程的耦合<br> <a href="https://mp.weixin.qq.com/s?__biz=Mzg2ODA3NjA1MA==&mid=2247484453&idx=1&sn=3f4160943cab8fa5f22048b66f7bc588&chksm=ceb09b58f9c7124e65565183cac89fe041f8cec1e06f4e1711d614957ea2ce4bb02a16b8ff3d&token=1711145754&lang=zh_CN#rd" target="_blank" rel="noopener">责任链模式</a>.<br>二面<br>1.说一下B树和B+树的区别<br>索引结构：B-Tree  B+Tree  B：balance<br>B-Tree：平衡二叉树<br>特点：<br>        1.具有数据节点<br>        2.指向下层指针<br>        3.指向数据指针<br>缺页查询,产生IO<br>B+Tree：<br>特点:<br>       1.具有数据节点<br>       2.指向下层指针<br>命中数据3层查找后查询数据指针<br>加载更快，产生更少IO<br>效率：BTree更高，但从IO角度，Mysql选择B+Tree<br>2.说一下HashMap的实现，扩容机制，扩容时如何保证操作<br>put 方法比较复杂，实现步骤大致如下：<br>1、先通过 hash 值计算出 key 映射到哪个桶。<br>2、如果桶上没有碰撞冲突，则直接插入。<br>3、如果出现碰撞冲突了，则需要处理冲突：<br>（1）如果该桶使用红黑树处理冲突，则调用红黑树的方法插入。<br>（2）否则采用传统的链式方法插入。如果链的长度到达临界值，则把链转变为红<br>黑树。<br>4、如果桶中存在重复的键，则为该键替换新值。<br>5、如果 size 大于阈值(8)，则进行扩容</p><p>根据hash算法得到hash码值，也就是数组的索引值，在判断是否有对象，如果没有则放入<br>如果有则先通过equals比较两个对象的内容，如果内容一样，则覆盖value，<br>如果内容不一样，形成链表，1.7后加的放前面，这种情况叫做hash碰撞，这种情况我们是尽可能避免的，如果这里的元素过多的话，插入效率过低，为了避免的话，重写hashcode和equals方法保持一致，这种情况避免不了<br>加载因子，当到达元素个数的0.75，进行扩容，扩容则每个元素重新运算位置，，如果到达100%其他位置可能会不存入，如果太小，则频繁扩容，可浪费空间。这样碰撞的概率会降低，但是极端情况下还是需要查询每个元素比较，效率极低。<br>1.8以后，数组+链表+红黑树<br>当碰撞的个数大于8时，并且总容量大于64时，将链表转为红黑树，除了添加以外其他的效率都高，jdk1.8加到链表末尾，扩容以后不需要运行hash算法计算hashcode值。原来hash表的总长度，加上hash表的现在的位置，就放到第8个位置即可。<br>3.redis扩容机制(渐进式单线程扩容)<br>Redis是一个键值对（key-value pair）数据库服务器，Redis服务器结构是redis.h/redisServer结构表示，Redis服务器中的所有数据库保存在db数组中，数据库的结构是redis.h/redisDb，其中，redisDb结构的dict字典保存了数据库中的所有键值对，所以，说起Redis的扩容机制，指的就是字典中哈希表的rehash（重新散列）操作<br>在实际开发过程中，这个rehash 操作并不是一次性、集中式完成的，而是分多次、渐进式地完成的。<br>　　　　渐进式rehash 的详细步骤：<br>　　　　　　1、为ht[1] 分配空间，让字典同时持有ht[0]和ht[1]两个哈希表<br>　　　　　　2、在几点钟维持一个索引计数器变量rehashidx，并将它的值设置为0，表示rehash 开始<br>　　　　　　3、在rehash 进行期间，每次对字典执行CRUD操作时，程序除了执行指定的操作以外，还会将ht[0]中的数据rehash 到ht[1]表中，并且将rehashidx加一<br>　　　　　　4、当ht[0]中所有数据转移到ht[1]中时，将rehashidx 设置成-1，表示rehash 结束<br>　　　　采用渐进式rehash 的好处在于它采取分而治之的方式，避免了集中式rehash 带来的庞大计算量。<br>作者：13693160765<br>链接：<a href="https://www.jianshu.com/p/ea5a747ade5d" target="_blank" rel="noopener">https://www.jianshu.com/p/ea5a747ade5d</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br>4.SpringAop，ioc的原理，如何解决循环依赖<br>SpringIoc可以对我们应用程序中的java对象做一个集中化的管理，从而使我们从繁琐的new Object()；中解脱出来<br>Spring中AOP的有两种实现方式：<br>1、JDK动态代理<br>2、Cglib动态代理<br>在没有修改原有类的代码的情况下，对原有类的功能进行了增强<br>静态代理模式：静态代理说白了就是在程序运行前就已经存在代理类的字节码文件，代理类和原始类的关系在运行前就已经确定<br>动态代理模式:动态代理类的源码是在程序运行期间通过JVM反射等机制动态生成，代理类和委托类的关系是运行时才确定的<br>使用jdk生成的动态代理的前提是目标类必须有实现的接口。但这里又引入一个问题,如果某个类没有实现接口,就不能使用JDK动态代理,所以Cglib代理就是解决这个问题的<br>Cglib使用的前提是目标类不能为final修饰。因为final修饰的类不能被继承。<br>核心原理是使用动态代理模式在方法执行前后或出现异常时加入相关逻辑。<br>通过定义和前面代码我们可以发现3点：<br>    1.AOP是基于动态代理模式。<br>    2.AOP是方法级别的（要测试的方法不能为static修饰，因为接口中不能存在静态方法，编译就会报错）。<br>    3.AOP可以分离业务代码和关注点代码（重复代码），在执行业务代码时，动态的注入关注点代码。切面就是关注点代码形成的类。<br>循环依赖解决<br>1.在字段上使用@Autowired注解，让Spring决定在合适的时机注入<br>2.用基于setter方法的依赖注入<br>6.两个线程对变量i进行加1操作，结果如何？为什么？如何解决？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">    i=i+<span class="number">1</span>;</span><br><span class="line">    action();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"==&gt;"</span>+Thread.currentThread().getName()+<span class="string">":"</span>+i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(SysUserServiceImpl::add,<span class="string">"t1"</span>);</span><br><span class="line">    Thread t2= <span class="keyword">new</span> Thread(SysUserServiceImpl::add,<span class="string">"t2"</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">==&gt;t1:<span class="number">1</span></span><br><span class="line">==&gt;t2:<span class="number">2</span></span><br><span class="line"></span><br><span class="line">==&gt;t1:<span class="number">2</span></span><br><span class="line">==&gt;t2:<span class="number">1</span></span><br><span class="line"></span><br><span class="line">==&gt;t1:<span class="number">2</span></span><br><span class="line">==&gt;t2:<span class="number">2</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">线程安全问题，对共享变量进行修改</span><br><span class="line">改进方法<span class="number">1</span>:</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (SysUserServiceImpl<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">        i=i+<span class="number">1</span>;</span><br><span class="line">        action();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"==&gt;"</span>+Thread.currentThread().getName()+<span class="string">":"</span>+i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(SysUserServiceImpl::add,<span class="string">"t1"</span>);</span><br><span class="line">    Thread t2= <span class="keyword">new</span> Thread(SysUserServiceImpl::add,<span class="string">"t2"</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span>在多jvm情况下不生效,且效率低下</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">方法<span class="number">2</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger num = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = num.getAndIncrement();</span><br><span class="line">    action(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"由"</span>+i+<span class="string">"==&gt;"</span>+Thread.currentThread().getName()+<span class="string">":"</span>+num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(SysUserServiceImpl::add,<span class="string">"t1"</span>);</span><br><span class="line">    Thread t2= <span class="keyword">new</span> Thread(SysUserServiceImpl::add,<span class="string">"t2"</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法3</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"==&gt;"</span>+Thread.currentThread().getName()+<span class="string">":"</span>+i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> Lock lock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1</span>);</span><br><span class="line">            i=i+<span class="number">1</span>;</span><br><span class="line">            action();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(SysUserServiceImpl::inc,<span class="string">"t1"</span>);</span><br><span class="line">        Thread t2= <span class="keyword">new</span> Thread(SysUserServiceImpl::inc,<span class="string">"t2"</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>7.CAS概念，原子类实现<br>CAS锁是比较偏重的操作？<br>CAS在操作锁时，执行比较并交换操作，相对synchronized瘦锁是比较重的锁，偏向锁在这里避免了CAS操作。UseBiaseLocking对synchronize有用<br>比较并交换，判断取出内存中某时刻的数据并在当下时刻进行交换，缺点：循环时间长，只能保证一个共享变量的原子操作，引来ABA问题?<br> CAS核心是由native修饰的Unsafe类，其中valueOff为内存偏移量地址，变量由volatile修饰。<br>private static final Unsafe unsafe<br>private volatile int value;<br>unsafe类是CAS的核心类，是由C语言native方法来访问的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中getAndAddInt方法，this表示当前对象valueoffset表示内存中的偏移地址，delta是当前value增加的变量<br>CAS即比较当前值与预设值，交换并增加，如果与预想一致就交换，否则再次自旋，所以带来循环开销问题，进而引来ABA问题。<br>原子类的话经典类：AtomicInteger，其共享变量是由volatile修饰的，<br>getAndIncrement是unsafe类操作，底层也是cas</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>8.synchronized<br>synchronized和Lock有什么区别？<br>        ①:synchronized是JVM层面实现的，java提供的关键字，Lock是API层面的锁。<br>        ②:synchronized不需要手动释放锁，底层会自动释放，<br>            Lock则需要手动释放锁，否则有可能导致死锁<br>        ③:synchronized等待不可中断，除非抛出异常或者执行完成<br>            Lock可以中断，通过interrupt()可中断<br>        ④:synchronized是非公平锁<br>            Lock是默认公平锁，当传入false时是非公平锁<br>        ⑤:synchronized不可绑定多个条件<br>            Lock可实现分组唤醒需要唤醒的锁<br>monitorenter<br>monitorexit<br>synchronized通过监控对象来完成，本质是锁一个对象<br>同步方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          System.out.println(<span class="string">"synchronized...."</span>);  </span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修饰方法与修饰代码块产生字节码不同<br>如何实现lock，AQS:AbstractQueuedSynchronizer,AQS是ReentrantLock的核心实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ReentrantLock的子类Sync类的final static子类FairSync和NonFairSync用于支持公平锁和非公平锁。<br>AQS的tryAcquire()和FairSync的tryAcquire()判定是否为公平锁，其实现也是偏向锁UseBiaseLock的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3000897897090466540L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Fair version of tryAcquire.  Don't grant access unless</span></span><br><span class="line"><span class="comment">     * recursive call or no waiters or is first.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                    compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法首先会判断当前线程的状态，如果c==0 说明没有线程正在竞争锁。（反过来，如果c!=0则说明已经有其他线程已经拥有了锁）。如果c==0，则通过CAS将状态设置为acquires(独占锁的acquires为1)，后续每次重入该锁都会+1，每次unlock都会-1，当数据为0时则释放锁资源。其中精妙的部分在于：并发访问时，有可能多个线程同时检测到c为0，此时执行compareAndSetState(0, acquires))设置，可以预见，如果当前线程CAS成功，则其他线程都不会再成功，也就默认当前线程获取了锁，直接作为running线程，很显然这个线程并没有进入等待队列。如果c!=0，首先判断获取锁的线程是不是当前线程，如果是当前线程，则表明为锁重入，继续+1，修改state的状态，此时并没有锁竞争，也非CAS，因此这段代码也非常漂亮的实现了偏向锁。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;问题来源&lt;a href=&quot;https://www.bilibili.com/read/cv4654469&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.bilibili.com/read/cv4654469&lt;/a&gt;&lt;br&gt;1.线程参
      
    
    </summary>
    
    
    
      <category term="面经" scheme="kkget.github.io/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java并发真讨厌</title>
    <link href="kkget.github.io/2020/06/03/Java%E5%B9%B6%E5%8F%91%E7%9C%9F%E8%AE%A8%E5%8E%8C/"/>
    <id>kkget.github.io/2020/06/03/Java%E5%B9%B6%E5%8F%91%E7%9C%9F%E8%AE%A8%E5%8E%8C/</id>
    <published>2020-06-03T05:44:19.000Z</published>
    <updated>2020-06-03T08:06:45.705Z</updated>
    
    <content type="html"><![CDATA[<p>volatile 解决的是多核CPU带来的缓存与CPU之间数据的可见性</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/concurrent/1.png" alt="Alt text" title="">                </div>                <div class="image-caption">Alt text</div>            </figure><p>如何创建一个线程<br>new Thread<br>如何创建一个进程<br>runtime<br>runtime.exec(“”);<br>java无法销毁一个线程，只能改变线程状态<br>thread.Alive() 返回false时已经被销毁<br>thread_main_inner</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/concurrent/2.png" alt="Alt text" title="">                </div>                <div class="image-caption">Alt text</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/concurrent/3.png" alt="Alt text" title="">                </div>                <div class="image-caption">Alt text</div>            </figure><p>2.如何通过JAVA API启动线程<br>thread.start()<br>3.如何指定代码执行顺序</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/concurrent/4.png" alt="Alt text" title="">                </div>                <div class="image-caption">Alt text</div>            </figure><p>join是不管用的  线程必须执行完成。必须start.join</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/concurrent/5.png" alt="Alt text" title="">                </div>                <div class="image-caption">Alt text</div>            </figure><p>countdownLatch可以  信号量可以</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/concurrent/6.png" alt="Alt text" title="">                </div>                <div class="image-caption">Alt text</div>            </figure><p>java1.5怎么实现？<br>threadLoop<br>自旋</p><p>sleep</p><p>Wait</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/concurrent/7.png" alt="Alt text" title="">                </div>                <div class="image-caption">Alt text</div>            </figure><p>到底谁通知了？调用了thread.notify()<br>join方法的实现<br>线程中止方法</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/concurrent/8.png" alt="Alt text" title="">                </div>                <div class="image-caption">Alt text</div>            </figure><p>thread停止</p><p>1.加开关</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/concurrent/9.png" alt="Alt text" title="">                </div>                <div class="image-caption">Alt text</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/concurrent/10.png" alt="Alt text" title="">                </div>                <div class="image-caption">Alt text</div>            </figure><p>2.isInterrupted  *.cpp是C的实现<br>中断仅仅是设置状态，而非中止线程</p><p>为什么放弃stop？<br>防止死锁ddd<br>3.0说明Thread interrupt（）  isinterrupted（）interrupted 的区别和含义</p><p>Thread.interrupt()   设置状态<br>isInterrupted()    判断 返回Boolean<br>interrupted 即判断又清除</p><p>JavaThread  是一个包装  他由GC做垃圾回收<br>JVM thread 可能是一个OS thread JVM 管理</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/concurrent/11.png" alt="Alt text" title="">                </div>                <div class="image-caption">Alt text</div>            </figure><p>3.当遇到异常时，线程池如何捕捉<br>线程池及时关闭</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/concurrent/12.png" alt="Alt text" title="">                </div>                <div class="image-caption">Alt text</div>            </figure><p>如何获取线程的资源消费情况<br>代码层面<br>JMX<br>ThreadMXBean   threadInfo()</p><p>javap -v -p </p><p>字节码的区别</p><p>RPC<br>Request\Response=Command<br>一问一答  命令模式<br>Http  Streaming<br>同步好于异步</p><p>无论是dubbo还是grpc 都是私有协议</p><p>UncaughtExceptionHandler<br>3.请解释偏向锁对 synchronized 与 ReentrantLock 的价值？<br>偏向锁？对synchronize有用</p><p>ReentrantLock已经实现了偏向锁</p><p>UseBiaseLocking  java5 6版本</p><p>OpenJDKviki<br>把线程id 加入头里面  java6-7之间默认打开的</p><p>设计如此<br>wait() 获取锁的对象 释放锁 当前线程被阻塞<br> #LockSupport  park()死锁<br>notify()已经获取锁，唤起被阻塞的线程<br> #LockSupport unpark()<br> #LockSupport park()<br>Java 代码模拟实现 wait() 和 notif y() 以及 notif yAll() 的语<br>义？</p><p>1.当主线程退出时，守候子线程会执行完毕吗？<br>不一定执行<br>ti.setDaemon(true);<br>守候线程执行依赖于执行时间<br>请说明 ShutdownHook 线程的使用场景，以及如何触发执行？<br>比如dubbo，在static方法块里面注册了自己的关闭钩子，完全不可控。在进程退出时直接就把长连接给断开了，导致当前的执行线程无法正常完成，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                logger.info(<span class="string">"Run shutdown hook now."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ProtocolConfig.destroyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">"DubboShutdownHook"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">从Runtime.java和ApplicationShutdownHooks.java的源码中，我们看到并没有一个可以遍历操作shutdownHook的方法。 </span><br><span class="line">Runtime.java仅有的一个removeShutdownHook的方法，对于未写线程名的匿名类来说，无法获取对象的引用，也无法分辨出彼此。 </span><br><span class="line">Runtime runtime=<span class="keyword">new</span> Runtime();</span><br><span class="line">runtime.addShutDownHook(<span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">System.out.println(<span class="string">""</span>)</span><br><span class="line">),<span class="string">""</span>);</span><br></pre></td></tr></table></figure><p>如何确保在主线程退出前，所有线程执行完毕？<br>countdownlatch<br>thread.getThreadGroup();</p><p>如何将普通 Li s t、Set 以及 Map 转化为线程安全对象？<br>把普通的集合转为线程安全的<br>Collections.synchronizedList()方法，都被同步</p><p>Vector所有方法都是同步的  返回fastfail</p><p>CopyOnWriteArrayList   弱一致性的实现</p><p>Arrays#asList(Object. . .) 方法是线程安全的吗？如果不是的话，如何实现替代方案？<br>并非线程安全，三种解决<br>请至少举出三种线程安全的 Set 实现？<br>synchronizedSet<br>CopyOnWriteArraySet<br>CopyOnWriteArrayList<br>CopyOnWriteArraySet<br>ConcurentSkipListSet<br>ConcurrentHashMap 与 ConcurrentSkipListMap<br>ConcurrentHashMap 加锁<br>ConcurrentSkipListMap  不需要加锁，浪费空间，<br>从性能来说，synchronizedSet，Collections.synchronizedList()方法原理都是加了<br>synchronized关键字，性能低下，推荐ConcurrentHashMap系列</p><p>java并发框架</p><p>为什么会出现？<br>知识点穿插<br>reentrantLock与reentrantReadWriteLock的区别<br>不光要去看源码也要去看如何命名的?设计是一部分，<br>重进入的体现:acquire调了N次<br>2020年5月8日21:32:53   优先级<br>相似：都是可进入的，都是互斥的，都是锁<br>2020年3月3日11:04:25更新<br>[<br>都是互斥<br>lock，unlock<br>其中 arg视为信号量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 实现判定是否是公平锁<br> CAS也是一个锁  即内存屏障<br> memory </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setExclusiveOwnerThread</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">    exclusiveOwnerThread = thread;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加一个等待者</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//入队</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>thread[main]-&gt;thread[0]<br>同一个线程不需要锁</p><p>T1 T2 T3<br>T1lock<br>waited Queue -&gt;head -&gt;T2 next -&gt;T3 </p><p>]<br>synchronized实际也是可重入的只不过是jvm层次的<br>ReentrantLock是代码层次的<br>写锁：互斥，<br>读锁：并行，数据的可见性<br>AQS<br>1.trAcquire 判断锁的状态，cas，是否是公平锁<br>2.acquireQueue 入队  Node线程的状态语义，共享/独占模式<br>3.addWaiter<br>acquire（int  arg：信号量）<br>公平锁和非公平锁<br>偏向锁的实现方案<br>UseBiaseLock在java5的6版本</p><p>getstate默认是0<br>CAS   也可以看做一个锁  内存地址锁掉      内存屏障<br>共享模式    独占模式<br>addwaiter  入队  aqs<br>为什么是重进入？<br>acquire调了N次</p><p>renentrantlock   workThrogh<br>Lock与LockInterruptibly的区别<br>获取不到锁的时候进行入队，如果当前线程已被其他线程调用interrupt()方法的时候，这时会返回true，selfInterrupt将状态设置回去<br>AQS设置完会清空状态</p><p>LockInterruptibly判断是否被中断  中断则抛异常</p><p>显式的恢复中断标识<br>抛出interruptedException状态会被清掉</p><p>关注当前线程是否互斥<br>Condition:条件变量</p><p>thread结束后  自动notify了<br>并不会中断或者阻塞线程，但会被JVM利用，然后抛出异常</p><p>JAVA1.4实现countdownlatch<br>–LegacyCountDownLatch<br>–模仿countdownLatch<br>–当count&gt;0 等待<br>–当count&lt;1  return  count–;<br>–当count==0 notifyall</p><p>会发生死锁</p><p>cyclicBarrier<br>reset<br>breakBarrier<br>nextGeneration</p><p>尽可能不要执行完成再reset<br>reset不要轻易去用<br>releaseshared  计数</p><p>lock.condition()<br>condition.signalAll</p><p>线程池  THREADPOOL<br>threadpoolExecutors<br>ScheduledExecutorService</p><p>ctrl +alt +b</p><p>ForkJoinPool</p><p>即时线程池很大  但是存活时间不长<br>newCatchedThreadPool()</p><p>拒绝策略</p><p>如何得到正在获取的线程<br>AbstractExecutorService   netty 实现<br>threadPool   beforeExecutor<br>子线程的创造来自于factory<br>Future</p><p>Future get</p><p>如何优雅的停止Futrue<br>高并发————-<br>1.线程安全<br>2.减少线程同步竞争<br>3.合理利用状态位<br>4.线程池<br>5.超时意识</p><p>Volatile  内存屏障   一段内存的   一个变量的原子性<br>可见性<br>原子性？？  原生类型都是原子性</p><p>long    double    是线程安全的</p><p>屏障==锁？</p><p>AtomicInteger  为什么用int<br>boolean的真是实现就是int      jvm虚拟机<br>volatile.set  就是线程安全的</p><p>CAS    操作是锁非常重的操作<br>synchronized 是瘦锁<br><a href="http://wiki.openjdk.java.net/display/HotSpot/synchronization" target="_blank" rel="noopener">http://wiki.openjdk.java.net/display/HotSpot/synchronization</a></p><p>偏离锁避免CAS操作<br>cpmchg   汇编指令<br>资料参考自：小马哥blibli公开课直播，议题为《面试虐我千百遍，Java 并发真讨厌》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;volatile 解决的是多核CPU带来的缓存与CPU之间数据的可见性&lt;/p&gt;
&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div
      
    
    </summary>
    
    
    
      <category term="并发编程" scheme="kkget.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Thymleaf项目常用操作</title>
    <link href="kkget.github.io/2020/06/02/Thymleaf%E9%A1%B9%E7%9B%AE%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    <id>kkget.github.io/2020/06/02/Thymleaf%E9%A1%B9%E7%9B%AE%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</id>
    <published>2020-06-02T03:45:38.000Z</published>
    <updated>2020-06-02T03:48:36.335Z</updated>
    
    <content type="html"><![CDATA[<p>Thymleaf搭配Springboot完成页面渲染，整理下日常开发中常见常用操作<br>1.下拉框动态被选中</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;label <span class="keyword">for</span>=<span class="string">"inputLevel"</span></span><br><span class="line">class="col-6 col-form-label form-label"&gt;用户服务等级：&lt;/label&gt;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"col-6"</span>&gt;</span><br><span class="line">&lt;select id=<span class="string">"inputLevel"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"form-control"</span> name=<span class="string">"level"</span>&gt;</span><br><span class="line">&lt;option value=<span class="string">""</span></span><br><span class="line">th:selected=<span class="string">"$&#123;null==req?'selected':req.level==null?'select':'false'&#125;"</span>&gt;</span><br><span class="line">全部</span><br><span class="line">&lt;/option&gt;</span><br><span class="line">&lt;option value=<span class="string">"1"</span></span><br><span class="line">th:selected=<span class="string">"$&#123;null==req?'false':req.level=='1'?'select':'false'&#125;"</span>&gt;<span class="number">1</span>级</span><br><span class="line">&lt;/option&gt;</span><br><span class="line">&lt;option value=<span class="string">"2"</span></span><br><span class="line">th:selected=<span class="string">"$&#123;null==req?'false':req.level=='2'?'select':'false'&#125;"</span>&gt;<span class="number">2</span>级</span><br><span class="line">&lt;/option&gt;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>2.动态复选框选中(判断List是否包含)</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">"checkbox"</span></span><br><span class="line">  th:id=<span class="string">"'checkboxResource' + $&#123;resourceEn.key&#125;"</span></span><br><span class="line">  th:checked=<span class="string">"$&#123;null==req.resourceIdList?'false':#arrays.contains(req.resourceIdList, #strings.toString(resourceEn.key))?'checked':'false'&#125;"</span></span><br><span class="line">  name=<span class="string">"resourceIdList"</span> th:value=<span class="string">"$&#123;resourceEn.key&#125;"</span>&gt;</span><br><span class="line">  &lt;label th:text="$&#123;resourceEn.value.name&#125;" th:for="'checkboxResource' + $&#123;resourceEn.key&#125;"&gt;&lt;/label&gt;</span><br></pre></td></tr></table></figure><p>3.onclick动态传值</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;button type=<span class="string">"button"</span> th:text=<span class="string">"*&#123;status&#125;==0?'开启':'关闭'"</span></span><br><span class="line">th:attr=<span class="string">"disabled=*&#123;status==10?true:false&#125;"</span></span><br><span class="line">th:data-id=<span class="string">"$&#123;supplier.id&#125;"</span></span><br><span class="line">th:data-status=<span class="string">"*&#123;status==0?1:0&#125;"</span></span><br><span class="line">th:<span class="class"><span class="keyword">class</span></span>=<span class="string">"*&#123;status ==0||status!=1&#125;?'btn btn-block btn-success':'btn btn-block btn-danger'"</span></span><br><span class="line">onclick="enable(this.getAttribute('data-id'),this.getAttribute('data-status'))"&gt;&lt;/button&gt;</span><br></pre></td></tr></table></figure><p>4.日期格式化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;td th:text=<span class="string">"*&#123;#dates.format(updateTime, 'yyyy-MM-dd HH:mm:ss')&#125;"</span>&gt;</span><br></pre></td></tr></table></figure><p>5.保留小数点后两位</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;label class="ml-3" th:if="*&#123;price ne 1.0&#125;" th:text="*&#123;#numbers.formatDecimal(price * 10,0,2)&#125;"&gt;&lt;/label&gt;</span><br></pre></td></tr></table></figure><p>6.点击详情/编辑回显下拉被选中</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;select <span class="class"><span class="keyword">class</span></span>=<span class="string">"form-control select2bs4"</span> style=<span class="string">"width: 100%;"</span> name=<span class="string">"id"</span>&gt;</span><br><span class="line">&lt;option value="" selected="selected"&gt;==请选择==&lt;/option&gt;</span><br><span class="line">&lt;option th:each="user : $&#123;users&#125;" th:selected="$&#123;user.id eq dept.id&#125;"  th:text="$&#123;user.Name&#125;"&gt;&lt;/option&gt;&lt;/select&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Thymleaf搭配Springboot完成页面渲染，整理下日常开发中常见常用操作&lt;br&gt;1.下拉框动态被选中&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;lin
      
    
    </summary>
    
    
    
      <category term="Thymleaf" scheme="kkget.github.io/tags/Thymleaf/"/>
    
  </entry>
  
  <entry>
    <title>Nginx安装与原理</title>
    <link href="kkget.github.io/2020/06/02/Nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E5%8E%9F%E7%90%86/"/>
    <id>kkget.github.io/2020/06/02/Nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E5%8E%9F%E7%90%86/</id>
    <published>2020-06-02T03:25:02.000Z</published>
    <updated>2020-06-02T03:27:05.484Z</updated>
    
    <content type="html"><![CDATA[<p>官网<a href="http://nginx.org/" target="_blank" rel="noopener">http://nginx.org/</a><br>需要的素材</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pcre-8.37.tar.gz</span><br><span class="line">openssl-1.0.1t.tar.gz</span><br><span class="line">zlib-1.2.8.tar.gz</span><br><span class="line">nginx-1.11.1.tar.gz</span><br></pre></td></tr></table></figure><p>1.1.安装pcre<br>解压缩pcre-xx.tar.gz包<br>进入解压缩目录，执行./configure<br>如果提示，需要提前安装gcc++<br>进入安装光盘目录的软件包(/media/CentOSXX/Package)<br>执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh libstdc++-devel-4.4.7-17.el6.x86_64.rpm</span><br><span class="line">rpm -ivh gcc-c++-4.4.7-17.el6.x86_64.rpm</span><br></pre></td></tr></table></figure><p>./configure完成后，回到pcre目录下执行make，再执行make install<br>2. 安装openssl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、 解压缩openssl-xx.tar.gz包。</span><br><span class="line"><span class="number">2</span>、 进入解压缩目录，执行./config</span><br><span class="line"><span class="number">3</span>、 make &amp;&amp; make install</span><br><span class="line"><span class="number">3</span>. 安装zlib</span><br><span class="line"><span class="number">1</span>、 解压缩zlib-xx.tar.gz包。</span><br><span class="line"><span class="number">2</span>、 进入解压缩目录，执行./configure。</span><br><span class="line"><span class="number">3</span>、 make &amp;&amp; make install</span><br><span class="line"><span class="number">4</span>. 安装nginx</span><br><span class="line"><span class="number">1</span>、 解压缩nginx-xx.tar.gz包。</span><br><span class="line"><span class="number">2</span>、 进入解压缩目录，执行./configure。</span><br><span class="line"><span class="number">3</span>、 make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>nginx无法启动: libpcre.so.1/libpcre.so.0: cannot<br>open shared object file解决办法<br>解决方法：<br>ln -s /usr/local/lib/libpcre.so.1 /lib64<br>32位系统则：<br>ln -s /usr/local/lib/libpcre.so.1 /lib</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">在&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin目录下</span><br><span class="line">执行 .&#x2F;nginx</span><br><span class="line">启动命令 在&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin目录下</span><br><span class="line">执行 .&#x2F;nginx</span><br><span class="line">关闭命令 在&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin目录下</span><br><span class="line">执行 .&#x2F;nginx -s stop</span><br><span class="line">重新加载命令 在&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin目录下</span><br><span class="line">执行 .&#x2F;nginx -s reload</span><br><span class="line">设置nginx为自启动服务</span><br><span class="line">修改linux 启动脚本&#x2F;etc&#x2F;rc.d&#x2F;rc</span><br><span class="line">加入 :</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx</span><br></pre></td></tr></table></figure><p>5、配置nginx.conf</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">......</span><br><span class="line">upstream myserver&#123;</span><br><span class="line">ip_hash;<span class="comment">//ip取哈希码  与反向代理服务器取模 分在那一台</span></span><br><span class="line">server <span class="number">115.28</span><span class="number">.52</span><span class="number">.63</span>:<span class="number">8080</span> weight=<span class="number">1</span>;</span><br><span class="line">server <span class="number">115.28</span><span class="number">.52</span><span class="number">.63</span>:<span class="number">8180</span> weight=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">.....</span><br><span class="line">server&#123;</span><br><span class="line">location / &#123;</span><br><span class="line">.........</span><br><span class="line">proxy_pass http:<span class="comment">//myserver;</span></span><br><span class="line">proxy_connect_timeout <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">.........</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>master-workers的机制的好处<br>首先，对于每个worker进程来说，独立的进程，不需要加锁，<br>所以省掉了锁带来的开销，同时在编程以及问题查找时，也会方<br>便很多。<br>其次，采用独立的进程，可以让互相之间不会影响，一个进程<br>退出后，其它进程还在工作，服务不会中断，master进程则很快启<br>动新的worker进程。当然，worker进程的异常退出，肯定是程序有<br>bug了，异常退出，会导致当前worker上的所有请求失败，不过不<br>会影响到所有请求，所以降低了风险<br>需要设置多少个worker<br>Nginx 同redis类似都采用了io多路复用机制，每个<br>worker都是一个独立的进程，但每个进程里只有一个主线<br>程，通过异步非阻塞的方式来处理请求， 即使是千上万个<br>请求也不在话下。每个worker的线程可以把一个cpu的性<br>能发挥到极致。<br>所以worker数和服务器的cpu数相等是最为适宜的。设<br>少了会浪费cpu，设多了会造成cpu频繁切换上下文带来的<br>损耗。</p><p>//静态资源请求    2个<br>//动态资源请求    4个</p><p>#设置worker数量。<br>worker_processes 4<br>#work绑定cpu(4 work绑定4cpu)。<br>worker_cpu_affinity 0001 0010 0100 1000<br>#work绑定cpu (4 work绑定8cpu中的4个) 。<br>worker_cpu_affinity 0000001 00000010 00000100<br>00001000<br>连接数worker_connection<br>• 这个值是表示每个worker进程所能建立连接的最大值，所以，一个nginx<br>能建立的最大连接数，应该是worker_connections * worker_processes。<br>当然，这里说的是最大连接数，对于HTTP请求本地资源来说，能够支持的<br>最大并发数量是worker_connections * worker_processes，如果是支持<br>http1.1的浏览器每次访问要占两个连接，所以普通的静态访问最大并发数<br>是： worker_connections * worker_processes /2，而如果是HTTP作<br>为反向代理来说，最大并发数量应该是worker_connections *<br>worker_processes/4。因为作为反向代理服务器，每个并发会建立与客<br>户端的连接和与后端服务的连接，会占用两个连接。</p><p>worker_connections * worker_processes /2  静态<br>worker_connections * worker_processes /4  动态</p><p>work最先处理请求 nobody表示权限最低  路人甲<br>use epoll </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;官网&lt;a href=&quot;http://nginx.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://nginx.org/&lt;/a&gt;&lt;br&gt;需要的素材&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;t
      
    
    </summary>
    
    
    
      <category term="Nginx" scheme="kkget.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloudAlibaba服务注册新发现</title>
    <link href="kkget.github.io/2020/06/02/SpringCloudAlibaba%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E6%96%B0%E5%8F%91%E7%8E%B0/"/>
    <id>kkget.github.io/2020/06/02/SpringCloudAlibaba%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E6%96%B0%E5%8F%91%E7%8E%B0/</id>
    <published>2020-06-02T01:13:17.000Z</published>
    <updated>2020-06-03T07:58:33.020Z</updated>
    
    <content type="html"><![CDATA[<p>@(SpringCloudAlibaba)<br>2018.09.21「小马哥技术周报」- 第一期《Spring Cloud 服务发现新选择 - Alibaba Nacos Discovery》基本是刚出来的时候就已经讲了，现在都2020了</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/1.png" alt="Alt text" title="">                </div>                <div class="image-caption">Alt text</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/2.png" alt="Alt text" title="">                </div>                <div class="image-caption">Alt text</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/3.png" alt="Alt text" title="">                </div>                <div class="image-caption">Alt text</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/6.png" alt="Alt text" title="">                </div>                <div class="image-caption">Alt text</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/4.png" alt="Alt text" title="">                </div>                <div class="image-caption">Alt text</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/5.png" alt="Alt text" title="">                </div>                <div class="image-caption">Alt text</div>            </figure><p>不太适合大规模的分布式服务发现ZAB算法<br>内存型，有内存限制</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/7.png" alt="Alt text" title="">                </div>                <div class="image-caption">Alt text</div>            </figure><p>3000-5000节点会出现问题</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/8.png" alt="Alt text" title="">                </div>                <div class="image-caption">Alt text</div>            </figure><p><a href="https://start.spring.io/线上生成" target="_blank" rel="noopener">https://start.spring.io/线上生成</a></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/9.png" alt="Alt text" title="">                </div>                <div class="image-caption">Alt text</div>            </figure><p>Eureka30K个实例后出现GC,以及实例之间的复制，中小型企业不会达到这么高服务<br>除了ZK都是AP</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/10.png" alt="Alt text" title="">                </div>                <div class="image-caption">Alt text</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/11.png" alt="Alt text" title="">                </div>                <div class="image-caption">Alt text</div>            </figure><p>Springcloudcommons as servicediscovery load balancing  circuit break<br>EnableDiscoveryClient是通用API</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DiscoveryClient</span> <span class="keyword">extends</span> <span class="title">Ordered</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> DEFAULT_ORDER = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">description</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;ServiceInstance&gt; <span class="title">getInstances</span><span class="params">(String serviceId)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;String&gt; <span class="title">getServices</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现类的其中一种</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaDiscoveryClient</span> <span class="keyword">implements</span> <span class="title">DiscoveryClient</span> </span>&#123;</span><br><span class="line">    实现方法的返回值的ServiceInstance源码</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServiceInstance</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> String <span class="title">getInstanceId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    zk是唯一标识；eureka是ip+服务名</span><br><span class="line">    <span class="function">String <span class="title">getServiceId</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">getHost</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getPort</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//是否是HTTPs协议or not</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSecure</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">URI <span class="title">getUri</span><span class="params">()</span></span>;</span><br><span class="line">    源信息  zk是又专门存储字段  补充信息</span><br><span class="line">    <span class="function">Map&lt;String, String&gt; <span class="title">getMetadata</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> String <span class="title">getScheme</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Eureka传递序列化或反序列化通过metadata传递，相关的开销比较大<br>超类接口Registration  cloud commons 继承了上面的serviceInstance<br>现在的位置</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/12.png" alt="Alt text" title="">                </div>                <div class="image-caption">Alt text</div>            </figure><p>空继承，为了扩展</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServiceRegistry</span>&lt;<span class="title">R</span> <span class="keyword">extends</span> <span class="title">Registration</span>&gt; </span>&#123;</span><br><span class="line">    注册</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">register</span><span class="params">(R registration)</span></span>;</span><br><span class="line">    de解除注册</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deregister</span><span class="params">(R registration)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setStatus</span><span class="params">(R registration, String status)</span></span>;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">getStatus</span><span class="params">(R registration)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Nacos的实现注册<br> com.alibaba.nacos.api.naming;NamingService<br>现在我下载源码总是下不下来，以为是maven出问题，忘记因为其他项目公用maven，导致maven配置的是私服地址，改下maven就行了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">F:\cloud2020&gt;mvn dependency:resolve -Dclassifier=sources</span><br><span class="line">[INFO] Scanning <span class="keyword">for</span> projects...</span><br><span class="line">Downloading from nexus-server: xxx</span><br><span class="line">ependencies/<span class="number">2.2</span><span class="number">.2</span>.RELEASE/spring-boot-dependencies-<span class="number">2.2</span><span class="number">.2</span>.RELEASE.pom</span><br><span class="line">Downloading from nexus-server: xxx</span><br><span class="line">-dependencies/Hoxton.SR1/spring-cloud-dependencies-Hoxton.SR1.pom</span><br><span class="line">Downloading from nexus-server: xxx</span><br><span class="line">-dependencies/<span class="number">2.1</span><span class="number">.0</span>.RELEASE/spring-cloud-alibaba-dependencies-<span class="number">2.1</span><span class="number">.0</span>.RELEASE.pom</span><br></pre></td></tr></table></figure><p>namingSpace有很多重载方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NamingService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * register a instance to service</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serviceName name of service</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ip          instance ip</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> port        instance port</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NacosException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerInstance</span><span class="params">(String serviceName, String ip, <span class="keyword">int</span> port)</span> <span class="keyword">throws</span> NacosException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * register a instance to service</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serviceName name of service</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> groupName   group of service</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ip          instance ip</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> port        instance port</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NacosException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerInstance</span><span class="params">(String serviceName, String groupName, String ip, <span class="keyword">int</span> port)</span> <span class="keyword">throws</span> NacosException</span>;</span><br><span class="line"></span><br><span class="line">返回的是Instance</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * get all instances of a service</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> serviceName name of service</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> A list of instance</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NacosException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> 服务名   是否健康</span><br><span class="line"><span class="function">List&lt;Instance&gt; <span class="title">getAllInstances</span><span class="params">(String serviceName)</span> <span class="keyword">throws</span> NacosException</span>;</span><br></pre></td></tr></table></figure><p>Ribbon–&gt;server<br>Eureka==&gt;ServiceInstance</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/13.png" alt="Alt text" title="">                </div>                <div class="image-caption">Alt text</div>            </figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">namingSpace以及instance都是Nacos的Api,而registration是Spring 为了适配实现</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Registration registration)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(registration.getServiceId())) &#123;</span><br><span class="line">        log.warn(<span class="string">"No service to register for nacos client..."</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        String serviceId = registration.getServiceId();</span><br><span class="line">        <span class="comment">//this.getNacosInstanceFromRegistration  get  set</span></span><br><span class="line">        Instance instance = <span class="keyword">this</span>.getNacosInstanceFromRegistration(registration);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            放入nacos  注册中心持久化  可以连db</span><br><span class="line">            <span class="keyword">this</span>.namingService.registerInstance(serviceId, instance);</span><br><span class="line">            log.info(<span class="string">"nacos registry, &#123;&#125; &#123;&#125;:&#123;&#125; register finished"</span>, <span class="keyword">new</span> Object[]&#123;serviceId, instance.getIp(), instance.getPort()&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var5) &#123;</span><br><span class="line">            log.error(<span class="string">"nacos registry, &#123;&#125; register failed...&#123;&#125;,"</span>, <span class="keyword">new</span> Object[]&#123;serviceId, registration.toString(), var5&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>放入nacos  注册中心持久化  可以连db<br>this.namingService.registerInstance(serviceId, instance);<br>Nacos  =Naming +config server<br>上面的实现类图可以看到ZK的实现<br>org.springframework.cloud.zookeeper.serviceregistry;<br>ZK的注册 反注册就跟现在的Nacos有一定程度的相似</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/14.png" alt="Alt text" title="">                </div>                <div class="image-caption">Alt text</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/15.png" alt="Alt text" title="">                </div>                <div class="image-caption">Alt text</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/16.png" alt="Alt text" title="">                </div>                <div class="image-caption">Alt text</div>            </figure><p>注解驱动<br>依赖注入<br>外部化配置<br>事件驱动<br>github.com/nacos-group/nacos-spring-project<br>github.com/nacos-group/nacos-spring-boot-project</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/17.png" alt="Alt text" title="">                </div>                <div class="image-caption">Alt text</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/18.png" alt="Alt text" title="">                </div>                <div class="image-caption">Alt text</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/20.png" alt="Alt text" title="">                </div>                <div class="image-caption">Alt text</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.105.116.133:8080/upload/19.png" alt="Alt text" title="">                </div>                <div class="image-caption">Alt text</div>            </figure><p>gateway 是Http协议的一个转换</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;@(SpringCloudAlibaba)&lt;br&gt;2018.09.21「小马哥技术周报」- 第一期《Spring Cloud 服务发现新选择 - Alibaba Nacos Discovery》基本是刚出来的时候就已经讲了，现在都2020了&lt;/p&gt;
&lt;figure clas
      
    
    </summary>
    
    
    
      <category term="SpringCloudAlibaba" scheme="kkget.github.io/tags/SpringCloudAlibaba/"/>
    
  </entry>
  
  <entry>
    <title>拒绝解析又臭又长的JSON</title>
    <link href="kkget.github.io/2020/06/01/%E6%8B%92%E7%BB%9D%E8%A7%A3%E6%9E%90%E5%8F%88%E8%87%AD%E5%8F%88%E9%95%BF%E7%9A%84JSON/"/>
    <id>kkget.github.io/2020/06/01/%E6%8B%92%E7%BB%9D%E8%A7%A3%E6%9E%90%E5%8F%88%E8%87%AD%E5%8F%88%E9%95%BF%E7%9A%84JSON/</id>
    <published>2020-06-01T08:48:28.000Z</published>
    <updated>2020-06-02T07:26:54.873Z</updated>
    
    <content type="html"><![CDATA[<p>author:赵KK</p><p> 在日常工作中，不管是因为接收前端返回约定格式的JSON字符串，还是因为需要约定格式请求第三方服务，或者需要将前端画像xml解析成JSON，再或者需要接入第三方短信，供应商，数据提供商的JSON数据，或是需要提供对外暴露接口的API，可见解析JSON是一个常见操作。</p><p>JSON是一个轻量级的数据交换格式。</p><p>一：表单数据由数据库实体对象接收</p><p>常见的前后端约定字段，指定字段名称后，由数据库实体接收序列化后的表单数据，无序解析。</p><p>二：JSONObject解析</p><p>前后端约定格式，实体接收String类型，通过JSONObject解析JSON，JSONArray等操作</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;children&quot;: [</span><br><span class="line">            </span><br><span class="line">        ],</span><br><span class="line">        &quot;createBy&quot;: &quot;admin&quot;,</span><br><span class="line">        &quot;createTime&quot;: 1521171180000,</span><br><span class="line">        &quot;icon&quot;: &quot;fa fa-gear&quot;,</span><br><span class="line">        &quot;menuId&quot;: 1,</span><br><span class="line">        &quot;menuName&quot;: &quot;系统管理&quot;,</span><br><span class="line">        &quot;menuType&quot;: &quot;M&quot;,</span><br><span class="line">        &quot;orderNum&quot;: &quot;1&quot;,</span><br><span class="line">        &quot;params&quot;: &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;parentId&quot;: 0,</span><br><span class="line">        &quot;perms&quot;: &quot;&quot;,</span><br><span class="line">        &quot;target&quot;: &quot;&quot;,</span><br><span class="line">        &quot;url&quot;: &quot;#&quot;,</span><br><span class="line">        &quot;visible&quot;: &quot;0&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;children&quot;: [</span><br><span class="line">            </span><br><span class="line">        ],</span><br><span class="line">        &quot;createBy&quot;: &quot;admin&quot;,</span><br><span class="line">        &quot;createTime&quot;: 1521171180000,</span><br><span class="line">        &quot;icon&quot;: &quot;fa fa-video-camera&quot;,</span><br><span class="line">        &quot;menuId&quot;: 2,</span><br><span class="line">        &quot;menuName&quot;: &quot;系统监控&quot;,</span><br><span class="line">        &quot;menuType&quot;: &quot;M&quot;,</span><br><span class="line">        &quot;orderNum&quot;: &quot;2&quot;,</span><br><span class="line">        &quot;params&quot;: &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;parentId&quot;: 0,</span><br><span class="line">        &quot;perms&quot;: &quot;&quot;,</span><br><span class="line">        &quot;target&quot;: &quot;&quot;,</span><br><span class="line">        &quot;url&quot;: &quot;#&quot;,</span><br><span class="line">        &quot;visible&quot;: &quot;0&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;children&quot;: [</span><br><span class="line">            </span><br><span class="line">        ],</span><br><span class="line">        &quot;createBy&quot;: &quot;admin&quot;,</span><br><span class="line">        &quot;createTime&quot;: 1521171180000,</span><br><span class="line">        &quot;icon&quot;: &quot;fa fa-bars&quot;,</span><br><span class="line">        &quot;menuId&quot;: 3,</span><br><span class="line">        &quot;menuName&quot;: &quot;系统工具&quot;,</span><br><span class="line">        &quot;menuType&quot;: &quot;M&quot;,</span><br><span class="line">        &quot;orderNum&quot;: &quot;3&quot;,</span><br><span class="line">        &quot;params&quot;: &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;parentId&quot;: 0,</span><br><span class="line">        &quot;perms&quot;: &quot;&quot;,</span><br><span class="line">        &quot;target&quot;: &quot;&quot;,</span><br><span class="line">        &quot;url&quot;: &quot;#&quot;,</span><br><span class="line">        &quot;visible&quot;: &quot;0&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>通过JSONObject以及解析JSONArray获取<br>三：接入第三方API</p><p>接入第三方API，或者按约定调用第三方服务时，你会发现约定了又臭有长的JSON格式，包含特定字段，包含token，包含秘钥，一个详细数据解析接口，上百个字段是常见的，而且多种格式嵌套解析，如果单纯将收到的字符串手动转化成JSONObject，还要判空，还要层层遍历，还要验证数据的有效性，这是在是不小的工作量。</p><p>改造方法：提取最长，覆盖字段最全的作为实体列接收，含有List数据就由List接收，最外层K值由字段接收，涉及类型判断需按约定传不同数值的，定义为枚举，秘钥等特殊Key值MD5加解密传递。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果url是空，则认为是解析历史数据 不需要拼装请求</span></span><br><span class="line">        <span class="keyword">if</span> (url != <span class="keyword">null</span> &amp;&amp; !<span class="string">""</span>.equals(url)) &#123;</span><br><span class="line">            Client client = <span class="keyword">new</span> Client();</span><br><span class="line">            Map&lt;String, String&gt; params = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"mobileReli"</span>.equals(interfaceCode)) &#123; <span class="comment">//if类型判断定义为枚举      </span></span><br><span class="line">                String infoJson = String.format(<span class="string">"&#123;\"phone\":\"%s\",\"name\":\"%s\",\"curDate\":\"%s\"&#125;"</span>,</span><br><span class="line">                        applyRecord.getPhone(), applyRecord.getName(), applyRecord.getFlashblackDate());</span><br><span class="line">                StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">                <span class="keyword">long</span> time = System.currentTimeMillis();<span class="comment">//重复度高的字段由优特实体类接收</span></span><br><span class="line">                sb.append(secret + <span class="string">"!"</span> + appKey + <span class="string">"!"</span> + time + <span class="string">"!"</span> + applyRecord.getName() + <span class="string">"!"</span></span><br><span class="line">                        + applyRecord.getPhone() + <span class="string">"!"</span> + secret + <span class="string">"!"</span>);</span><br><span class="line">                sign = hdsClient.md5(sb.toString());</span><br><span class="line">                String param = String.format(<span class="string">"appKey=%s&amp;infoJson=%s&amp;sign=%s&amp;time=%s"</span>, appKey, infoJson, sign, time);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    jsonData = hdsClient.getResult(url, param);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"DSModel"</span>.equals(interfaceCode)) &#123;</span><br><span class="line">                String infoJson = String.format(<span class="string">"&#123;\"mobile\":\"%s\",\"name\":\"%s\",\"starttime\":\"%s\"&#125;"</span>,</span><br><span class="line">                        applyRecord.getPhone(), applyRecord.getName(), applyRecord.getFlashblackDate());</span><br><span class="line">                StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">                <span class="keyword">long</span> time = System.currentTimeMillis();</span><br><span class="line">                sb.append(secret + <span class="string">"!"</span> + appKey + <span class="string">"!"</span> + time + <span class="string">"!"</span> + applyRecord.getName() + <span class="string">"!"</span></span><br><span class="line">                        + applyRecord.getPhone() + <span class="string">"!"</span> + applyRecord.getFlashblackDate() + <span class="string">"!"</span> + secret + <span class="string">"!"</span>);</span><br><span class="line">                sign = hdsClient.md5(sb.toString());</span><br><span class="line">                String param = String.format(<span class="string">"appKey=%s&amp;infoJson=%s&amp;sign=%s&amp;time=%s"</span>, appKey, infoJson, sign, time);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    jsonData = hdsClient.getResult(url, param);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"addressDetection"</span>.equals(interfaceCode)) &#123;   </span><br><span class="line">                String infoJson = String.format(<span class="string">"&#123;\"phone\":\"%s\",\"address\":\"%s\",\"curDate\":\"%s\"&#125;"</span>,</span><br><span class="line">                        applyRecord.getPhone(), applyRecord.getAddress(), applyRecord.getFlashblackDate());</span><br><span class="line">                StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">                <span class="keyword">long</span> time = System.currentTimeMillis();</span><br><span class="line">                sb.append(secret + <span class="string">"!"</span> + appKey + <span class="string">"!"</span> + time + <span class="string">"!"</span> + applyRecord.getPhone() + <span class="string">"!"</span></span><br><span class="line">                        + applyRecord.getAddress() + <span class="string">"!"</span> + applyRecord.getFlashblackDate() + <span class="string">"!"</span> + secret + <span class="string">"!"</span>);</span><br><span class="line">                sign = hdsClient.md5(sb.toString());</span><br><span class="line">                String param = String.format(<span class="string">"appKey=%s&amp;infoJson=%s&amp;sign=%s&amp;time=%s"</span>, appKey, infoJson, sign, time);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    jsonData = hdsClient.getResult(url, param);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> InterfaceCodeEnum &#123;</span><br><span class="line">    </span><br><span class="line">    InterfaceCode1(<span class="number">1</span>,<span class="string">"mobileReli"</span>),</span><br><span class="line">    InterfaceCode2(<span class="number">2</span>,<span class="string">"DSModel"</span>),</span><br><span class="line">    InterfaceCode3(<span class="number">3</span>,<span class="string">"addressDetection"</span>),</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    InterfaceCodeEnum(Integer code, String name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getNameBycode</span><span class="params">(Integer code)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (code == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (InterfaceCodeEnum a : InterfaceCodeEnum.values()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a.code.equals(code)) &#123;</span><br><span class="line">                <span class="keyword">return</span> a.name;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterfaceCodeResult</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//基础信息</span></span><br><span class="line">    <span class="keyword">private</span> Base base;</span><br><span class="line">    <span class="comment">//秘钥信息</span></span><br><span class="line">    <span class="keyword">private</span> AuthInfo authInfo;</span><br><span class="line">    <span class="comment">//外层字段封装为对象接收</span></span><br><span class="line">    <span class="keyword">private</span> AddressResult  addressResult;</span><br><span class="line">    <span class="comment">//重复多层信息List接收</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Flashblack&gt; flashblack;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当接收到JSON字符串时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">InterfaceCodeResult codeResult=JSONObject.parseObject(InterfaceCodeResult.getRequestInfo(),InterfaceCodeResult<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="keyword">if</span>(PreInterfaceStatus.equals(codeResult.base.getTyep()))&#123;</span><br><span class="line">  <span class="keyword">return</span> JavaConvertUtil.conversion(codeResult, CodeParams<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仅需要判断多个类型即可，对应字段会自动解析，当接收又臭又长的XML解析还需要后端验证时，需要封装Util类进行验证调用</p><p>同步更新至微信公众号，请搜索:赵KK日常技术记录，不定时更新文章内容</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;author:赵KK&lt;/p&gt;
&lt;p&gt; 在日常工作中，不管是因为接收前端返回约定格式的JSON字符串，还是因为需要约定格式请求第三方服务，或者需要将前端画像xml解析成JSON，再或者需要接入第三方短信，供应商，数据提供商的JSON数据，或是需要提供对外暴露接口的API，可见
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
